{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/infiniteProxy/error.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\ncontract Error {\n    error FluidInfiniteProxyError(uint256 errorId_);\n}\n"
    },
    "contracts/infiniteProxy/errorTypes.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |         Infinite proxy            | \n    |__________________________________*/\n\n    /// @notice thrown when an implementation does not exist\n    uint256 internal constant InfiniteProxy__ImplementationNotExist = 50001;\n}\n"
    },
    "contracts/infiniteProxy/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\ncontract Events {\n    /// @notice emitted when a new admin is set\n    event LogSetAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice emitted when a new dummy implementation is set\n    event LogSetDummyImplementation(address indexed oldDummyImplementation, address indexed newDummyImplementation);\n\n    /// @notice emitted when a new implementation is set with certain sigs\n    event LogSetImplementation(address indexed implementation, bytes4[] sigs);\n\n    /// @notice emitted when an implementation is removed\n    event LogRemoveImplementation(address indexed implementation);\n}\n"
    },
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/infiniteProxy/proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"./errorTypes.sol\";\nimport { Error } from \"./error.sol\";\nimport { StorageRead } from \"../libraries/storageRead.sol\";\n\ncontract CoreInternals is StorageRead, Events, Error {\n    struct SigsSlot {\n        bytes4[] value;\n    }\n\n    /// @dev Storage slot with the admin of the contract.\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n    /// validated in the constructor.\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /// @dev Storage slot with the address of the current dummy-implementation.\n    /// This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n    /// validated in the constructor.\n    bytes32 internal constant _DUMMY_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /// @dev use EIP1967 proxy slot (see _DUMMY_IMPLEMENTATION_SLOT) except for first 4 bytes,\n    // which are set to 0. This is combined with a sig which will be set in those first 4 bytes\n    bytes32 internal constant _SIG_SLOT_BASE = 0x000000003ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /// @dev Returns the storage slot which stores the sigs array set for the implementation.\n    function _getSlotImplSigsSlot(address implementation_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\"eip1967.proxy.implementation\", implementation_));\n    }\n\n    /// @dev Returns the storage slot which stores the implementation address for the function sig.\n    function _getSlotSigsImplSlot(bytes4 sig_) internal pure returns (bytes32 result_) {\n        assembly {\n            // or operator sets sig_ in first 4 bytes with rest of bytes32 having default value of _SIG_SLOT_BASE\n            result_ := or(_SIG_SLOT_BASE, sig_)\n        }\n    }\n\n    /// @dev Returns an address `data_` located at `slot_`.\n    function _getAddressSlot(bytes32 slot_) internal view returns (address data_) {\n        assembly {\n            data_ := sload(slot_)\n        }\n    }\n\n    /// @dev Sets an address `data_` located at `slot_`.\n    function _setAddressSlot(bytes32 slot_, address data_) internal {\n        assembly {\n            sstore(slot_, data_)\n        }\n    }\n\n    /// @dev Returns an `SigsSlot` with member `value` located at `slot`.\n    function _getSigsSlot(bytes32 slot_) internal pure returns (SigsSlot storage _r) {\n        assembly {\n            _r.slot := slot_\n        }\n    }\n\n    /// @dev Sets new implementation and adds mapping from implementation to sigs and sig to implementation.\n    function _setImplementationSigs(address implementation_, bytes4[] memory sigs_) internal {\n        require(sigs_.length != 0, \"no-sigs\");\n        bytes32 slot_ = _getSlotImplSigsSlot(implementation_);\n        bytes4[] memory sigsCheck_ = _getSigsSlot(slot_).value;\n        require(sigsCheck_.length == 0, \"implementation-already-exist\");\n\n        for (uint256 i; i < sigs_.length; i++) {\n            bytes32 sigSlot_ = _getSlotSigsImplSlot(sigs_[i]);\n            require(_getAddressSlot(sigSlot_) == address(0), \"sig-already-exist\");\n            _setAddressSlot(sigSlot_, implementation_);\n        }\n\n        _getSigsSlot(slot_).value = sigs_;\n        emit LogSetImplementation(implementation_, sigs_);\n    }\n\n    /// @dev Removes implementation and the mappings corresponding to it.\n    function _removeImplementationSigs(address implementation_) internal {\n        bytes32 slot_ = _getSlotImplSigsSlot(implementation_);\n        bytes4[] memory sigs_ = _getSigsSlot(slot_).value;\n        require(sigs_.length != 0, \"implementation-not-exist\");\n\n        for (uint256 i; i < sigs_.length; i++) {\n            bytes32 sigSlot_ = _getSlotSigsImplSlot(sigs_[i]);\n            _setAddressSlot(sigSlot_, address(0));\n        }\n\n        delete _getSigsSlot(slot_).value;\n        emit LogRemoveImplementation(implementation_);\n    }\n\n    /// @dev Returns bytes4[] sigs from implementation address. If implemenatation is not registered then returns empty array.\n    function _getImplementationSigs(address implementation_) internal view returns (bytes4[] memory) {\n        bytes32 slot_ = _getSlotImplSigsSlot(implementation_);\n        return _getSigsSlot(slot_).value;\n    }\n\n    /// @dev Returns implementation address from bytes4 sig. If sig is not registered then returns address(0).\n    function _getSigImplementation(bytes4 sig_) internal view returns (address implementation_) {\n        bytes32 slot_ = _getSlotSigsImplSlot(sig_);\n        return _getAddressSlot(slot_);\n    }\n\n    /// @dev Returns the current admin.\n    function _getAdmin() internal view returns (address) {\n        return _getAddressSlot(_ADMIN_SLOT);\n    }\n\n    /// @dev Returns the current dummy-implementation.\n    function _getDummyImplementation() internal view returns (address) {\n        return _getAddressSlot(_DUMMY_IMPLEMENTATION_SLOT);\n    }\n\n    /// @dev Stores a new address in the EIP1967 admin slot.\n    function _setAdmin(address newAdmin_) internal {\n        address oldAdmin_ = _getAdmin();\n        require(newAdmin_ != address(0), \"ERC1967: new admin is the zero address\");\n        _setAddressSlot(_ADMIN_SLOT, newAdmin_);\n        emit LogSetAdmin(oldAdmin_, newAdmin_);\n    }\n\n    /// @dev Stores a new address in the EIP1967 implementation slot.\n    function _setDummyImplementation(address newDummyImplementation_) internal {\n        address oldDummyImplementation_ = _getDummyImplementation();\n        _setAddressSlot(_DUMMY_IMPLEMENTATION_SLOT, newDummyImplementation_);\n        emit LogSetDummyImplementation(oldDummyImplementation_, newDummyImplementation_);\n    }\n}\n\ncontract AdminInternals is CoreInternals {\n    /// @dev Only admin guard\n    modifier onlyAdmin() {\n        require(msg.sender == _getAdmin(), \"only-admin\");\n        _;\n    }\n\n    constructor(address admin_, address dummyImplementation_) {\n        _setAdmin(admin_);\n        _setDummyImplementation(dummyImplementation_);\n    }\n\n    /// @dev Sets new admin.\n    function setAdmin(address newAdmin_) external onlyAdmin {\n        _setAdmin(newAdmin_);\n    }\n\n    /// @dev Sets new dummy-implementation.\n    function setDummyImplementation(address newDummyImplementation_) external onlyAdmin {\n        _setDummyImplementation(newDummyImplementation_);\n    }\n\n    /// @dev Adds new implementation address.\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external onlyAdmin {\n        _setImplementationSigs(implementation_, sigs_);\n    }\n\n    /// @dev Removes an existing implementation address.\n    function removeImplementation(address implementation_) external onlyAdmin {\n        _removeImplementationSigs(implementation_);\n    }\n}\n\n/// @title Proxy\n/// @notice This abstract contract provides a fallback function that delegates all calls to another contract using the EVM.\n/// It implements the Instadapp infinite-proxy: https://github.com/Instadapp/infinite-proxy\nabstract contract Proxy is AdminInternals {\n    constructor(address admin_, address dummyImplementation_) AdminInternals(admin_, dummyImplementation_) {}\n\n    /// @dev Returns admin's address.\n    function getAdmin() external view returns (address) {\n        return _getAdmin();\n    }\n\n    /// @dev Returns dummy-implementations's address.\n    function getDummyImplementation() external view returns (address) {\n        return _getDummyImplementation();\n    }\n\n    /// @dev Returns bytes4[] sigs from implementation address If not registered then returns empty array.\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory) {\n        return _getImplementationSigs(impl_);\n    }\n\n    /// @dev Returns implementation address from bytes4 sig. If sig is not registered then returns address(0).\n    function getSigsImplementation(bytes4 sig_) external view returns (address) {\n        return _getSigImplementation(sig_);\n    }\n\n    /// @dev Fallback function that delegates calls to the address returned by Implementations registry.\n    fallback() external payable {\n        address implementation_;\n        assembly {\n            // get slot for sig and directly SLOAD implementation address from storage at that slot\n            implementation_ := sload(\n                // same as in `_getSlotSigsImplSlot()` but we must also load msg.sig from calldata.\n                // msg.sig is first 4 bytes of calldata, so we can use calldataload(0) with a mask\n                or(\n                    // or operator sets sig_ in first 4 bytes with rest of bytes32 having default value of _SIG_SLOT_BASE\n                    _SIG_SLOT_BASE,\n                    and(calldataload(0), 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n                )\n            )\n        }\n\n        if (implementation_ == address(0)) {\n            revert FluidInfiniteProxyError(ErrorTypes.InfiniteProxy__ImplementationNotExist);\n        }\n\n        // Delegate the current call to `implementation`.\n        // This does not return to its internall call site, it will return directly to the external caller.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation_, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            if eq(result, 0) {\n                // delegatecall returns 0 on error.\n                revert(0, returndatasize())\n            }\n\n            return(0, returndatasize())\n        }\n    }\n\n    receive() external payable {\n        // receive method can never have calldata in EVM so no need for any logic here\n    }\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399584 = 10000101010010110100000011111011110010100110100000000011100101001101001101011100000\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n\n    /// @dev gets the least significant bit `firstBit` of a `normal` number (position of rightmost 1 in binary format).\n    /// e.g.\n    /// 5035703444687813576399584 = 10000101010010110100000011111011110010100110100000000011100101001101001101011100000\n    /// firstBit =                                                                                               ^-6--^\n    function leastSignificantBit(uint256 normal) internal pure returns (uint firstBit) {\n        assembly {\n            // If number is 0, revert as there is no least significant bit\n            if iszero(normal) {\n                revert(0, 0)\n            }\n\n            // Find first set bit using binary search\n            let number_ := normal\n            firstBit := 0\n\n            // Check if lower 128 bits are all zero\n            if iszero(and(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) {\n                number_ := shr(0x80, number_)\n                firstBit := 0x80\n            }\n            // Check if lower 64 bits are all zero\n            if iszero(and(number_, 0xFFFFFFFFFFFFFFFF)) {\n                number_ := shr(0x40, number_)\n                firstBit := add(firstBit, 0x40)\n            }\n            // Check if lower 32 bits are all zero\n            if iszero(and(number_, 0xFFFFFFFF)) {\n                number_ := shr(0x20, number_)\n                firstBit := add(firstBit, 0x20)\n            }\n            // Check if lower 16 bits are all zero\n            if iszero(and(number_, 0xFFFF)) {\n                number_ := shr(0x10, number_)\n                firstBit := add(firstBit, 0x10)\n            }\n            // Check if lower 8 bits are all zero\n            if iszero(and(number_, 0xFF)) {\n                number_ := shr(0x8, number_)\n                firstBit := add(firstBit, 0x8)\n            }\n            // Check if lower 4 bits are all zero\n            if iszero(and(number_, 0xF)) {\n                number_ := shr(0x4, number_)\n                firstBit := add(firstBit, 0x4)\n            }\n            // Check if lower 2 bits are all zero\n            if iszero(and(number_, 0x3)) {\n                number_ := shr(0x2, number_)\n                firstBit := add(firstBit, 0x2)\n            }\n            // Check if lowest bit is zero\n            if iszero(and(number_, 0x1)) {\n                firstBit := add(firstBit, 1)\n            }\n            // Add 1 to match the 1-based position counting\n            firstBit := add(firstBit, 1)\n        }\n    }\n}\n"
    },
    "contracts/libraries/bigMathUnsafe.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n// todo: decide for license\n\n// Note: It's advised to use BigMathMinified which covers +90% of use cases, other functions need more thorough audits and testing\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, Valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once to the same number.\nlibrary BigMathUnsafe {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev see {BigMathUnsafe-toBigNumber}, but returns coefficient and exponent too\n    function toBigNumberExtended(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 coefficient, uint256 exponent, uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            exponent := sub(lastBit_, coefficientSize)\n            coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from BigNumber `coefficient` and `exponent`.\n    /// e.g.:\n    /// (coefficient[32bits], exponent[8bits])[40bits] => (normal)\n    /// (2236301563, 51) = 100001010100101101000000111110110000000000000000000000000000000000000000000000000\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011 (2236301563)\n    /// exponent =    0011,0011 (51)\n    /// normal =     10000101010010110100000011111011000000000000000000000000000000000000000000000000000  (5035703442907428892442624)\n    ///                                                ^-------------------- 51(exponent) -------------- ^\n    function fromBigNumber(uint256 coefficient, uint256 exponent) internal pure returns (uint256 normal) {\n        assembly {\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev multiplies a `normal` number with a `bigNumber1` and then divides by `bigNumber2`, with `exponentSize` and\n    /// `exponentMask` being used for both bigNumbers.\n    /// e.g.\n    /// res = normal * bigNumber1 / bigNumber2\n    /// normal:  normal number 281474976710656\n    /// bigNumber1: bigNumber 265046402172 [(0011,1101,1011,0101,1111,1111,0010,0100)Coefficient, (0111,1100)Exponent]\n    /// bigNumber2: bigNumber 178478830197 [(0010 1001 1000 1110 0010 1010 1101 0010)Coefficient, (0111 0101)Exponent\n    /// @return res normal number 53503841411969141\n    function mulDivNormal(\n        uint256 normal,\n        uint256 bigNumber1,\n        uint256 bigNumber2,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 res) {\n        assembly {\n            let coefficient1_ := shr(exponentSize, bigNumber1)\n            let exponent1_ := and(bigNumber1, exponentMask)\n            let coefficient2_ := shr(exponentSize, bigNumber2)\n            let exponent2_ := and(bigNumber2, exponentMask)\n            let X := gt(exponent1_, exponent2_) // bigNumber2 > bigNumber1\n            if X {\n                coefficient1_ := shl(sub(exponent1_, exponent2_), coefficient1_)\n            }\n            if iszero(X) {\n                coefficient2_ := shl(sub(exponent2_, exponent1_), coefficient2_)\n            }\n            // todo should we do this not in assembly so normal SafeMath checks work? e.g. divide by 0 etc.\n            res := div(mul(normal, coefficient1_), coefficient2_)\n        }\n    }\n\n    /// @dev decompiles a `bigNumber` into `coefficient` and `exponent`, based on `exponentSize` and `exponentMask`.\n    /// e.g.\n    /// bigNumber[40bits] => coefficient[32bits], exponent[8bits]\n    /// 1000,0101,0100,1011,0100,0000,1111,1011,0011,0011 =>\n    ///   coefficient = 1000,0101,0100,1011,0100,0000,1111,1011 (2236301563)\n    ///   exponent =    0011,0011 (51)\n    function decompileBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 coefficient, uint256 exponent) {\n        assembly {\n            coefficient := shr(exponentSize, bigNumber)\n            exponent := and(bigNumber, exponentMask)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n\n    /// @dev multiplies a `bigNumber` with normal `number1` and then divides by normal `number2`. `exponentSize` and `exponentMask`\n    /// are used for the input `bigNumber` and the `result` is a BigNumber with `coefficientSize` and `exponentSize`.\n    /// @param bigNumber Coefficient | Exponent. Eg: 8 bits coefficient (1101 0101) and 4 bits exponent (0011)\n    /// @param number1 normal number. Eg:- 32421421413532\n    /// @param number2 normal number. Eg:- 91897739843913\n    /// @param precisionBits precision bits should be set such that, (((Coefficient * number1) << precisionBits) / number2) > max coefficient possible\n    /// @param coefficientSize coefficient size. Eg: 8 bits, 56 btits, etc\n    /// @param exponentSize exponent size. Eg: 4 bits, 12 btits, etc\n    /// @param exponentMask exponent mask. (1 << exponentSize) - 1\n    /// @param roundUp is true then roundUp, default it's round down\n    /// @return result bigNumber * number1 / number2. Note bigNumber can't get directly multiplied or divide by normal numbers.\n    /// TODO: Add an example which can help in better understanding.\n    /// Didn't converted into assembly as overflow checks are good to have\n    function mulDivBigNumber(\n        uint256 bigNumber,\n        uint256 number1,\n        uint256 number2,\n        uint256 precisionBits,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        uint256 exponentMask,\n        bool roundUp\n    ) internal pure returns (uint256 result) {\n        uint256 _resultNumerator = (((bigNumber >> exponentSize) * number1) << precisionBits) / number2;\n        uint256 diff = mostSignificantBit(_resultNumerator) - coefficientSize;\n        _resultNumerator = _resultNumerator >> diff;\n        _resultNumerator = roundUp ? _resultNumerator + 1 : _resultNumerator;\n        uint256 _exponent = (bigNumber & exponentMask) + diff - precisionBits;\n\n        if (_exponent <= exponentMask) {\n            result = (_resultNumerator << exponentSize) + _exponent;\n        } else {\n            revert(\"exponent-overflow\");\n        }\n    }\n\n    // TODO: this function probably has some bugs & needs some updates to make it more efficient\n    /// @dev multiplies a `bigNumber1` with another `bigNumber2`.\n    /// e.g. res = bigNumber1 * bigNumber2 = [(coe1, exp1) * (coe2, exp2)] >> decimal\n    ///          = (coe1*coe2>>overflow, exp1+exp2+overflow-decimal)\n    /// @param bigNumber1          BigNumber format with coefficient and exponent\n    /// @param bigNumber2          BigNumber format with coefficient and exponent\n    /// @param coefficientSize     max size of coefficient, same for both `bigNumber1` and `bigNumber2`\n    /// @param exponentSize        max size of exponent, same for both `bigNumber1` and `bigNumber2`\n    /// @param decimal             decimals in bits\n    /// @return res                BigNumber format with coefficient and exponent\n    function mulBigNumber(\n        uint256 bigNumber1,\n        uint256 bigNumber2,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        uint256 decimal\n    ) internal pure returns (uint256 res) {\n        uint256 coefficient1_;\n        uint256 exponent1_;\n        uint256 coefficient2_;\n        uint256 exponent2_;\n\n        assembly {\n            if eq(bigNumber1, 0) {\n                stop()\n            }\n\n            if eq(bigNumber2, 0) {\n                stop()\n            }\n\n            let exponentMask_ := sub(shl(exponentSize, 1), 1)\n            coefficient1_ := shr(exponentSize, bigNumber1)\n            exponent1_ := and(bigNumber1, exponentMask_)\n            coefficient2_ := shr(exponentSize, bigNumber2)\n            exponent2_ := and(bigNumber2, exponentMask_)\n        }\n\n        // when exponent is 0, it means coefficient last bit could be less than _coefficientSize and we need to calculate the length using mostSignificantBit()\n        // when exponent is greater than 0, coefficient length will always be the same as _coefficientSize\n        uint256 coefficientLen1_ = exponent1_ == 0 ? mostSignificantBit(coefficient1_) : coefficientSize;\n        uint256 coefficientLen2_ = exponent2_ == 0 ? mostSignificantBit(coefficient2_) : coefficientSize;\n\n        assembly {\n            let overflowLen_\n            let resCoefficient_ := mul(coefficient1_, coefficient2_)\n            let midLen_ := add(coefficientLen1_, coefficientLen2_)\n            // the (coefficientLen1_ * coefficientLen2_) length will be among\n            // (coefficientLen1_'s length + coefficientLen2_'s length) and (coefficientLen1_'s length + coefficientLen2_'s length -1)\n            if eq(and(resCoefficient_, shl(sub(midLen_, 1), 1)), 0) {\n                midLen_ := sub(midLen_, 1)\n            }\n            if gt(midLen_, coefficientSize) {\n                overflowLen_ := sub(midLen_, coefficientSize)\n                resCoefficient_ := shr(overflowLen_, resCoefficient_)\n            }\n            let resExponent_ := add(add(exponent1_, exponent2_), overflowLen_)\n            let cond_ := gt(add(resExponent_, coefficientSize), decimal)\n            if iszero(cond_) {\n                stop()\n            }\n            cond_ := gt(decimal, resExponent_)\n            if cond_ {\n                resCoefficient_ := shr(sub(decimal, resExponent_), resCoefficient_)\n                resExponent_ := 0\n            }\n            if iszero(cond_) {\n                resExponent_ := sub(resExponent_, decimal)\n                if gt(resExponent_, sub(shl(exponentSize, 1), 1)) {\n                    revert(0, 0) // overflow error\n                }\n            }\n            res := add(shl(exponentSize, resCoefficient_), resExponent_)\n        }\n    }\n\n    /// @dev divides a `bigNumber1` by `bigNumber2`.\n    /// e.g. res = bigNumber1 / bigNumber2 = [(coe1, exp1) / (coe2, exp2)] << decimal\n    ///          = ((coe1<<precision_)/coe2, exp1+decimal-exp2-precision_)\n    /// @param bigNumber1          BigNumber format with coefficient and exponent\n    /// @param bigNumber2          BigNumber format with coefficient and exponent\n    /// @param coefficientSize     max size of coefficient, same for both `bigNumber1` and `bigNumber2`\n    /// @param exponentSize        max size of exponent, same for both `bigNumber1` and `bigNumber2`\n    /// @param precision_          precision bit\n    /// @param decimal             decimals in bits\n    /// @return res                BigNumber format with coefficient and exponent\n    function divBigNumber(\n        uint256 bigNumber1,\n        uint256 bigNumber2,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        uint256 precision_,\n        uint256 decimal\n    ) internal pure returns (uint256 res) {\n        uint256 coefficient1_;\n        uint256 exponent1_;\n        uint256 coefficient2_;\n        uint256 exponent2_;\n        uint256 resCoefficient_;\n        uint256 overflowLen_;\n\n        assembly {\n            if eq(bigNumber1, 0) {\n                stop()\n            }\n\n            if eq(bigNumber2, 0) {\n                stop()\n            }\n\n            let expeontMask_ := sub(shl(exponentSize, 1), 1)\n            coefficient1_ := shr(exponentSize, bigNumber1)\n            exponent1_ := and(bigNumber1, expeontMask_)\n            coefficient2_ := shr(exponentSize, bigNumber2)\n            exponent2_ := and(bigNumber2, expeontMask_)\n\n            resCoefficient_ := div(shl(precision_, coefficient1_), coefficient2_)\n        }\n        uint256 midLen_ = mostSignificantBit(resCoefficient_);\n        assembly {\n            if gt(midLen_, coefficientSize) {\n                let delta_ := sub(midLen_, coefficientSize)\n                resCoefficient_ := shr(delta_, resCoefficient_)\n                overflowLen_ := delta_\n            }\n            if gt(add(exponent2_, precision_), add(overflowLen_, add(exponent1_, decimal))) {\n                stop()\n            }\n\n            let resExponent_ := sub(sub(add(exponent1_, add(decimal, overflowLen_)), exponent2_), precision_)\n            res := add(shl(exponentSize, resCoefficient_), resExponent_)\n        }\n    }\n}\n"
    },
    "contracts/libraries/bigMathVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @title Extended version of BigMathMinified. Implements functions for normal operators (*, /, etc) modified to interact with big numbers.\n/// @notice this is an optimized version mainly created by taking Fluid vault's codebase into consideration so it's use is limited for other cases.\n// \n// @dev IMPORTANT: for any change here, make sure to uncomment and run the fuzz tests in bigMathVault.t.sol\nlibrary BigMathVault {\n    uint private constant COEFFICIENT_SIZE_DEBT_FACTOR = 35;\n    uint private constant EXPONENT_SIZE_DEBT_FACTOR = 15;\n    uint private constant COEFFICIENT_MAX_DEBT_FACTOR = (1 << COEFFICIENT_SIZE_DEBT_FACTOR) - 1;\n    uint private constant EXPONENT_MAX_DEBT_FACTOR = (1 << EXPONENT_SIZE_DEBT_FACTOR) - 1;\n    uint private constant DECIMALS_DEBT_FACTOR = 16384;\n    uint internal constant MAX_MASK_DEBT_FACTOR = (1 << (COEFFICIENT_SIZE_DEBT_FACTOR + EXPONENT_SIZE_DEBT_FACTOR)) - 1;\n\n    // Having precision as 2**64 on vault\n    uint internal constant PRECISION = 64;\n    uint internal constant TWO_POWER_64 = 1 << PRECISION;\n    // Max bit for 35 bits * 35 bits number will be 70\n    // why do we use 69 then here instead of 70\n    uint internal constant TWO_POWER_69_MINUS_1 = (1 << 69) - 1;\n\n    uint private constant COEFFICIENT_PLUS_PRECISION = COEFFICIENT_SIZE_DEBT_FACTOR + PRECISION; // 99\n    uint private constant COEFFICIENT_PLUS_PRECISION_MINUS_1 = COEFFICIENT_PLUS_PRECISION - 1; // 98\n    uint private constant TWO_POWER_COEFFICIENT_PLUS_PRECISION_MINUS_1 = (1 << COEFFICIENT_PLUS_PRECISION_MINUS_1) - 1; // (1 << 98) - 1;\n    uint private constant TWO_POWER_COEFFICIENT_PLUS_PRECISION_MINUS_1_MINUS_1 =\n        (1 << (COEFFICIENT_PLUS_PRECISION_MINUS_1 - 1)) - 1; // (1 << 97) - 1;\n\n    /// @dev multiplies a `normal` number with a `bigNumber1` and then divides by `bigNumber2`.\n    /// @dev For vault's use case MUST always:\n    ///      - bigNumbers have exponent size 15 bits\n    ///      - bigNumbers have coefficient size 35 bits and have 35th bit always 1 (when exponent > 0 BigMath numbers have max precision)\n    ///        so coefficients must always be in range 17179869184 <= coefficient <= 34359738367.\n    ///      - bigNumber1 (debt factor) always have exponent >= 1 & <= 16384\n    ///      - bigNumber2 (connection factor) always have exponent >= 1 & <= 32767 (15 bits)\n    ///      - bigNumber2 always >= bigNumber1 (connection factor can never be < base branch debt factor)\n    ///      - as a result of previous points, numbers must never be 0\n    ///      - normal is positionRawDebt and is always within 10000 and type(int128).max\n    /// @return normal * bigNumber1 / bigNumber2\n    function mulDivNormal(uint256 normal, uint256 bigNumber1, uint256 bigNumber2) internal pure returns (uint256) {\n        unchecked {\n            // exponent2_ - exponent1_\n            uint netExponent_ = (bigNumber2 & EXPONENT_MAX_DEBT_FACTOR) - (bigNumber1 & EXPONENT_MAX_DEBT_FACTOR);\n            if (netExponent_ < 129) {\n                // (normal * coefficient1_) / (coefficient2_ << netExponent_);\n                return ((normal * (bigNumber1 >> EXPONENT_SIZE_DEBT_FACTOR)) /\n                    ((bigNumber2 >> EXPONENT_SIZE_DEBT_FACTOR) << netExponent_));\n            }\n            // else:\n            // biggest possible nominator: type(int128).max * 35bits max      =  5846006549323611672814739330865132078589370433536\n            // smallest possible denominator: 17179869184 << 129 (= 1 << 163) = 11692013098647223345629478661730264157247460343808\n            // -> can only ever be 0\n            return 0;\n        }\n    }\n\n    /// @dev multiplies a `bigNumber` with normal `number1` and then divides by `TWO_POWER_64`.\n    /// @dev For vault's use case (calculating new branch debt factor after liquidation):\n    ///      - number1 is debtFactor, intialized as TWO_POWER_64 and reduced from there, hence it's always <= TWO_POWER_64 and always > 0.\n    ///      - bigNumber is branch debt factor, which starts as ((X35 << 15) | (1 << 14)) and reduces from there.\n    ///      - bigNumber must have have exponent size 15 bits and be >= 1 & <= 16384\n    ///      - bigNumber must have coefficient size 35 bits and have 35th bit always 1 (when exponent > 0 BigMath numbers have max precision)\n    ///        so coefficients must always be in range 17179869184 <= coefficient <= 34359738367.\n    /// @param bigNumber Coefficient | Exponent.\n    /// @param number1 normal number.\n    /// @return result bigNumber * number1 / TWO_POWER_64.\n    function mulDivBigNumber(uint256 bigNumber, uint256 number1) internal pure returns (uint256 result) {\n        // using unchecked as we are only at 1 place in Vault and it won't overflow there.\n        unchecked {\n            uint256 _resultNumerator = (bigNumber >> EXPONENT_SIZE_DEBT_FACTOR) * number1; // bigNumber coefficient * normal number\n            // 99% chances are that most sig bit should be 64 + 35 - 1 or 64 + 35 - 2\n            // diff = mostSigBit. Can only ever be >= 35 and <= 98\n            uint256 diff = (_resultNumerator > TWO_POWER_COEFFICIENT_PLUS_PRECISION_MINUS_1)\n                ? COEFFICIENT_PLUS_PRECISION\n                : (_resultNumerator > TWO_POWER_COEFFICIENT_PLUS_PRECISION_MINUS_1_MINUS_1)\n                    ? COEFFICIENT_PLUS_PRECISION_MINUS_1\n                    : BigMathMinified.mostSignificantBit(_resultNumerator);\n\n            // diff = difference in bits to make the _resultNumerator 35 bits again\n            diff = diff - COEFFICIENT_SIZE_DEBT_FACTOR;\n            _resultNumerator = _resultNumerator >> diff;\n            // starting exponent is 16384, so exponent should never get 0 here\n            result = (bigNumber & EXPONENT_MAX_DEBT_FACTOR) + diff;\n            if (result > PRECISION) {\n                result = (_resultNumerator << EXPONENT_SIZE_DEBT_FACTOR) + result - PRECISION; // divides by TWO_POWER_64 by reducing exponent by 64\n            } else {\n                // if number1 is small, e.g. 1e4 and bigNumber is also small e.g. coefficient = 17179869184 & exponent is at 50\n                // then: resultNumerator = 171798691840000, diff most significant bit = 48, ending up with diff = 13\n                // for exponent in result we end up doing: 50 + 13 - 64 -> underflowing exponent.\n                // this should never happen anyway, but if it does better to revert than to continue with unknown effects.\n                revert(); // debt factor should never become a BigNumber with exponent <= 0\n            }\n        }\n    }\n\n    /// @dev multiplies a `bigNumber1` with another `bigNumber2`.\n    /// @dev For vault's use case (calculating connection factor of merged branches userTickDebtFactor * connectionDebtFactor *... connectionDebtFactor):\n    ///      - bigNumbers must have have exponent size 15 bits and be >= 1 & <= 32767\n    ///      - bigNumber must have coefficient size 35 bits and have 35th bit always 1 (when exponent > 0 BigMath numbers have max precision)\n    ///        so coefficients must always be in range 17179869184 <= coefficient <= 34359738367.\n    /// @dev sum of exponents from `bigNumber1` `bigNumber2` should be > 16384.\n    /// e.g. res = bigNumber1 * bigNumber2 = [(coe1, exp1) * (coe2, exp2)] >> decimal\n    ///          = (coe1*coe2>>overflow, exp1+exp2+overflow-decimal)\n    /// @param bigNumber1          BigNumber format with coefficient and exponent.\n    /// @param bigNumber2          BigNumber format with coefficient and exponent.\n    /// @return                    BigNumber format with coefficient and exponent\n    function mulBigNumber(uint256 bigNumber1, uint256 bigNumber2) internal pure returns (uint256) {\n        unchecked {\n            // coefficient1_ * coefficient2_\n            uint resCoefficient_ = (bigNumber1 >> EXPONENT_SIZE_DEBT_FACTOR) *\n                (bigNumber2 >> EXPONENT_SIZE_DEBT_FACTOR);\n            // res coefficient at min can be 17179869184 * 17179869184 =  295147905179352825856 (= 1 << 68; 69th bit as 1)\n            // res coefficient at max can be 34359738367 * 34359738367 = 1180591620648691826689 (X35 * X35 fits in 70 bits)\n            uint overflowLen_ = resCoefficient_ > TWO_POWER_69_MINUS_1\n                ? COEFFICIENT_SIZE_DEBT_FACTOR\n                : COEFFICIENT_SIZE_DEBT_FACTOR - 1;\n            // overflowLen_ is either 34 or 35\n            resCoefficient_ = resCoefficient_ >> overflowLen_;\n\n            // bigNumber2 is connection factor\n            // exponent1_ + exponent2_ + overflowLen_ - decimals\n            uint resExponent_ = ((bigNumber1 & EXPONENT_MAX_DEBT_FACTOR) +\n                (bigNumber2 & EXPONENT_MAX_DEBT_FACTOR) +\n                overflowLen_);\n            if (resExponent_ < DECIMALS_DEBT_FACTOR) {\n                // for this ever to happen, the debt factors used to calculate connection factors would have to be at extremely\n                // unrealistic values. Like e.g.\n                // branch3 (debt factor X35 << 15 | 16383) got merged into branch2 (debt factor X35 << 15 | 8190)\n                // -> connection factor (divBigNumber): ((coe1<<precision_)/coe2>>overflowLen, exp1+decimal+overflowLen-exp2-precision_) so:\n                // coefficient: (X35<<64)/X35 >> 30 = 17179869184\n                // exponent: 8190+16384+30-16383-64 = 8157.\n                // result: 17179869184 << 15 | 8157\n                // and then branch2 into branch1 (debt factor X35 << 15 | 22). -> connection factor:\n                // coefficient: (X35<<64)/X35 >> 30 = 17179869184\n                // exponent: 22+16384+30-8190-64 = 8182.\n                // result: 17179869184 << 15 | 8182\n                // connection factors sum up (mulBigNumber): (coe1*coe2>>overflow, exp1+exp2+overflow-decimal)\n                // exponent: 8182+8157+35-16384=16374-16384=-10. underflow.\n                // this should never happen anyway, but if it does better to revert than to continue with unknown effects.\n                revert();\n            }\n            resExponent_ = resExponent_ - DECIMALS_DEBT_FACTOR;\n\n            if (resExponent_ > EXPONENT_MAX_DEBT_FACTOR) {\n                // if resExponent_ is not within limits that means user's got ~100% (something like 99.999999999999...)\n                // this situation will probably never happen and this basically means user's position is ~100% liquidated\n                return MAX_MASK_DEBT_FACTOR;\n            }\n\n            return ((resCoefficient_ << EXPONENT_SIZE_DEBT_FACTOR) | resExponent_);\n        }\n    }\n\n    /// @dev divides a `bigNumber1` by `bigNumber2`.\n    /// @dev For vault's use case (calculating connectionFactor_ = baseBranchDebtFactor / currentBranchDebtFactor) bigNumbers MUST always:\n    ///      - have exponent size 15 bits and be >= 1 & <= 16384\n    ///      - have coefficient size 35 bits and have 35th bit always 1 (when exponent > 0 BigMath numbers have max precision)\n    ///        so coefficients must always be in range 17179869184 <= coefficient <= 34359738367.\n    ///      - as a result of previous points, numbers must never be 0\n    /// e.g. res = bigNumber1 / bigNumber2 = [(coe1, exp1) / (coe2, exp2)] << decimal\n    ///          = ((coe1<<precision_)/coe2, exp1+decimal-exp2-precision_)\n    /// @param bigNumber1          BigNumber format with coefficient and exponent\n    /// @param bigNumber2          BigNumber format with coefficient and exponent\n    /// @return                    BigNumber format with coefficient and exponent\n    /// Returned connection factor can only ever be >= baseBranchDebtFactor (c = x*100/y with both x,y > 0 & x,y <= 100: c can only ever be >= x)\n    function divBigNumber(uint256 bigNumber1, uint256 bigNumber2) internal pure returns (uint256) {\n        unchecked {\n            // (coefficient1_ << PRECISION) / coefficient2_\n            uint256 resCoefficient_ = ((bigNumber1 >> EXPONENT_SIZE_DEBT_FACTOR) << PRECISION) /\n                (bigNumber2 >> EXPONENT_SIZE_DEBT_FACTOR);\n            // nominator at min 17179869184 << 64 = 316912650057057350374175801344. at max 34359738367 << 64 = 633825300095667956674642051072.\n            // so min value resCoefficient_ 9223372037123211264 (64 bits) vs max 36893488146345361408 (fits in 65 bits)\n\n            // mostSigBit will be PRECISION + 1 or PRECISION\n            uint256 overflowLen_ = ((resCoefficient_ >> PRECISION) == 1) ? (PRECISION + 1) : PRECISION;\n            // Overflow will be PRECISION - COEFFICIENT_SIZE_DEBT_FACTOR or (PRECISION + 1) - COEFFICIENT_SIZE_DEBT_FACTOR\n            // Meaning 64 - 35 = 29 or 65 - 35 = 30\n            overflowLen_ = overflowLen_ - COEFFICIENT_SIZE_DEBT_FACTOR;\n            resCoefficient_ = resCoefficient_ >> overflowLen_;\n\n            // exponent1_ will always be less than or equal to 16384\n            // exponent2_ will always be less than or equal to 16384\n            // Even if exponent2_ is 0 (not possible) & resExponent_ = DECIMALS_DEBT_FACTOR then also resExponent_ will be less than max limit, so no overflow\n            // result exponent = (exponent1_ + DECIMALS_DEBT_FACTOR + overflowLen_) - (exponent2_ + PRECISION);\n            uint256 resExponent_ = ((bigNumber1 & EXPONENT_MAX_DEBT_FACTOR) + // exponent1_\n                DECIMALS_DEBT_FACTOR + // DECIMALS_DEBT_FACTOR is 100% as it is percentage value\n                overflowLen_); // addition part resExponent_ here min 16414, max 32798\n            // reuse overFlowLen_ variable for subtraction sum of exponent\n            overflowLen_ = (bigNumber2 & EXPONENT_MAX_DEBT_FACTOR) + PRECISION; // subtraction part overflowLen_ here: min 65, max 16448\n            if (resExponent_ > overflowLen_) {\n                resExponent_ = resExponent_ - overflowLen_;\n\n                return ((resCoefficient_ << EXPONENT_SIZE_DEBT_FACTOR) | resExponent_);\n            }\n\n            // Can happen if bigNumber1 exponent is < 35 (35+16384+29 = 16448) and bigNumber2 exponent is e.g. max 16384.\n            // this would mean a branch with a normal big debt factor (bigNumber2) is merged into a base branch with an extremely small\n            // debt factor (bigNumber1).\n            // this should never happen anyway, but if it does better to revert than to continue with unknown effects.\n            revert(); // connection factor should never become a BigNumber with exponent <= 0\n        }\n    }\n}\n"
    },
    "contracts/libraries/bytesSliceAndConcat.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nlibrary BytesSliceAndConcat {\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesConcat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    ) internal pure returns (bytes memory tempBytes) {\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    // @dev taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function bytesSlice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory tempBytes) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/libraries/dexCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\nimport { DexSlotsLink } from \"./dexSlotsLink.sol\";\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// @DEV ATTENTION: ON ANY CHANGES HERE, MAKE SURE THAT LOGIC IN VAULTS WILL STILL BE VALID.\n// SOME CODE THERE ASSUMES DEXCALCS == LIQUIDITYCALCS.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n/// @notice implements calculation methods used for Fluid Dex such as updated withdrawal / borrow limits.\nlibrary DexCalcs {\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) &\n            X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ = block.timestamp - ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> DexSlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ = block.timestamp - ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> DexSlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n}\n"
    },
    "contracts/libraries/dexLiteSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex Lite.\nlibrary DexLiteSlotsLink {\n    /// @dev storage slot for is auth mapping\n    uint256 internal constant DEX_LITE_IS_AUTH_SLOT = 0;\n    /// @dev storage slot for dexes list\n    uint256 internal constant DEX_LITE_DEXES_LIST_SLOT = 1;\n    /// @dev storage slot for is dex variables\n    uint256 internal constant DEX_LITE_DEX_VARIABLES_SLOT = 2;\n    /// @dev storage slot for center price shift\n    uint256 internal constant DEX_LITE_CENTER_PRICE_SHIFT_SLOT = 3;\n    /// @dev storage slot for range shift\n    uint256 internal constant DEX_LITE_RANGE_SHIFT_SLOT = 4;\n    /// @dev storage slot for threshold shift\n    uint256 internal constant DEX_LITE_THRESHOLD_SHIFT_SLOT = 5;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // DexVariables\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_FEE = 0;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT = 13;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS = 20;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE = 22;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE = 23;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS = 63;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE = 82;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT = 83;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT = 97;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE = 111;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT = 112;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT = 119;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS = 126;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS = 131;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED = 136;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED = 196;\n\n    // CenterPriceShift\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP = 0;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME = 33;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE = 57;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE = 85;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT = 113;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT = 133;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP = 153;\n\n    // RangeShift\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT = 0;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT = 14;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT = 28;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP = 48;\n\n    // ThresholdShift\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT = 0;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT = 7;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT = 14;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP = 34;\n\n    // --------------------------------\n    // @dev stacked uint256 swapData for LogSwap event\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_DEX_ID = 0;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_SWAP_0_TO_1 = 64;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN = 65;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT = 125;\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, bytes32 key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n}\n"
    },
    "contracts/libraries/dexSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n\n    /***********************************|\n    |           SafeApprove             | \n    |__________________________________*/\n\n    /// @notice thrown when safe approve from for an ERC20 fails\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\n}\n"
    },
    "contracts/libraries/fluidProtocolTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\ninterface IFluidProtocol {\n    function TYPE() external view returns (uint256);\n}\n\n/// @notice implements helper methods to filter Fluid protocols by a certain type\nlibrary FluidProtocolTypes {\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\n\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\n    ///      `type_` must be a listed constant type of this library.\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\n    ///      DEX protocol type vaults.\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\n        uint256 curType_;\n        uint256 filteredProtocols_ = addresses_.length;\n        for (uint256 i; i < addresses_.length; ) {\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\n                curType_ = protocolType_;\n            } catch {\n                curType_ = VAULT_T1_TYPE;\n            }\n\n            if (curType_ != type_) {\n                addresses_[i] = address(0);\n                --filteredProtocols_;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        filtered_ = new address[](filteredProtocols_);\n        uint256 index_;\n        unchecked {\n            for (uint256 i; i < addresses_.length; ) {\n                if (addresses_[i] != address(0)) {\n                    filtered_[index_] = addresses_[i];\n                    ++index_;\n                }\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/liquidityCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\nimport { LiquiditySlotsLink } from \"./liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\n/// borrow rate, withdrawal / borrow limits, revenue amount.\nlibrary LiquidityCalcs {\n    error FluidLiquidityCalcsError(uint256 errorId_);\n\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\n    event BorrowRateMaxCap();\n\n    /// @dev constants as from Liquidity variables.sol\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                  CALC EXCHANGE PRICES                  /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\n    function calcExchangePrices(\n        uint256 exchangePricesAndConfig_\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        // Extracting exchange prices\n        supplyExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n            X64;\n        borrowExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n            X64;\n\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\n        }\n\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\n\n        unchecked {\n            // last timestamp can not be > current timestamp\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\n\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                X15;\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // calculate new borrow exchange price.\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\n            borrowExchangePrice_ +=\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\n\n            // FOR SUPPLY EXCHANGE PRICE:\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\n            //\n            // Example:\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\n            // yield is 10 (so half a year must have passed).\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 25%) = 62,5%\n            // supplyRate = (40% * (100% - 10%)) * 62,5% = 36% * 62,5% = 22.5%\n            // increase in supplyExchangePrice, assuming 100 as previous price.\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\n\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\n\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\n\n            if (temp_ == 1) {\n                // if no raw supply: no exchange price update needed\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\n            if (temp_ & 1 == 1) {\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n                temp_ = temp_ >> 1;\n\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\n                // in the if statement a little above.\n\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\n                // so ratioSupplyYield must come out as 2.5 (250%).\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\n                temp_ =\n                    // utilization * (100% + 100% / supplyRatio)\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\n                    (FOUR_DECIMALS);\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\n            } else {\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n                temp_ = temp_ >> 1;\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\n\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\n                temp_ =\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\n                    (1e27 *\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\n                        (FOUR_DECIMALS + temp_)) /\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\n            }\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\n\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\n            if (borrowRatio_ & 1 == 1) {\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\n\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\n            } else {\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\n            }\n\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\n\n            // 2. calculate supply rate\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\n            // but more suppliers not earning interest.\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\n                temp_ * // ratioSupplyYield\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\n\n            // 3. calculate increase in supply exchange price\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                     CALC REVENUE                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\n    /// and the current balance of the Fluid liquidity contract for the token.\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\n    /// @return revenueAmount_ collectable revenue amount\n    function calcRevenue(\n        uint256 totalAmounts_,\n        uint256 exchangePricesAndConfig_,\n        uint256 liquidityTokenBalance_\n    ) internal view returns (uint256 revenueAmount_) {\n        // @dev no need to super-optimize this method as it is only used by admin\n\n        // calculate the new exchange prices based on earned interest\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\n\n        // total supply = interest free + with interest converted from raw\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\n\n        if (totalSupply_ > 0) {\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n            // ensure there is no possible case because of rounding etc. where this would revert,\n            // explicitly check if >\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\n            // can only be revenue.\n        } else {\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\n            revenueAmount_ = liquidityTokenBalance_;\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ =\n                block.timestamp -\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ =\n                block.timestamp -\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC RATES                        /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev Calculates new borrow rate from utilization for a token\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\n        // extract rate version: 4 bits (0xF) starting from bit 0\n        uint256 rateVersion_ = (rateData_ & 0xF);\n\n        if (rateVersion_ == 1) {\n            rate_ = calcRateV1(rateData_, utilization_);\n        } else if (rateVersion_ == 2) {\n            rate_ = calcRateV2(rateData_, utilization_);\n        } else {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\n        }\n\n        if (rate_ > X16) {\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\n            // this is unlikely to ever happen if configs stay within expected levels.\n            rate_ = X16;\n            // emit event to more easily become aware\n            emit BorrowRateMaxCap();\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e2 precision\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v1 (one kink) ------------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // else utilization is greater than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            x1_ = kink1_;\n            x2_ = FOUR_DECIMALS; // 100%\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e4 precision\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v2 (two kinks) -----------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 156 bits => 100-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink1\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n            if (utilization_ < kink2_) {\n                // if utilization is less than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                x1_ = kink1_;\n                x2_ = kink2_;\n            } else {\n                // else utilization is greater than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n                x1_ = kink2_;\n                x2_ = FOUR_DECIMALS;\n            }\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\n    function getTotalSupply(\n        uint256 totalAmounts_,\n        uint256 supplyExchangePrice_\n    ) internal pure returns (uint256 totalSupply_) {\n        // totalSupply_ => supplyInterestFree\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\n    function getTotalBorrow(\n        uint256 totalAmounts_,\n        uint256 borrowExchangePrice_\n    ) internal pure returns (uint256 totalBorrow_) {\n        // totalBorrow_ => borrowInterestFree\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n}\n"
    },
    "contracts/libraries/liquiditySlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_CONFIGS2_MAPPING_SLOT = 11;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n    uint256 internal constant BITS_EXCHANGE_PRICES_USES_CONFIGS2 = 249;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // Configs2\n    uint256 internal constant BITS_CONFIGS2_MAX_UTILIZATION = 0;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
    },
    "contracts/libraries/reentrancyLock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nlibrary ReentrancyLock {\n    // bytes32(uint256(keccak256(\"FLUID_REENTRANCY_LOCK\")) - 1)\n    bytes32 constant REENTRANCY_LOCK_SLOT = 0xb9cde754d19acfff2b3ccabc66f256d3563a0bc5805da4205f01a9bda38a2df7;\n\n    function lock() internal {\n        assembly {\n            if tload(REENTRANCY_LOCK_SLOT) { revert(0, 0) }\n            tstore(REENTRANCY_LOCK_SLOT, 1)\n        }\n    }\n\n    function unlock() internal {\n        assembly { tstore(REENTRANCY_LOCK_SLOT, 0) }\n    }\n}\n"
    },
    "contracts/libraries/safeApprove.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe approve, e.g. ERC20 safeApprove\nlibrary SafeApprove {\n    error FluidSafeApproveError(uint256 errorId_);\n\n    /// @dev Approve `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L97-L127\n    function safeApprove(\n        address token_,\n        address to_,\n        uint256 amount_\n    ) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            success_ := call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n\n            // Set success to whether the call reverted, if not we check it either\n            // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.\n            if and(iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))), success_) {\n                success_ := iszero(or(iszero(extcodesize(token_)), returndatasize())) \n            }\n        }\n\n        if (!success_) {\n            revert FluidSafeApproveError(ErrorTypes.SafeApprove__ApproveFailed);\n        }\n    }\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/libraries/storageRead.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n/// @notice implements a method to read uint256 data from storage at a bytes32 storage slot key.\ncontract StorageRead {\n    function readFromStorage(bytes32 slot_) public view returns (uint256 result_) {\n        assembly {\n            result_ := sload(slot_) // read value from the storage slot\n        }\n    }\n}\n"
    },
    "contracts/libraries/tickMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n/// @title library that calculates number \"tick\" and \"ratioX96\" from this: ratioX96 = (1.0015^tick) * 2^96\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\n/// @dev \"tick\" supports between -32767 and 32767. \"ratioX96\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\nlibrary TickMath {\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\n    int24 internal constant MIN_TICK = -32767;\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\n    int24 internal constant MAX_TICK = 32767;\n\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\n\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\n    uint256 internal constant MIN_RATIOX96 = 37075072;\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\n\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\n    uint256 internal constant _1E26 = 1e26;\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\n        assembly {\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\n\n            if gt(absTick_, MAX_TICK) {\n                revert(0, 0)\n            }\n            let factor_ := FACTOR00\n            if and(absTick_, 0x1) {\n                factor_ := FACTOR01\n            }\n            if and(absTick_, 0x2) {\n                factor_ := shr(128, mul(factor_, FACTOR02))\n            }\n            if and(absTick_, 0x4) {\n                factor_ := shr(128, mul(factor_, FACTOR03))\n            }\n            if and(absTick_, 0x8) {\n                factor_ := shr(128, mul(factor_, FACTOR04))\n            }\n            if and(absTick_, 0x10) {\n                factor_ := shr(128, mul(factor_, FACTOR05))\n            }\n            if and(absTick_, 0x20) {\n                factor_ := shr(128, mul(factor_, FACTOR06))\n            }\n            if and(absTick_, 0x40) {\n                factor_ := shr(128, mul(factor_, FACTOR07))\n            }\n            if and(absTick_, 0x80) {\n                factor_ := shr(128, mul(factor_, FACTOR08))\n            }\n            if and(absTick_, 0x100) {\n                factor_ := shr(128, mul(factor_, FACTOR09))\n            }\n            if and(absTick_, 0x200) {\n                factor_ := shr(128, mul(factor_, FACTOR10))\n            }\n            if and(absTick_, 0x400) {\n                factor_ := shr(128, mul(factor_, FACTOR11))\n            }\n            if and(absTick_, 0x800) {\n                factor_ := shr(128, mul(factor_, FACTOR12))\n            }\n            if and(absTick_, 0x1000) {\n                factor_ := shr(128, mul(factor_, FACTOR13))\n            }\n            if and(absTick_, 0x2000) {\n                factor_ := shr(128, mul(factor_, FACTOR14))\n            }\n            if and(absTick_, 0x4000) {\n                factor_ := shr(128, mul(factor_, FACTOR15))\n            }\n\n            let precision_ := 0\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\n                // we round up in the division so getTickAtRatio of the output price is always consistent\n                if mod(factor_, 0x100000000) {\n                    precision_ := 1\n                }\n            }\n            ratioX96 := add(shr(32, factor_), precision_)\n        }\n    }\n\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\n    /// @return perfectRatioX96 perfect ratio for the above tick\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\n        assembly {\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\n                revert(0, 0)\n            }\n\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\n            let factor_\n\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\n            }\n\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\n\n            // for tick = 16384\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\n            // 4626198540796508716348404308345255985.06131964639489434655721\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\n                tick := or(tick, 0x4000)\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\n            }\n            // for tick = 8192\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\n            // 21508599537851153911767490449162.3037648642153898377655505172\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\n                tick := or(tick, 0x2000)\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\n            }\n            // for tick = 4096\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\n            // 46377364670549310883002866648.9777607649742626173648716941385\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\n                tick := or(tick, 0x1000)\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\n            }\n            // for tick = 2048\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\n            // 2153540449365864845468344760.06357108484096046743300420319322\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\n                tick := or(tick, 0x800)\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\n            }\n            // for tick = 1024\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\n            // 464062544207767844008185024.950588990554136265212906454481127\n            if iszero(lt(factor_, 464062544207767844008185025)) {\n                tick := or(tick, 0x400)\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\n            }\n            // for tick = 512\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\n            // 215421109505955298802281577.031879604792139232258508172947569\n            if iszero(lt(factor_, 215421109505955298802281577)) {\n                tick := or(tick, 0x200)\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\n            }\n            // for tick = 256\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\n            // 146772309890508740607270614.667650899656438875541505058062410\n            if iszero(lt(factor_, 146772309890508740607270615)) {\n                tick := or(tick, 0x100)\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\n            }\n            // for tick = 128\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\n            // 121149622323187099817270416.157248837742741760456796835775887\n            if iszero(lt(factor_, 121149622323187099817270416)) {\n                tick := or(tick, 0x80)\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\n            }\n            // for tick = 64\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\n            // 110067989135437147685980801.568068573422377364214113968609839\n            if iszero(lt(factor_, 110067989135437147685980801)) {\n                tick := or(tick, 0x40)\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\n            }\n            // for tick = 32\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\n            // 104913292358707887270979599.831816586773651266562785765558183\n            if iszero(lt(factor_, 104913292358707887270979600)) {\n                tick := or(tick, 0x20)\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\n            }\n            // for tick = 16\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\n            // 102427189924701091191840927.762844039579442328381455567932128\n            if iszero(lt(factor_, 102427189924701091191840928)) {\n                tick := or(tick, 0x10)\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\n            }\n            // for tick = 8\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\n            // 101206318935480056907421312.890625\n            if iszero(lt(factor_, 101206318935480056907421313)) {\n                tick := or(tick, 0x8)\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\n            }\n            // for tick = 4\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\n            // 100601351350506250000000000\n            if iszero(lt(factor_, 100601351350506250000000000)) {\n                tick := or(tick, 0x4)\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\n            }\n            // for tick = 2\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\n            // 100300225000000000000000000\n            if iszero(lt(factor_, 100300225000000000000000000)) {\n                tick := or(tick, 0x2)\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\n            }\n            // for tick = 1\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\n            // 100150000000000000000000000\n            if iszero(lt(factor_, 100150000000000000000000000)) {\n                tick := or(tick, 0x1)\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\n            }\n            if iszero(cond) {\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\n            }\n            if cond {\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\n                tick := not(tick)\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\n            }\n            // perfect ratio should always be <= ratioX96\n            // not sure if it can ever be bigger but better to have extra checks\n            if gt(perfectRatioX96, ratioX96) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { Structs } from \"./structs.sol\";\n\ncontract Events is Structs {\n    /// @notice emitted when allowed auths are updated\n    event LogUpdateAuths(AddressBool[] authsStatus);\n\n    /// @notice emitted when allowed guardians are updated\n    event LogUpdateGuardians(AddressBool[] guardiansStatus);\n\n    /// @notice emitted when revenue collector address is updated\n    event LogUpdateRevenueCollector(address indexed revenueCollector);\n\n    /// @notice emitted when status is changed (paused / unpaused)\n    event LogChangeStatus(uint256 indexed newStatus);\n\n    /// @notice emitted when user classes are updated\n    event LogUpdateUserClasses(AddressUint256[] userClasses);\n\n    /// @notice emitted when token configs are updated\n    event LogUpdateTokenConfigs(TokenConfig[] tokenConfigs);\n\n    /// @notice emitted when user supply configs are updated\n    event LogUpdateUserSupplyConfigs(UserSupplyConfig[] userSupplyConfigs);\n\n    /// @notice emitted when user borrow configs are updated\n    event LogUpdateUserBorrowConfigs(UserBorrowConfig[] userBorrowConfigs);\n\n    /// @notice emitted when a user gets certain tokens paused\n    event LogPauseUser(address user, address[] supplyTokens, address[] borrowTokens);\n\n    /// @notice emitted when a user gets certain tokens unpaused\n    event LogUnpauseUser(address user, address[] supplyTokens, address[] borrowTokens);\n\n    /// @notice emitted when token rate data is updated with rate data v1\n    event LogUpdateRateDataV1s(RateDataV1Params[] tokenRateDatas);\n\n    /// @notice emitted when token rate data is updated with rate data v2\n    event LogUpdateRateDataV2s(RateDataV2Params[] tokenRateDatas);\n\n    /// @notice emitted when revenue is collected\n    event LogCollectRevenue(address indexed token, uint256 indexed amount);\n\n    /// @notice emitted when exchange prices and borrow rate are updated\n    event LogUpdateExchangePrices(\n        address indexed token,\n        uint256 indexed supplyExchangePrice,\n        uint256 indexed borrowExchangePrice,\n        uint256 borrowRate,\n        uint256 utilization\n    );\n\n    /// @notice emitted when user withdrawal limit is updated\n    event LogUpdateUserWithdrawalLimit(address user, address token, uint256 newLimit);\n}\n"
    },
    "contracts/liquidity/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { LiquidityCalcs } from \"../../libraries/liquidityCalcs.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { SafeTransfer } from \"../../libraries/safeTransfer.sol\";\nimport { Events } from \"./events.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { CommonHelpers } from \"../common/helpers.sol\";\nimport { IFluidLiquidityAdmin } from \"../interfaces/iLiquidity.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\n\nabstract contract AdminModuleConstants is Error {\n    /// @dev hard cap value for max borrow limit, used as sanity check. Usually 10x of total supply.\n    uint256 public immutable NATIVE_TOKEN_MAX_BORROW_LIMIT_CAP;\n\n    constructor(uint256 nativeTokenMaxBorrowLimitCap_) {\n        if (nativeTokenMaxBorrowLimitCap_ == 0) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__InvalidParams);\n        }\n\n        NATIVE_TOKEN_MAX_BORROW_LIMIT_CAP = nativeTokenMaxBorrowLimitCap_;\n    }\n}\n\n/// @notice Fluid Liquidity Governance only related methods\nabstract contract GovernanceModule is IFluidLiquidityAdmin, CommonHelpers, Events, AdminModuleConstants {\n    /// @notice only governance guard\n    modifier onlyGovernance() {\n        if (_getGovernanceAddr() != msg.sender) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__OnlyGovernance);\n        }\n        _;\n    }\n\n    /// @dev checks that `value_` is a valid address (not zero address)\n    function _checkValidAddress(address value_) internal pure {\n        if (value_ == address(0)) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__AddressZero);\n        }\n    }\n\n    /// @dev checks that `value_` address is a contract\n    function _checkIsContract(address value_) internal view {\n        if (value_.code.length == 0) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__AddressNotAContract);\n        }\n    }\n\n    /// @dev checks that `value_` address is a contract (which includes address zero check) or the native token\n    function _checkIsContractOrNativeAddress(address value_) internal view {\n        if (value_.code.length == 0 && value_ != NATIVE_TOKEN_ADDRESS) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__AddressNotAContract);\n        }\n    }\n\n    /// @dev checks that `token_` decimals are between `MIN_TOKEN_DECIMALS` and `MAX_TOKEN_DECIMALS` (inclusive).\n    function _checkTokenDecimalsRange(address token_) internal view {\n        uint8 decimals_ = token_ == NATIVE_TOKEN_ADDRESS ? NATIVE_TOKEN_DECIMALS : IERC20Metadata(token_).decimals();\n        if (decimals_ < MIN_TOKEN_DECIMALS || decimals_ > MAX_TOKEN_DECIMALS) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__TokenInvalidDecimalsRange);\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateAuths(AddressBool[] calldata authsStatus_) external onlyGovernance {\n        uint256 length_ = authsStatus_.length;\n        for (uint256 i; i < length_; ) {\n            _checkValidAddress(authsStatus_[i].addr);\n\n            _isAuth[authsStatus_[i].addr] = authsStatus_[i].value ? 1 : 0;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateAuths(authsStatus_);\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateGuardians(AddressBool[] calldata guardiansStatus_) external onlyGovernance {\n        uint256 length_ = guardiansStatus_.length;\n        for (uint256 i; i < length_; ) {\n            _checkValidAddress(guardiansStatus_[i].addr);\n\n            _isGuardian[guardiansStatus_[i].addr] = guardiansStatus_[i].value ? 1 : 0;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateGuardians(guardiansStatus_);\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateRevenueCollector(address revenueCollector_) external onlyGovernance {\n        _checkValidAddress(revenueCollector_);\n\n        _revenueCollector = revenueCollector_;\n\n        emit LogUpdateRevenueCollector(revenueCollector_);\n    }\n}\n\nabstract contract AuthInternals is Error, CommonHelpers, Events {\n    /// @dev computes rata data packed uint256 for version 1 rate input params telling desired values\n    /// at different uzilitation points (0%, kink, 100%)\n    /// @param rataDataV1Params_ rata data params for a given token\n    /// @return rateData_ packed uint256 rate data\n    function _computeRateDataPackedV1(\n        RateDataV1Params memory rataDataV1Params_\n    ) internal pure returns (uint256 rateData_) {\n        if (rataDataV1Params_.rateAtUtilizationZero > X16) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__RATE_AT_UTIL_ZERO);\n        }\n        if (rataDataV1Params_.rateAtUtilizationKink > X16) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__RATE_AT_UTIL_KINK);\n        }\n        if (rataDataV1Params_.rateAtUtilizationMax > X16) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__RATE_AT_UTIL_MAX);\n        }\n        if (\n            // kink must not be 0 or >= 100% (being 0 or 100% would lead to division through 0 at calculation time)\n            rataDataV1Params_.kink == 0 ||\n            rataDataV1Params_.kink >= FOUR_DECIMALS ||\n            // for the last part of rate curve a spike increase must be present as utilization grows.\n            // declining rate is supported before kink. kink to max must be increasing.\n            // @dev Note rates can be equal, that leads to a 0 slope which is supported in calculation code.\n            rataDataV1Params_.rateAtUtilizationKink > rataDataV1Params_.rateAtUtilizationMax\n        ) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__InvalidParams);\n        }\n\n        rateData_ =\n            1 | // version\n            (rataDataV1Params_.rateAtUtilizationZero << LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) |\n            (rataDataV1Params_.kink << LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) |\n            (rataDataV1Params_.rateAtUtilizationKink << LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) |\n            (rataDataV1Params_.rateAtUtilizationMax << LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX);\n    }\n\n    /// @dev computes rata data packed uint256 for rate version 2 input params telling desired values\n    /// at different uzilitation points (0%, kink1, kink2, 100%)\n    /// @param rataDataV2Params_ rata data params for a given token\n    /// @return rateData_ packed uint256 rate data\n    function _computeRateDataPackedV2(\n        RateDataV2Params memory rataDataV2Params_\n    ) internal pure returns (uint256 rateData_) {\n        if (rataDataV2Params_.rateAtUtilizationZero > X16) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__RATE_AT_UTIL_ZERO);\n        }\n        if (rataDataV2Params_.rateAtUtilizationKink1 > X16) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__RATE_AT_UTIL_KINK1);\n        }\n        if (rataDataV2Params_.rateAtUtilizationKink2 > X16) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__RATE_AT_UTIL_KINK2);\n        }\n        if (rataDataV2Params_.rateAtUtilizationMax > X16) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__RATE_AT_UTIL_MAX_V2);\n        }\n        if (\n            // kink can not be 0, >= 100% or >= kink2 (would lead to division through 0 at calculation time)\n            rataDataV2Params_.kink1 == 0 ||\n            rataDataV2Params_.kink1 >= FOUR_DECIMALS ||\n            rataDataV2Params_.kink1 >= rataDataV2Params_.kink2 ||\n            // kink2 can not be >= 100% (must be > kink1 already checked)\n            rataDataV2Params_.kink2 >= FOUR_DECIMALS ||\n            // for the last part of rate curve a spike increase must be present as utilization grows.\n            // declining rate is supported before kink2. kink2 to max must be increasing.\n            // @dev Note rates can be equal, that leads to a 0 slope which is supported in calculation code.\n            rataDataV2Params_.rateAtUtilizationKink2 > rataDataV2Params_.rateAtUtilizationMax\n        ) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__InvalidParams);\n        }\n\n        rateData_ =\n            2 | // version\n            (rataDataV2Params_.rateAtUtilizationZero << LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) |\n            (rataDataV2Params_.kink1 << LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) |\n            (rataDataV2Params_.rateAtUtilizationKink1 <<\n                LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) |\n            (rataDataV2Params_.kink2 << LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) |\n            (rataDataV2Params_.rateAtUtilizationKink2 <<\n                LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) |\n            (rataDataV2Params_.rateAtUtilizationMax << LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX);\n    }\n\n    /// @dev updates the exchange prices in storage for `token_` and returns `supplyExchangePrice_` and `borrowExchangePrice_`.\n    /// Recommended to use only in a method that later calls `_updateExchangePricesAndRates()`.\n    function _updateExchangePrices(\n        address token_\n    ) internal returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        uint256 exchangePricesAndConfig_ = _exchangePricesAndConfig[token_];\n\n        // calculate the new exchange prices based on earned interest\n        (supplyExchangePrice_, borrowExchangePrice_) = LiquidityCalcs.calcExchangePrices(exchangePricesAndConfig_);\n\n        // ensure values written to storage do not exceed the dedicated bit space in packed uint256 slots\n        if (supplyExchangePrice_ > X64 || borrowExchangePrice_ > X64) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__EXCHANGE_PRICES);\n        }\n\n        // write updated exchangePrices_ for token to storage\n        _exchangePricesAndConfig[token_] =\n            (exchangePricesAndConfig_ &\n                // mask to update bits: 58-218 (timestamp and exchange prices)\n                0xfffffffff80000000000000000000000000000000000000003ffffffffffffff) |\n            (block.timestamp << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) |\n            (supplyExchangePrice_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) |\n            (borrowExchangePrice_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE);\n\n        emit LogUpdateExchangePrices(\n            token_,\n            supplyExchangePrice_,\n            borrowExchangePrice_,\n            exchangePricesAndConfig_ & X16, // borrow rate is unchanged -> read from exchangePricesAndConfig_\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14 // utilization is unchanged -> read from exchangePricesAndConfig_\n        );\n\n        return (supplyExchangePrice_, borrowExchangePrice_);\n    }\n\n    /// @dev updates the exchange prices + rates in storage for `token_` and returns `supplyExchangePrice_` and `borrowExchangePrice_`\n    function _updateExchangePricesAndRates(\n        address token_\n    ) internal returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        uint256 exchangePricesAndConfig_ = _exchangePricesAndConfig[token_];\n        // calculate the new exchange prices based on earned interest\n        (supplyExchangePrice_, borrowExchangePrice_) = LiquidityCalcs.calcExchangePrices(exchangePricesAndConfig_);\n\n        uint256 totalAmounts_ = _totalAmounts[token_];\n\n        // calculate updated ratios\n        // set supplyRatio_ = supplyWithInterest here, using that value for total supply before finish calc supplyRatio\n        uint256 supplyRatio_ = ((BigMathMinified.fromBigNumber(\n            (totalAmounts_ & X64),\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        ) * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n        // set borrowRatio_ = borrowWithInterest here, using that value for total borrow before finish calc borrowRatio\n        uint256 borrowRatio_ = ((BigMathMinified.fromBigNumber(\n            (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        ) * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n\n        uint256 supplyInterestFree_ = BigMathMinified.fromBigNumber(\n            (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64,\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        uint256 borrowInterestFree_ = BigMathMinified.fromBigNumber(\n            // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n            (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE),\n            DEFAULT_EXPONENT_SIZE,\n            DEFAULT_EXPONENT_MASK\n        );\n\n        // calculate utilization: totalBorrow / totalSupply. If no supply, utilization must be 0 (avoid division by 0)\n        uint256 utilization_ = 0;\n        if (supplyRatio_ > 0 || supplyInterestFree_ > 0) {\n            utilization_ = (((borrowRatio_ + borrowInterestFree_) * FOUR_DECIMALS) /\n                (supplyRatio_ + supplyInterestFree_));\n        }\n\n        // finish calculating supply & borrow ratio\n        // ########## calculating supply ratio ##########\n        // supplyRatio_ holds value of supplyWithInterest below\n        if (supplyRatio_ > supplyInterestFree_) {\n            // supplyRatio_ is ratio with 1 bit as 0 as supply interest raw is bigger\n            supplyRatio_ = ((supplyInterestFree_ * FOUR_DECIMALS) / supplyRatio_) << 1;\n            // because of checking to divide by bigger amount, ratio can never be > 100%\n        } else if (supplyRatio_ < supplyInterestFree_) {\n            // supplyRatio_ is ratio with 1 bit as 1 as supply interest free is bigger\n            supplyRatio_ = (((supplyRatio_ * FOUR_DECIMALS) / supplyInterestFree_) << 1) | 1;\n            // because of checking to divide by bigger amount, ratio can never be > 100%\n        } else {\n            // supplies match exactly (supplyWithInterest  == supplyInterestFree)\n            if (supplyRatio_ > 0) {\n                // supplies are not 0 -> set ratio to 1 (with first bit set to 0, doesn't matter)\n                supplyRatio_ = FOUR_DECIMALS << 1;\n            } else {\n                // if total supply = 0\n                supplyRatio_ = 0;\n            }\n        }\n\n        // ########## calculating borrow ratio ##########\n        // borrowRatio_ holds value of borrowWithInterest below\n        if (borrowRatio_ > borrowInterestFree_) {\n            // borrowRatio_ is ratio with 1 bit as 0 as borrow interest raw is bigger\n            borrowRatio_ = ((borrowInterestFree_ * FOUR_DECIMALS) / borrowRatio_) << 1;\n            // because of checking to divide by bigger amount, ratio can never be > 100%\n        } else if (borrowRatio_ < borrowInterestFree_) {\n            // borrowRatio_ is ratio with 1 bit as 1 as borrow interest free is bigger\n            borrowRatio_ = (((borrowRatio_ * FOUR_DECIMALS) / borrowInterestFree_) << 1) | 1;\n            // because of checking to divide by bigger amount, ratio can never be > 100%\n        } else {\n            // borrows match exactly (borrowWithInterest  == borrowInterestFree)\n            if (borrowRatio_ > 0) {\n                // borrows are not 0 -> set ratio to 1 (with first bit set to 0, doesn't matter)\n                borrowRatio_ = FOUR_DECIMALS << 1;\n            } else {\n                // if total borrows = 0\n                borrowRatio_ = 0;\n            }\n        }\n\n        // updated borrow rate from utilization\n        uint256 borrowRate_ = LiquidityCalcs.calcBorrowRateFromUtilization(_rateData[token_], utilization_);\n\n        // ensure values written to storage do not exceed the dedicated bit space in packed uint256 slots\n        if (supplyExchangePrice_ > X64 || borrowExchangePrice_ > X64) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__EXCHANGE_PRICES);\n        }\n        if (utilization_ > X14) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__UTILIZATION);\n        }\n\n        // write updated exchangePrices_ for token to storage\n        _exchangePricesAndConfig[token_] =\n            (exchangePricesAndConfig_ &\n                // mask to update bits: 0-15 (borrow rate), 30-43 (utilization), 58-248 (timestamp, exchange prices, ratios)\n                0xfe000000000000000000000000000000000000000000000003fff0003fff0000) |\n            borrowRate_ | // already includes an overflow check in `calcBorrowRateFromUtilization`\n            (utilization_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) |\n            (block.timestamp << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) |\n            (supplyExchangePrice_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) |\n            (borrowExchangePrice_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) |\n            // ratios can never be > 100%, no overflow check needed\n            (supplyRatio_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) |\n            (borrowRatio_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO);\n\n        emit LogUpdateExchangePrices(token_, supplyExchangePrice_, borrowExchangePrice_, borrowRate_, utilization_);\n\n        return (supplyExchangePrice_, borrowExchangePrice_);\n    }\n}\n\n/// @notice Fluid Liquidity Auths only related methods\nabstract contract AuthModule is AuthInternals, GovernanceModule {\n    using BigMathMinified for uint256;\n\n    /// @dev max update on storage threshold as a sanity check. threshold is in 1e2, so 500 = 5%.\n    /// A higher threshold is not allowed as it would cause the borrow rate to be updated too rarely.\n    uint256 private constant MAX_TOKEN_CONFIG_UPDATE_THRESHOLD = 500;\n\n    /// @dev only auths guard\n    modifier onlyAuths() {\n        if (_isAuth[msg.sender] & 1 != 1 && _getGovernanceAddr() != msg.sender) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__OnlyAuths);\n        }\n        _;\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function collectRevenue(address[] calldata tokens_) external onlyAuths {\n        address payable revenueCollector_ = payable(_revenueCollector);\n        if (revenueCollector_ == address(0)) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__RevenueCollectorNotSet);\n        }\n\n        uint256 length_ = tokens_.length;\n        for (uint256 i; i < length_; ) {\n            _checkIsContractOrNativeAddress(tokens_[i]);\n\n            bool isNativeToken_ = tokens_[i] == NATIVE_TOKEN_ADDRESS;\n\n            // get revenue amount with updated interest etc.\n            uint256 revenueAmount_ = LiquidityCalcs.calcRevenue(\n                _totalAmounts[tokens_[i]],\n                _exchangePricesAndConfig[tokens_[i]],\n                isNativeToken_ ? address(this).balance : IERC20(tokens_[i]).balanceOf(address(this))\n            );\n\n            if (revenueAmount_ > 0) {\n                // transfer token amount to revenueCollector address\n                if (isNativeToken_) {\n                    SafeTransfer.safeTransferNative(revenueCollector_, revenueAmount_);\n                } else {\n                    SafeTransfer.safeTransfer(tokens_[i], revenueCollector_, revenueAmount_);\n                }\n            }\n\n            emit LogCollectRevenue(tokens_[i], revenueAmount_);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function changeStatus(uint256 newStatus_) external onlyAuths {\n        if (newStatus_ == 0 || newStatus_ > 2) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__InvalidParams);\n        }\n\n        _status = newStatus_;\n\n        emit LogChangeStatus(newStatus_);\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateRateDataV1s(RateDataV1Params[] calldata tokensRateData_) external onlyAuths {\n        uint256 length_ = tokensRateData_.length;\n        uint256 rateData_;\n\n        for (uint256 i; i < length_; ) {\n            _checkIsContractOrNativeAddress(tokensRateData_[i].token);\n\n            // token that is being listed must have between 6 and 18 decimals.\n            // setting rate data is the first step for listing a token, so this check blocks any\n            // unsupported token to ever be listed at Liquidity\n            _checkTokenDecimalsRange(tokensRateData_[i].token);\n\n            rateData_ = _rateData[tokensRateData_[i].token];\n\n            // apply current rate data to exchange prices before updating to new rate data\n            if (rateData_ != 0) {\n                _updateExchangePrices(tokensRateData_[i].token);\n            }\n\n            _rateData[tokensRateData_[i].token] = _computeRateDataPackedV1(tokensRateData_[i]);\n\n            if (rateData_ != 0) {\n                // apply new rate data to borrow rate\n                _updateExchangePricesAndRates(tokensRateData_[i].token);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateRateDataV1s(tokensRateData_);\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateRateDataV2s(RateDataV2Params[] calldata tokensRateData_) external onlyAuths {\n        uint256 length_ = tokensRateData_.length;\n        uint256 rateData_;\n\n        for (uint256 i; i < length_; ) {\n            _checkIsContractOrNativeAddress(tokensRateData_[i].token);\n\n            // token that is being listed must have between 6 and 18 decimals.\n            // setting rate data is the first step for listing a token, so this check blocks any\n            // unsupported token to ever be listed at Liquidity\n            _checkTokenDecimalsRange(tokensRateData_[i].token);\n\n            rateData_ = _rateData[tokensRateData_[i].token];\n\n            // apply current rate data to exchange prices before updating to new rate data\n            if (rateData_ != 0) {\n                _updateExchangePrices(tokensRateData_[i].token);\n            }\n\n            _rateData[tokensRateData_[i].token] = _computeRateDataPackedV2(tokensRateData_[i]);\n\n            if (rateData_ != 0) {\n                // apply new rate data to borrow rate\n                _updateExchangePricesAndRates(tokensRateData_[i].token);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateRateDataV2s(tokensRateData_);\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateTokenConfigs(TokenConfig[] calldata tokenConfigs_) external onlyAuths {\n        uint256 length_ = tokenConfigs_.length;\n        uint256 exchangePricesAndConfig_;\n        uint256 supplyExchangePrice_;\n        uint256 borrowExchangePrice_;\n\n        for (uint256 i; i < length_; ) {\n            _checkIsContractOrNativeAddress(tokenConfigs_[i].token);\n            if (_rateData[tokenConfigs_[i].token] == 0) {\n                // rate data must be configured before token config\n                revert FluidLiquidityError(ErrorTypes.AdminModule__InvalidConfigOrder);\n            }\n            if (tokenConfigs_[i].fee > FOUR_DECIMALS) {\n                // fee can not be > 100%\n                revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__FEE);\n            }\n            if (tokenConfigs_[i].maxUtilization > FOUR_DECIMALS) {\n                // borrows above 100% should never be possible\n                revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__MAX_UTILIZATION);\n            }\n            if (tokenConfigs_[i].threshold > MAX_TOKEN_CONFIG_UPDATE_THRESHOLD) {\n                // update on storage threshold can not be > MAX_TOKEN_CONFIG_UPDATE_THRESHOLD\n                revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__THRESHOLD);\n            }\n\n            exchangePricesAndConfig_ = _exchangePricesAndConfig[tokenConfigs_[i].token];\n\n            // extract exchange prices\n            supplyExchangePrice_ =\n                (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n                X64;\n            borrowExchangePrice_ =\n                (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n                X64;\n\n            if (supplyExchangePrice_ > 0 && borrowExchangePrice_ > 0) {\n                // calculate the current exchange prices based on earned interest before updating fee + timestamp in storage\n                (supplyExchangePrice_, borrowExchangePrice_) = LiquidityCalcs.calcExchangePrices(\n                    exchangePricesAndConfig_\n                );\n\n                // ensure values written to storage do not exceed the dedicated bit space in packed uint256 slots\n                if (supplyExchangePrice_ > X64 || borrowExchangePrice_ > X64) {\n                    revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__EXCHANGE_PRICES);\n                }\n            } else {\n                // exchange prices can only increase once set so if either one is 0, the other must be 0 too.\n                supplyExchangePrice_ = EXCHANGE_PRICES_PRECISION;\n                borrowExchangePrice_ = EXCHANGE_PRICES_PRECISION;\n\n                _listedTokens.push(tokenConfigs_[i].token);\n            }\n\n            // max utilization of 100% is default, configs2 slot is not used in that case\n            bool usesConfigs2_ = tokenConfigs_[i].maxUtilization != FOUR_DECIMALS;\n\n            _exchangePricesAndConfig[tokenConfigs_[i].token] =\n                // mask to set bits 16-29 (fee), 44-218 (update storage threshold, timestamp, exchange prices)\n                // and flag for uses configs2 at bit 249\n                (exchangePricesAndConfig_ & 0xfdfffffff80000000000000000000000000000000000000000000fffc000ffff) |\n                (tokenConfigs_[i].fee << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) |\n                (tokenConfigs_[i].threshold << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD) |\n                (block.timestamp << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) |\n                (supplyExchangePrice_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) |\n                (borrowExchangePrice_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) |\n                ((uint256(usesConfigs2_ ? 1 : 0)) << uint256(LiquiditySlotsLink.BITS_EXCHANGE_PRICES_USES_CONFIGS2));\n\n            _configs2[tokenConfigs_[i].token] =\n                // set max utilization at bits 0-14\n                (_configs2[tokenConfigs_[i].token] &\n                    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc000) |\n                (usesConfigs2_ ? tokenConfigs_[i].maxUtilization : 0);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateTokenConfigs(tokenConfigs_);\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateUserClasses(AddressUint256[] calldata userClasses_) external onlyAuths {\n        uint256 length_ = userClasses_.length;\n        for (uint256 i = 0; i < length_; ) {\n            if (userClasses_[i].value > 1) {\n                revert FluidLiquidityError(ErrorTypes.AdminModule__InvalidParams);\n            }\n            _checkIsContract(userClasses_[i].addr);\n\n            _userClass[userClasses_[i].addr] = userClasses_[i].value;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateUserClasses(userClasses_);\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external onlyAuths {\n        _checkIsContract(user_);\n        _checkIsContractOrNativeAddress(token_);\n\n        // get current user config data from storage\n        uint256 userSupplyData_ = _userSupplyData[user_][token_];\n        if (userSupplyData_ == 0) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__UserNotDefined);\n        }\n\n        // get current user supply amount\n        uint256 userSupply_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\n\n        // maxExpansionLimit_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        uint256 maxExpansionLimit_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        maxExpansionLimit_ = userSupply_ - ((userSupply_ * maxExpansionLimit_) / FOUR_DECIMALS);\n\n        if (newLimit_ == 0 || newLimit_ < maxExpansionLimit_) {\n            // instant full expansion, and if that goes below base limit then fully down to 0.\n            // if we were to set a limit that goes below max expansion limit, then after 1 deposit or 1 withdrawal it would\n            // become based on the max expansion limit again (unless it goes below base limit), which can be confusing.\n            // Also updating base limit here to avoid the change after 1 interaction might have undesired effects.\n            // So limiting update to max. full expansion. If more is desired, this must be called again after some withdraws.\n            newLimit_ = maxExpansionLimit_;\n        } else if (newLimit_ == type(uint256).max || newLimit_ > userSupply_) {\n            // current withdrawable 0 (sets current user supply as limit).\n            newLimit_ = userSupply_;\n        }\n        // else => new limit is between > max expansion and < user supply.\n\n        // set input limit as new current limit. instant withdrawable will be userSupply_ - newLimit_\n\n        uint256 baseLimit_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        baseLimit_ = (baseLimit_ >> DEFAULT_EXPONENT_SIZE) << (baseLimit_ & DEFAULT_EXPONENT_MASK);\n        if (userSupply_ < baseLimit_) {\n            newLimit_ = 0;\n            // Note if new limit goes below base limit, it follows default behavior: first there must be a withdrawal\n            // that brings user supply below base limit, then the limit will be set to 0.\n            // otherwise we would have the same problem as described above after 1 interaction.\n        }\n\n        // Update on storage\n        _userSupplyData[user_][token_] =\n            // mask to update bits 65-161 (withdrawal limit, timestamp)\n            (userSupplyData_ & 0xFFFFFFFFFFFFFFFFFFFFFFFC000000000000000000000001FFFFFFFFFFFFFFFF) |\n            (newLimit_.toBigNumber(DEFAULT_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BigMathMinified.ROUND_DOWN) <<\n                LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP);\n\n        emit LogUpdateUserWithdrawalLimit(user_, token_, newLimit_);\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateUserSupplyConfigs(UserSupplyConfig[] memory userSupplyConfigs_) external onlyAuths {\n        uint256 userSupplyData_;\n        uint256 totalAmounts_;\n        uint256 totalSupplyRawInterest_;\n        uint256 totalSupplyInterestFree_;\n        uint256 supplyConversion_;\n        uint256 withdrawLimitConversion_;\n        uint256 supplyExchangePrice_;\n\n        for (uint256 i; i < userSupplyConfigs_.length; ) {\n            _checkIsContract(userSupplyConfigs_[i].user);\n            _checkIsContractOrNativeAddress(userSupplyConfigs_[i].token);\n            if (_exchangePricesAndConfig[userSupplyConfigs_[i].token] == 0) {\n                // token config must be configured before setting any user supply config\n                revert FluidLiquidityError(ErrorTypes.AdminModule__InvalidConfigOrder);\n            }\n            if (\n                userSupplyConfigs_[i].mode > 1 ||\n                // can not set expand duration to 0 as that could cause a division by 0 in LiquidityCalcs.\n                // having expand duration as 0 is anyway not an expected config so removing the possibility for that.\n                // if no expansion is wanted, simply set expandDuration to 1 and expandPercent to 0.\n                userSupplyConfigs_[i].expandDuration == 0\n            ) {\n                revert FluidLiquidityError(ErrorTypes.AdminModule__InvalidParams);\n            }\n            if (userSupplyConfigs_[i].expandPercent > FOUR_DECIMALS) {\n                revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__EXPAND_PERCENT);\n            }\n            if (userSupplyConfigs_[i].expandDuration > X24) {\n                // duration is max 24 bits\n                revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__EXPAND_DURATION);\n            }\n            if (userSupplyConfigs_[i].baseWithdrawalLimit == 0) {\n                // base withdrawal limit can not be 0. As a side effect, this ensures that there is no supply config\n                // where all values would be 0, so configured users can be differentiated in the mapping.\n                revert FluidLiquidityError(ErrorTypes.AdminModule__LimitZero);\n            }\n            // @dev baseWithdrawalLimit has no max bits amount as it is in normal token amount & converted to BigNumber\n\n            // get current user config data from storage\n            userSupplyData_ = _userSupplyData[userSupplyConfigs_[i].user][userSupplyConfigs_[i].token];\n\n            // if userSupplyData_ == 0 (new setup) or if mode is unchanged, normal update is possible.\n            // else if mode changes, values have to be converted from raw <> normal etc.\n            if (\n                userSupplyData_ == 0 ||\n                (userSupplyData_ & 1 == 0 && userSupplyConfigs_[i].mode == 0) ||\n                (userSupplyData_ & 1 == 1 && userSupplyConfigs_[i].mode == 1)\n            ) {\n                // Updating user data on storage\n\n                _userSupplyData[userSupplyConfigs_[i].user][userSupplyConfigs_[i].token] =\n                    // mask to update first bit + bits 162-217 (expand percentage, expand duration, base limit)\n                    (userSupplyData_ & 0xfffffffffc00000000000003fffffffffffffffffffffffffffffffffffffffe) |\n                    (userSupplyConfigs_[i].mode) | // at first bit\n                    (userSupplyConfigs_[i].expandPercent << LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) |\n                    (userSupplyConfigs_[i].expandDuration << LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) |\n                    // convert base withdrawal limit to BigNumber for storage (10 | 8). (below this, 100% can be withdrawn)\n                    (userSupplyConfigs_[i].baseWithdrawalLimit.toBigNumber(\n                        SMALL_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_DOWN\n                    ) << LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT);\n            } else {\n                // mode changes -> values have to be converted from raw <> normal etc.\n\n                // if the mode changes then update _exchangePricesAndConfig related data in storage always\n                // update exchange prices timely before applying changes that affect utilization, rate etc.\n                _updateExchangePrices(userSupplyConfigs_[i].token);\n\n                // get updated exchange prices for the token\n                (supplyExchangePrice_, ) = LiquidityCalcs.calcExchangePrices(\n                    _exchangePricesAndConfig[userSupplyConfigs_[i].token]\n                );\n\n                totalAmounts_ = _totalAmounts[userSupplyConfigs_[i].token];\n                totalSupplyRawInterest_ = BigMathMinified.fromBigNumber(\n                    (totalAmounts_ & X64),\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                );\n                totalSupplyInterestFree_ = BigMathMinified.fromBigNumber(\n                    (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                );\n\n                // read current user supply & withdraw limit values\n                // here supplyConversion_ = user supply amount\n                supplyConversion_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n                supplyConversion_ =\n                    (supplyConversion_ >> DEFAULT_EXPONENT_SIZE) <<\n                    (supplyConversion_ & DEFAULT_EXPONENT_MASK);\n\n                withdrawLimitConversion_ =\n                    (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) &\n                    X64; // here withdrawLimitConversion_ = previous user withdraw limit\n                withdrawLimitConversion_ =\n                    (withdrawLimitConversion_ >> DEFAULT_EXPONENT_SIZE) <<\n                    (withdrawLimitConversion_ & DEFAULT_EXPONENT_MASK);\n\n                // conversion of balance and limit according to the mode change\n                if (userSupplyData_ & 1 == 0 && userSupplyConfigs_[i].mode == 1) {\n                    // Changing balance from interest free to with interest -> normal amounts to raw amounts\n                    // -> must divide by exchange price.\n\n                    // decreasing interest free total supply\n                    totalSupplyInterestFree_ = totalSupplyInterestFree_ > supplyConversion_\n                        ? totalSupplyInterestFree_ - supplyConversion_\n                        : 0;\n\n                    supplyConversion_ = (supplyConversion_ * EXCHANGE_PRICES_PRECISION) / supplyExchangePrice_;\n                    withdrawLimitConversion_ =\n                        (withdrawLimitConversion_ * EXCHANGE_PRICES_PRECISION) /\n                        supplyExchangePrice_;\n\n                    // increasing raw (with interest) total supply\n                    totalSupplyRawInterest_ += supplyConversion_;\n                } else if (userSupplyData_ & 1 == 1 && userSupplyConfigs_[i].mode == 0) {\n                    // Changing balance from with interest to interest free-> raw amounts to normal amounts\n                    // -> must multiply by exchange price.\n\n                    // decreasing raw (with interest) supply\n                    totalSupplyRawInterest_ = totalSupplyRawInterest_ > supplyConversion_\n                        ? totalSupplyRawInterest_ - supplyConversion_\n                        : 0;\n\n                    supplyConversion_ = (supplyConversion_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION;\n                    withdrawLimitConversion_ =\n                        (withdrawLimitConversion_ * supplyExchangePrice_) /\n                        EXCHANGE_PRICES_PRECISION;\n\n                    // increasing interest free total supply\n                    totalSupplyInterestFree_ += supplyConversion_;\n                }\n\n                // change new converted amounts to BigNumber for storage\n                supplyConversion_ = supplyConversion_.toBigNumber(\n                    DEFAULT_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_DOWN\n                );\n                withdrawLimitConversion_ = withdrawLimitConversion_.toBigNumber(\n                    DEFAULT_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_DOWN // withdrawal limit stores the amount that must stay supplied after withdrawal\n                );\n\n                // Updating user data on storage\n                _userSupplyData[userSupplyConfigs_[i].user][userSupplyConfigs_[i].token] =\n                    // mask to set bits 0-128 and 162-217 (all except last process timestamp)\n                    (userSupplyData_ & 0xfffffffffc00000000000003fffffffe00000000000000000000000000000000) |\n                    (userSupplyConfigs_[i].mode) |\n                    (supplyConversion_ << LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) | // BigNumber converted can not overflow\n                    (withdrawLimitConversion_ << LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) | // BigNumber converted can not overflow\n                    (userSupplyConfigs_[i].expandPercent << LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) |\n                    (userSupplyConfigs_[i].expandDuration << LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) |\n                    // convert base withdrawal limit to BigNumber for storage (10 | 8). (below this, 100% can be withdrawn)\n                    (userSupplyConfigs_[i].baseWithdrawalLimit.toBigNumber(\n                        SMALL_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_DOWN\n                    ) << LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT);\n\n                // change new total amounts to BigNumber for storage\n                totalSupplyRawInterest_ = totalSupplyRawInterest_.toBigNumber(\n                    DEFAULT_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_DOWN\n                );\n                totalSupplyInterestFree_ = totalSupplyInterestFree_.toBigNumber(\n                    DEFAULT_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_DOWN\n                );\n\n                // Updating total supplies on storage\n                _totalAmounts[userSupplyConfigs_[i].token] =\n                    // mask to set bits 0-127\n                    (totalAmounts_ & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) |\n                    (totalSupplyRawInterest_) | // BigNumber converted can not overflow\n                    (totalSupplyInterestFree_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE); // BigNumber converted can not overflow\n\n                // trigger update borrow rate, utilization, ratios etc.\n                _updateExchangePricesAndRates(userSupplyConfigs_[i].token);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateUserSupplyConfigs(userSupplyConfigs_);\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateUserBorrowConfigs(UserBorrowConfig[] memory userBorrowConfigs_) external onlyAuths {\n        uint256 userBorrowData_;\n        uint256 totalAmounts_;\n        uint256 totalBorrowRawInterest_;\n        uint256 totalBorrowInterestFree_;\n        uint256 borrowingConversion_;\n        uint256 debtCeilingConversion_;\n        uint256 borrowExchangePrice_;\n\n        for (uint256 i; i < userBorrowConfigs_.length; ) {\n            _checkIsContract(userBorrowConfigs_[i].user);\n            _checkIsContractOrNativeAddress(userBorrowConfigs_[i].token);\n            if (_exchangePricesAndConfig[userBorrowConfigs_[i].token] == 0) {\n                // token config must be configured before setting any user borrow config\n                revert FluidLiquidityError(ErrorTypes.AdminModule__InvalidConfigOrder);\n            }\n            if (\n                userBorrowConfigs_[i].mode > 1 ||\n                // max debt ceiling must not be smaller than base debt ceiling. Also covers case where max = 0 but base > 0\n                userBorrowConfigs_[i].baseDebtCeiling > userBorrowConfigs_[i].maxDebtCeiling ||\n                // can not set expand duration to 0 as that could cause a division by 0 in LiquidityCalcs.\n                // having expand duration as 0 is anyway not an expected config so removing the possibility for that.\n                // if no expansion is wanted, simply set expandDuration to 1 and expandPercent to 0.\n                userBorrowConfigs_[i].expandDuration == 0 ||\n                // sanity check that max borrow limit can never be more than 10x the total token supply.\n                // protects against that even if someone could artificially inflate token supply to a point where\n                // Fluid precision trade-offs could become problematic, can not inflate too much.\n                (userBorrowConfigs_[i].maxDebtCeiling >\n                    (\n                        userBorrowConfigs_[i].token == NATIVE_TOKEN_ADDRESS\n                            ? NATIVE_TOKEN_MAX_BORROW_LIMIT_CAP\n                            : 10 * IERC20(userBorrowConfigs_[i].token).totalSupply()\n                    ))\n            ) {\n                revert FluidLiquidityError(ErrorTypes.AdminModule__InvalidParams);\n            }\n            if (userBorrowConfigs_[i].expandPercent > X14) {\n                // expandPercent is max 14 bits\n                revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__EXPAND_PERCENT_BORROW);\n            }\n            if (userBorrowConfigs_[i].expandDuration > X24) {\n                // duration is max 24 bits\n                revert FluidLiquidityError(ErrorTypes.AdminModule__ValueOverflow__EXPAND_DURATION_BORROW);\n            }\n            if (userBorrowConfigs_[i].baseDebtCeiling == 0 || userBorrowConfigs_[i].maxDebtCeiling == 0) {\n                // limits can not be 0. As a side effect, this ensures that there is no borrow config\n                // where all values would be 0, so configured users can be differentiated in the mapping.\n                revert FluidLiquidityError(ErrorTypes.AdminModule__LimitZero);\n            }\n            // @dev baseDebtCeiling & maxDebtCeiling have no max bits amount as they are in normal token amount\n            // and then converted to BigNumber\n\n            // get current user config data from storage\n            userBorrowData_ = _userBorrowData[userBorrowConfigs_[i].user][userBorrowConfigs_[i].token];\n\n            // if userBorrowData_ == 0 (new setup) or if mode is unchanged, normal update is possible.\n            // else if mode changes, values have to be converted from raw <> normal etc.\n            if (\n                userBorrowData_ == 0 ||\n                (userBorrowData_ & 1 == 0 && userBorrowConfigs_[i].mode == 0) ||\n                (userBorrowData_ & 1 == 1 && userBorrowConfigs_[i].mode == 1)\n            ) {\n                // Updating user data on storage\n\n                _userBorrowData[userBorrowConfigs_[i].user][userBorrowConfigs_[i].token] =\n                    // mask to update first bit (mode) + bits 162-235 (debt limit values)\n                    (userBorrowData_ & 0xfffff0000000000000000003fffffffffffffffffffffffffffffffffffffffe) |\n                    (userBorrowConfigs_[i].mode) |\n                    (userBorrowConfigs_[i].expandPercent << LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) |\n                    (userBorrowConfigs_[i].expandDuration << LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) |\n                    // convert base debt limit to BigNumber for storage (10 | 8). (borrow is always possible below this)\n                    (userBorrowConfigs_[i].baseDebtCeiling.toBigNumber(\n                        SMALL_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_DOWN\n                    ) << LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) |\n                    // convert max debt limit to BigNumber for storage (10 | 8). (no borrowing ever possible above this)\n                    (userBorrowConfigs_[i].maxDebtCeiling.toBigNumber(\n                        SMALL_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_DOWN\n                    ) << LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT);\n            } else {\n                // mode changes -> values have to be converted from raw <> normal etc.\n\n                // if the mode changes then update _exchangePricesAndConfig related data in storage always\n                // update exchange prices timely before applying changes that affect utilization, rate etc.\n                _updateExchangePrices(userBorrowConfigs_[i].token);\n\n                // get updated exchange prices for the token\n                (, borrowExchangePrice_) = LiquidityCalcs.calcExchangePrices(\n                    _exchangePricesAndConfig[userBorrowConfigs_[i].token]\n                );\n\n                totalAmounts_ = _totalAmounts[userBorrowConfigs_[i].token];\n                totalBorrowRawInterest_ = BigMathMinified.fromBigNumber(\n                    (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64,\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                );\n                totalBorrowInterestFree_ = BigMathMinified.fromBigNumber(\n                    // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n                    (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE),\n                    DEFAULT_EXPONENT_SIZE,\n                    DEFAULT_EXPONENT_MASK\n                );\n\n                // read current user borrowing & borrow limit values\n                borrowingConversion_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64; // here borrowingConversion_ = user borrow amount\n                borrowingConversion_ =\n                    (borrowingConversion_ >> DEFAULT_EXPONENT_SIZE) <<\n                    (borrowingConversion_ & DEFAULT_EXPONENT_MASK);\n\n                debtCeilingConversion_ =\n                    (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) &\n                    X64; // here debtCeilingConversion_ = previous user borrow limit\n                debtCeilingConversion_ =\n                    (debtCeilingConversion_ >> DEFAULT_EXPONENT_SIZE) <<\n                    (debtCeilingConversion_ & DEFAULT_EXPONENT_MASK);\n\n                // conversion of balance and limit according to the mode change\n                if (userBorrowData_ & 1 == 0 && userBorrowConfigs_[i].mode == 1) {\n                    // Changing balance from interest free to with interest -> normal amounts to raw amounts\n                    // -> must divide by exchange price.\n\n                    // decreasing interest free total borrow; total = total - user borrow\n                    totalBorrowInterestFree_ = totalBorrowInterestFree_ > borrowingConversion_\n                        ? totalBorrowInterestFree_ - borrowingConversion_\n                        : 0;\n\n                    // round up for user borrow amount\n                    borrowingConversion_ = FixedPointMathLib.mulDivUp(\n                        borrowingConversion_,\n                        EXCHANGE_PRICES_PRECISION,\n                        borrowExchangePrice_\n                    );\n                    debtCeilingConversion_ =\n                        (debtCeilingConversion_ * EXCHANGE_PRICES_PRECISION) /\n                        borrowExchangePrice_;\n\n                    // increasing raw (with interest) total borrow\n                    totalBorrowRawInterest_ += borrowingConversion_;\n                } else if (userBorrowData_ & 1 == 1 && userBorrowConfigs_[i].mode == 0) {\n                    // Changing balance from with interest to interest free-> raw amounts to normal amounts\n                    // -> must multiply by exchange price.\n\n                    // decreasing raw (with interest) borrow; total = total - user borrow raw\n                    totalBorrowRawInterest_ = totalBorrowRawInterest_ > borrowingConversion_\n                        ? totalBorrowRawInterest_ - borrowingConversion_\n                        : 0;\n\n                    // round up for user borrow amount\n                    borrowingConversion_ = FixedPointMathLib.mulDivUp(\n                        borrowingConversion_,\n                        borrowExchangePrice_,\n                        EXCHANGE_PRICES_PRECISION\n                    );\n                    debtCeilingConversion_ =\n                        (debtCeilingConversion_ * borrowExchangePrice_) /\n                        EXCHANGE_PRICES_PRECISION;\n\n                    // increasing interest free total borrow\n                    totalBorrowInterestFree_ += borrowingConversion_;\n                }\n\n                // change new converted amounts to BigNumber for storage\n                borrowingConversion_ = borrowingConversion_.toBigNumber(\n                    DEFAULT_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_UP\n                );\n                debtCeilingConversion_ = debtCeilingConversion_.toBigNumber(\n                    DEFAULT_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_DOWN\n                );\n\n                // Updating user data on storage\n                _userBorrowData[userBorrowConfigs_[i].user][userBorrowConfigs_[i].token] =\n                    // mask to update bits 0-128 and bits 162-235 (all except last process timestamp)\n                    (userBorrowData_ & 0xfffff0000000000000000003fffffffe00000000000000000000000000000000) |\n                    (userBorrowConfigs_[i].mode) |\n                    (borrowingConversion_ << LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) | // BigNumber converted can not overflow\n                    (debtCeilingConversion_ << LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) | // BigNumber converted can not overflow\n                    (userBorrowConfigs_[i].expandPercent << LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) |\n                    (userBorrowConfigs_[i].expandDuration << LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) |\n                    // convert base debt limit to BigNumber for storage (10 | 8). (borrow is always possible below this)\n                    (userBorrowConfigs_[i].baseDebtCeiling.toBigNumber(\n                        SMALL_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_DOWN\n                    ) << LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) |\n                    // convert max debt limit to BigNumber for storage (10 | 8). (no borrowing ever possible above this)\n                    (userBorrowConfigs_[i].maxDebtCeiling.toBigNumber(\n                        SMALL_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_DOWN\n                    ) << LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT);\n\n                // change new total amounts to BigNumber for storage\n                totalBorrowRawInterest_ = totalBorrowRawInterest_.toBigNumber(\n                    DEFAULT_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_UP\n                );\n                totalBorrowInterestFree_ = totalBorrowInterestFree_.toBigNumber(\n                    DEFAULT_COEFFICIENT_SIZE,\n                    DEFAULT_EXPONENT_SIZE,\n                    BigMathMinified.ROUND_UP\n                );\n\n                // Updating total borrowings on storage\n                _totalAmounts[userBorrowConfigs_[i].token] =\n                    // mask to set bits 128-255\n                    (totalAmounts_ & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff) |\n                    (totalBorrowRawInterest_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) | // BigNumber converted can not overflow\n                    (totalBorrowInterestFree_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE); // BigNumber converted can not overflow\n\n                // trigger update borrow rate, utilization, ratios etc.\n                _updateExchangePricesAndRates(userBorrowConfigs_[i].token);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit LogUpdateUserBorrowConfigs(userBorrowConfigs_);\n    }\n}\n\n/// @notice Fluid Liquidity Guardians only related methods\nabstract contract GuardianModule is AuthModule {\n    /// @dev only guardians guard\n    modifier onlyGuardians() {\n        if (_isGuardian[msg.sender] & 1 != 1 && _getGovernanceAddr() != msg.sender) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__OnlyGuardians);\n        }\n        _;\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function pauseUser(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    ) public onlyGuardians {\n        _checkIsContract(user_);\n        if (_userClass[user_] == 1) {\n            revert FluidLiquidityError(ErrorTypes.AdminModule__UserNotPausable);\n        }\n\n        uint256 userData_;\n\n        // pause supply tokens\n        uint256 length_ = supplyTokens_.length;\n\n        if (length_ > 0) {\n            for (uint256 i; i < length_; ) {\n                _checkIsContractOrNativeAddress(supplyTokens_[i]);\n                // userData_ => userSupplyData_\n                userData_ = _userSupplyData[user_][supplyTokens_[i]];\n                if (userData_ == 0) {\n                    revert FluidLiquidityError(ErrorTypes.AdminModule__UserNotDefined);\n                }\n                // set last bit of _userSupplyData (pause flag) to 1\n                _userSupplyData[user_][supplyTokens_[i]] =\n                    userData_ |\n                    (1 << LiquiditySlotsLink.BITS_USER_SUPPLY_IS_PAUSED);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        // pause borrow tokens\n        length_ = borrowTokens_.length;\n\n        if (length_ > 0) {\n            for (uint256 i; i < length_; ) {\n                _checkIsContractOrNativeAddress(borrowTokens_[i]);\n                // userData_ => userBorrowData_\n                userData_ = _userBorrowData[user_][borrowTokens_[i]];\n                if (userData_ == 0) {\n                    revert FluidLiquidityError(ErrorTypes.AdminModule__UserNotDefined);\n                }\n                // set last bit of _userBorrowData (pause flag) to 1\n                _userBorrowData[user_][borrowTokens_[i]] =\n                    userData_ |\n                    (1 << LiquiditySlotsLink.BITS_USER_BORROW_IS_PAUSED);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        emit LogPauseUser(user_, supplyTokens_, borrowTokens_);\n    }\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function unpauseUser(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    ) public onlyGuardians {\n        _checkIsContract(user_);\n\n        uint256 userData_;\n\n        // unpause supply tokens\n        uint256 length_ = supplyTokens_.length;\n\n        if (length_ > 0) {\n            for (uint256 i; i < length_; ) {\n                _checkIsContractOrNativeAddress(supplyTokens_[i]);\n                // userData_ => userSupplyData_\n                userData_ = _userSupplyData[user_][supplyTokens_[i]];\n                if ((userData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_IS_PAUSED) & 1 != 1) {\n                    revert FluidLiquidityError(ErrorTypes.AdminModule__UserNotPaused);\n                }\n\n                // set last bit of _userSupplyData (pause flag) to 0\n                _userSupplyData[user_][supplyTokens_[i]] =\n                    userData_ &\n                    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        // unpause borrow tokens\n        length_ = borrowTokens_.length;\n\n        if (length_ > 0) {\n            for (uint256 i; i < length_; ) {\n                _checkIsContractOrNativeAddress(borrowTokens_[i]);\n                // userData_ => userBorrowData_\n                userData_ = _userBorrowData[user_][borrowTokens_[i]];\n                if ((userData_ >> LiquiditySlotsLink.BITS_USER_BORROW_IS_PAUSED) & 1 != 1) {\n                    revert FluidLiquidityError(ErrorTypes.AdminModule__UserNotPaused);\n                }\n                // set last bit of _userBorrowData (pause flag) to 0\n                _userBorrowData[user_][borrowTokens_[i]] =\n                    userData_ &\n                    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        emit LogUnpauseUser(user_, supplyTokens_, borrowTokens_);\n    }\n}\n\n/// @title Fluid Liquidity AdminModule\n/// @notice Fluid Liquidity auth protected methods to configure things such as:\n/// guardians, auths, governance, revenue, token configs, allowances etc.\n/// Accessibility of methods is restricted to Governance, Auths or Guardians. Governance is Auth & Governance by default\ncontract FluidLiquidityAdminModule is AdminModuleConstants, GuardianModule {\n    constructor(uint256 nativeTokenMaxBorrowLimitCap_) AdminModuleConstants(nativeTokenMaxBorrowLimitCap_) {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_) {\n        uint256 tokensLength_ = tokens_.length;\n\n        supplyExchangePrices_ = new uint256[](tokensLength_);\n        borrowExchangePrices_ = new uint256[](tokensLength_);\n\n        for (uint256 i; i < tokensLength_; ) {\n            _checkIsContractOrNativeAddress(tokens_[i]);\n            (supplyExchangePrices_[i], borrowExchangePrices_[i]) = _updateExchangePricesAndRates(tokens_[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/common/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { Variables } from \"./variables.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\n\n/// @dev ReentrancyGuard based on OpenZeppelin implementation.\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/security/ReentrancyGuard.sol\nabstract contract ReentrancyGuard is Variables, Error {\n    uint8 internal constant REENTRANCY_NOT_ENTERED = 1;\n    uint8 internal constant REENTRANCY_ENTERED = 2;\n\n    constructor() {\n        // on logic contracts, switch reentrancy to entered so no call is possible (forces delegatecall)\n        _status = REENTRANCY_ENTERED; \n    }\n\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\n    /// See OpenZeppelin implementation for more info\n    modifier reentrancy() {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == REENTRANCY_ENTERED) {\n            revert FluidLiquidityError(ErrorTypes.LiquidityHelpers__Reentrancy);\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = REENTRANCY_ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = REENTRANCY_NOT_ENTERED;\n    }\n}\n\nabstract contract CommonHelpers is ReentrancyGuard {\n    /// @dev Returns the current admin (governance).\n    function _getGovernanceAddr() internal view returns (address governance_) {\n        assembly {\n            governance_ := sload(GOVERNANCE_SLOT)\n        }\n    }\n}\n"
    },
    "contracts/liquidity/common/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\ncontract ConstantVariables {\n    /// @dev Storage slot with the admin of the contract. Logic from \"proxy.sol\".\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is validated in the constructor.\n    bytes32 internal constant GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    /// @dev decimals for native token\n    // !! Double check compatibility with all code if this ever changes for a deployment !!\n    uint8 internal constant NATIVE_TOKEN_DECIMALS = 18;\n\n    /// @dev Minimum token decimals for any token that can be listed at Liquidity (inclusive)\n    uint8 internal constant MIN_TOKEN_DECIMALS = 6;\n    /// @dev Maximum token decimals for any token that can be listed at Liquidity (inclusive)\n    uint8 internal constant MAX_TOKEN_DECIMALS = 18;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /// @dev limit any total amount to be half of type(uint128).max (~3.4e38) at type(int128).max (~1.7e38) as safety\n    /// measure for any potential overflows / unexpected outcomes. This is checked for total borrow / supply.\n    uint256 internal constant MAX_TOKEN_AMOUNT_CAP = uint256(uint128(type(int128).max));\n\n    /// @dev limit for triggering a revert if sent along excess input amount diff is bigger than this percentage (in 1e2)\n    uint256 internal constant MAX_INPUT_AMOUNT_EXCESS = 100; // 1%\n\n    /// @dev if this bytes32 is set in the calldata, then token transfers are skipped as long as Liquidity layer is on the winning side.\n    bytes32 internal constant SKIP_TRANSFERS = keccak256(bytes(\"SKIP_TRANSFERS\"));\n\n    /// @dev time after which a write to storage of exchangePricesAndConfig will happen always.\n    uint256 internal constant FORCE_STORAGE_WRITE_AFTER_TIME = 1 days;\n\n    /// @dev constants used for BigMath conversion from and to storage\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 10;\n    uint256 internal constant DEFAULT_COEFFICIENT_SIZE = 56;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    /// @dev constants to increase readability for using bit masks\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X8 = 0xff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n}\n\ncontract Variables is ConstantVariables {\n    /// @dev address of contract that gets sent the revenue. Configurable by governance\n    address internal _revenueCollector;\n\n    // 12 bytes empty\n\n    // ----- storage slot 1 ------\n\n    /// @dev paused status: status = 1 -> normal. status = 2 -> paused.\n    /// not tightly packed with revenueCollector address to allow for potential changes later that improve gas more\n    /// (revenueCollector is only rarely used by admin methods, where optimization is not as important).\n    /// to be replaced with transient storage once EIP-1153 Transient storage becomes available with dencun upgrade.\n    uint256 internal _status;\n\n    // ----- storage slot 2 ------\n\n    /// @dev Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\n    /// Governance can add/remove auths.\n    /// Governance is auth by default\n    mapping(address => uint256) internal _isAuth;\n\n    // ----- storage slot 3 ------\n\n    /// @dev Guardians can pause lower class users\n    /// Governance can add/remove guardians\n    /// Governance is guardian by default\n    mapping(address => uint256) internal _isGuardian;\n\n    // ----- storage slot 4 ------\n\n    /// @dev class defines which protocols can be paused by guardians\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\n    mapping(address => uint256) internal _userClass;\n\n    // ----- storage slot 5 ------\n\n    /// @dev exchange prices and token config per token: token -> exchange prices & config\n    /// First 16 bits =>   0- 15 => borrow rate (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next  14 bits =>  16- 29 => fee on interest from borrowers to lenders (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n    /// Next  14 bits =>  30- 43 => last stored utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    /// Next  14 bits =>  44- 57 => update on storage threshold (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n    /// Next  33 bits =>  58- 90 => last update timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  64 bits =>  91-154 => supply exchange price (1e12 -> max value 18_446_744,073709551615)\n    /// Next  64 bits => 155-218 => borrow exchange price (1e12 -> max value 18_446_744,073709551615)\n    /// Next   1 bit  => 219-219 => if 0 then ratio is supplyInterestFree / supplyWithInterest else ratio is supplyWithInterest / supplyInterestFree\n    /// Next  14 bits => 220-233 => supplyRatio: supplyInterestFree / supplyWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    /// Next   1 bit  => 234-234 => if 0 then ratio is borrowInterestFree / borrowWithInterest else ratio is borrowWithInterest / borrowInterestFree\n    /// Next  14 bits => 235-248 => borrowRatio: borrowInterestFree / borrowWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    /// Next   1 bit  => 249-249 => flag for token uses config storage slot 2. (signals SLOAD for additional config slot is needed during execution)\n    /// Last   6 bits => 250-255 => empty for future use\n    ///                             if more free bits are needed in the future, update on storage threshold bits could be reduced to 7 bits\n    ///                             (can plan to add `MAX_TOKEN_CONFIG_UPDATE_THRESHOLD` but need to adjust more bits)\n    ///                             if more bits absolutely needed then we can convert fee, utilization, update on storage threshold,\n    ///                             supplyRatio & borrowRatio from 14 bits to 10bits (1023 max number) where 1000 = 100% & 1 = 0.1%\n    mapping(address => uint256) internal _exchangePricesAndConfig;\n\n    // ----- storage slot 6 ------\n\n    /// @dev Rate related data per token: token -> rate data\n    /// READ (SLOAD): all actions; WRITE (SSTORE): only on set config admin actions\n    /// token => rate related data\n    /// First 4 bits  =>     0-3 => rate version\n    /// rest of the bits are rate dependent:\n\n    /// For rate v1 (one kink) ------------------------------------------------------\n    /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Last 188 bits =>  68-255 => empty for future use\n\n    /// For rate v2 (two kinks) -----------------------------------------------------\n    /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Last 156 bits => 100-255 => empty for future use\n    mapping(address => uint256) internal _rateData;\n\n    // ----- storage slot 7 ------\n\n    /// @dev total supply / borrow amounts for with / without interest per token: token -> amounts\n    /// First  64 bits =>   0- 63 => total supply with interest in raw (totalSupply = totalSupplyRaw * supplyExchangePrice); BigMath: 56 | 8\n    /// Next   64 bits =>  64-127 => total interest free supply in normal token amount (totalSupply = totalSupply); BigMath: 56 | 8\n    /// Next   64 bits => 128-191 => total borrow with interest in raw (totalBorrow = totalBorrowRaw * borrowExchangePrice); BigMath: 56 | 8\n    /// Next   64 bits => 192-255 => total interest free borrow in normal token amount (totalBorrow = totalBorrow); BigMath: 56 | 8\n    mapping(address => uint256) internal _totalAmounts;\n\n    // ----- storage slot 8 ------\n\n    /// @dev user supply data per token: user -> token -> data\n    /// First  1 bit  =>       0 => mode: user supply with or without interest\n    ///                             0 = without, amounts are in normal (i.e. no need to multiply with exchange price)\n    ///                             1 = with interest, amounts are in raw (i.e. must multiply with exchange price to get actual token amounts)\n    /// Next  64 bits =>   1- 64 => user supply amount (normal or raw depends on 1st bit); BigMath: 56 | 8\n    /// Next  64 bits =>  65-128 => previous user withdrawal limit (normal or raw depends on 1st bit); BigMath: 56 | 8\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  14 bits => 162-175 => expand withdrawal limit percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383).\n    ///                             @dev shrinking is instant\n    /// Next  24 bits => 176-199 => withdrawal limit expand duration in seconds.(Max value 16_777_215; ~4_660 hours, ~194 days)\n    /// Next  18 bits => 200-217 => base withdrawal limit: below this, 100% withdrawals can be done (normal or raw depends on 1st bit); BigMath: 10 | 8\n    /// Next  37 bits => 218-254 => empty for future use\n    /// Last     bit  => 255-255 => is user paused (1 = paused, 0 = not paused)\n    mapping(address => mapping(address => uint256)) internal _userSupplyData;\n\n    // ----- storage slot 9 ------\n\n    /// @dev user borrow data per token: user -> token -> data\n    /// First  1 bit  =>       0 => mode: user borrow with or without interest\n    ///                             0 = without, amounts are in normal (i.e. no need to multiply with exchange price)\n    ///                             1 = with interest, amounts are in raw (i.e. must multiply with exchange price to get actual token amounts)\n    /// Next  64 bits =>   1- 64 => user borrow amount (normal or raw depends on 1st bit); BigMath: 56 | 8\n    /// Next  64 bits =>  65-128 => previous user debt ceiling (normal or raw depends on 1st bit); BigMath: 56 | 8\n    /// Next  33 bits => 129-161 => last triggered process timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  14 bits => 162-175 => expand debt ceiling percentage (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    ///                             @dev shrinking is instant\n    /// Next  24 bits => 176-199 => debt ceiling expand duration in seconds (Max value 16_777_215; ~4_660 hours, ~194 days)\n    /// Next  18 bits => 200-217 => base debt ceiling: below this, there's no debt ceiling limits (normal or raw depends on 1st bit); BigMath: 10 | 8\n    /// Next  18 bits => 218-235 => max debt ceiling: absolute maximum debt ceiling can expand to (normal or raw depends on 1st bit); BigMath: 10 | 8\n    /// Next  19 bits => 236-254 => empty for future use\n    /// Last     bit  => 255-255 => is user paused (1 = paused, 0 = not paused)\n    mapping(address => mapping(address => uint256)) internal _userBorrowData;\n\n    // ----- storage slot 10 ------\n\n    /// @dev list of allowed tokens at Liquidity. tokens that are once configured can never be completely removed. so this\n    ///      array is append-only.\n    address[] internal _listedTokens;\n\n    // ----- storage slot 11 ------\n\n    /// @dev expanded token configs per token: token -> config data slot 2.\n    ///      Use of this is signaled by `_exchangePricesAndConfig` bit 249.\n    /// First 14 bits =>   0- 13 => max allowed utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n    /// Last 242 bits =>  14-255 => empty for future use\n    mapping(address => uint256) internal _configs2;\n}\n"
    },
    "contracts/liquidity/dummyImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { IFluidLiquidityLogic, IFluidLiquidityAdmin } from \"./interfaces/iLiquidity.sol\";\nimport { Structs as AdminModuleStructs } from \"./adminModule/structs.sol\";\n\n/// @notice Liquidity dummy implementation used for Fluid Liquidity infinite proxy.\n/// @dev see https://github.com/Instadapp/infinite-proxy?tab=readme-ov-file#dummy-implementation\ncontract FluidLiquidityDummyImpl is IFluidLiquidityLogic {\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateRevenueCollector(address revenueCollector_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function changeStatus(uint256 newStatus_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function collectRevenue(address[] calldata tokens_) external {}\n\n    /// @inheritdoc IFluidLiquidityAdmin\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_) {}\n\n    /// @inheritdoc IFluidLiquidityLogic\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_) {}\n}\n"
    },
    "contracts/liquidity/error.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\ncontract Error {\n    error FluidLiquidityError(uint256 errorId_);\n}\n"
    },
    "contracts/liquidity/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nlibrary ErrorTypes {\n    /***********************************|\n    |         Admin Module              | \n    |__________________________________*/\n\n    /// @notice thrown when an input address is zero\n    uint256 internal constant AdminModule__AddressZero = 10001;\n\n    /// @notice thrown when msg.sender is not governance\n    uint256 internal constant AdminModule__OnlyGovernance = 10002;\n\n    /// @notice thrown when msg.sender is not auth\n    uint256 internal constant AdminModule__OnlyAuths = 10003;\n\n    /// @notice thrown when msg.sender is not guardian\n    uint256 internal constant AdminModule__OnlyGuardians = 10004;\n\n    /// @notice thrown when base withdrawal limit, base debt limit or max withdrawal limit is sent as 0\n    uint256 internal constant AdminModule__LimitZero = 10005;\n\n    /// @notice thrown whenever an invalid input param is given\n    uint256 internal constant AdminModule__InvalidParams = 10006;\n\n    /// @notice thrown if user class 1 is paused (can not be paused)\n    uint256 internal constant AdminModule__UserNotPausable = 10007;\n\n    /// @notice thrown if user is tried to be unpaused but is not paused in the first place\n    uint256 internal constant AdminModule__UserNotPaused = 10008;\n\n    /// @notice thrown if user is not defined yet: Governance didn't yet set any config for this user on a particular token\n    uint256 internal constant AdminModule__UserNotDefined = 10009;\n\n    /// @notice thrown if a token is configured in an invalid order:  1. Set rate config for token 2. Set token config 3. allow any user.\n    uint256 internal constant AdminModule__InvalidConfigOrder = 10010;\n\n    /// @notice thrown if revenue is collected when revenue collector address is not set\n    uint256 internal constant AdminModule__RevenueCollectorNotSet = 10011;\n\n    /// @notice all ValueOverflow errors below are thrown if a certain input param overflows the allowed storage size\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_ZERO = 10012;\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_KINK = 10013;\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_MAX = 10014;\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_KINK1 = 10015;\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_KINK2 = 10016;\n    uint256 internal constant AdminModule__ValueOverflow__RATE_AT_UTIL_MAX_V2 = 10017;\n    uint256 internal constant AdminModule__ValueOverflow__FEE = 10018;\n    uint256 internal constant AdminModule__ValueOverflow__THRESHOLD = 10019;\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_PERCENT = 10020;\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_DURATION = 10021;\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_PERCENT_BORROW = 10022;\n    uint256 internal constant AdminModule__ValueOverflow__EXPAND_DURATION_BORROW = 10023;\n    uint256 internal constant AdminModule__ValueOverflow__EXCHANGE_PRICES = 10024;\n    uint256 internal constant AdminModule__ValueOverflow__UTILIZATION = 10025;\n\n    /// @notice thrown when an address is not a contract\n    uint256 internal constant AdminModule__AddressNotAContract = 10026;\n\n    uint256 internal constant AdminModule__ValueOverflow__MAX_UTILIZATION = 10027;\n\n    /// @notice thrown if a token that is being listed has not between 6 and 18 decimals\n    uint256 internal constant AdminModule__TokenInvalidDecimalsRange = 10028;\n\n    /***********************************|\n    |          User Module              | \n    |__________________________________*/\n\n    /// @notice thrown when user operations are paused for an interacted token\n    uint256 internal constant UserModule__UserNotDefined = 11001;\n\n    /// @notice thrown when user operations are paused for an interacted token\n    uint256 internal constant UserModule__UserPaused = 11002;\n\n    /// @notice thrown when user's try to withdraw below withdrawal limit\n    uint256 internal constant UserModule__WithdrawalLimitReached = 11003;\n\n    /// @notice thrown when user's try to borrow above borrow limit\n    uint256 internal constant UserModule__BorrowLimitReached = 11004;\n\n    /// @notice thrown when user sent supply/withdraw and borrow/payback both as 0\n    uint256 internal constant UserModule__OperateAmountsZero = 11005;\n\n    /// @notice thrown when user sent supply/withdraw or borrow/payback both as bigger than 2**128\n    uint256 internal constant UserModule__OperateAmountOutOfBounds = 11006;\n\n    /// @notice thrown when the operate amount for supply / withdraw / borrow / payback is below the minimum amount\n    /// that would cause a storage difference after BigMath & rounding imprecision. Extremely unlikely to ever happen\n    /// for all normal use-cases.\n    uint256 internal constant UserModule__OperateAmountInsufficient = 11007;\n\n    /// @notice thrown when withdraw or borrow is executed but withdrawTo or borrowTo is the zero address\n    uint256 internal constant UserModule__ReceiverNotDefined = 11008;\n\n    /// @notice thrown when user did send excess or insufficient amount (beyond rounding issues)\n    uint256 internal constant UserModule__TransferAmountOutOfBounds = 11009;\n\n    /// @notice thrown when user sent msg.value along for an operation not for the native token\n    uint256 internal constant UserModule__MsgValueForNonNativeToken = 11010;\n\n    /// @notice thrown when a borrow operation is done when utilization is above 100%\n    uint256 internal constant UserModule__MaxUtilizationReached = 11011;\n\n    /// @notice all ValueOverflow errors below are thrown if a certain input param or calc result overflows the allowed storage size\n    uint256 internal constant UserModule__ValueOverflow__EXCHANGE_PRICES = 11012;\n    uint256 internal constant UserModule__ValueOverflow__UTILIZATION = 11013;\n    uint256 internal constant UserModule__ValueOverflow__TOTAL_SUPPLY = 11014;\n    uint256 internal constant UserModule__ValueOverflow__TOTAL_BORROW = 11015;\n\n    /// @notice thrown when SKIP_TRANSFERS is set but the input params are invalid for skipping transfers\n    uint256 internal constant UserModule__SkipTransfersInvalid = 11016;\n\n    /***********************************|\n    |         LiquidityHelpers          | \n    |__________________________________*/\n\n    /// @notice thrown when a reentrancy happens\n    uint256 internal constant LiquidityHelpers__Reentrancy = 12001;\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/liquidity/proxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { Proxy } from \"../infiniteProxy/proxy.sol\";\n\n/// @notice Fluid Liquidity infinte proxy.\n/// Liquidity is the central point of the Instadapp Fluid architecture, it is the core interaction point\n/// for all allow-listed protocols, such as fTokens, Vault, Flashloan, StETH protocol, DEX protocol etc.\ncontract FluidLiquidityProxy is Proxy {\n    constructor(address admin_, address dummyImplementation_) Proxy(admin_, dummyImplementation_) {}\n}\n"
    },
    "contracts/liquidity/userModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\ncontract Events {\n    /// @notice emitted on any `operate()` execution: deposit / supply / withdraw / borrow.\n    /// includes info related to the executed operation, new total amounts (packed uint256 of BigMath numbers as in storage)\n    /// and exchange prices (packed uint256 as in storage).\n    /// @param user protocol that triggered this operation (e.g. via an fToken or via Vault protocol)\n    /// @param token token address for which this operation was executed\n    /// @param supplyAmount supply amount for the operation. if >0 then a deposit happened, if <0 then a withdrawal happened.\n    ///                     if 0 then nothing.\n    /// @param borrowAmount borrow amount for the operation. if >0 then a borrow happened, if <0 then a payback happened.\n    ///                     if 0 then nothing.\n    /// @param withdrawTo   address that funds where withdrawn to (if supplyAmount <0)\n    /// @param borrowTo     address that funds where borrowed to (if borrowAmount >0)\n    /// @param totalAmounts updated total amounts, stacked uint256 as written to storage:\n    /// First  64 bits =>   0- 63 => total supply with interest in raw (totalSupply = totalSupplyRaw * supplyExchangePrice); BigMath: 56 | 8\n    /// Next   64 bits =>  64-127 => total interest free supply in normal token amount (totalSupply = totalSupply); BigMath: 56 | 8\n    /// Next   64 bits => 128-191 => total borrow with interest in raw (totalBorrow = totalBorrowRaw * borrowExchangePrice); BigMath: 56 | 8\n    /// Next   64 bits => 192-255 => total interest free borrow in normal token amount (totalBorrow = totalBorrow); BigMath: 56 | 8\n    /// @param exchangePricesAndConfig updated exchange prices and configs storage slot. Contains updated supply & borrow exchange price:\n    /// First 16 bits =>   0- 15 => borrow rate (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n    /// Next  14 bits =>  16- 29 => fee on interest from borrowers to lenders (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n    /// Next  14 bits =>  30- 43 => last stored utilization (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    /// Next  14 bits =>  44- 57 => update on storage threshold (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383). configurable.\n    /// Next  33 bits =>  58- 90 => last update timestamp (enough until 16 March 2242 -> max value 8589934591)\n    /// Next  64 bits =>  91-154 => supply exchange price (1e12 -> max value 18_446_744,073709551615)\n    /// Next  64 bits => 155-218 => borrow exchange price (1e12 -> max value 18_446_744,073709551615)\n    /// Next   1 bit  => 219-219 => if 0 then ratio is supplyInterestFree / supplyWithInterest else ratio is supplyWithInterest / supplyInterestFree\n    /// Next  14 bits => 220-233 => supplyRatio: supplyInterestFree / supplyWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    /// Next   1 bit  => 234-234 => if 0 then ratio is borrowInterestFree / borrowWithInterest else ratio is borrowWithInterest / borrowInterestFree\n    /// Next  14 bits => 235-248 => borrowRatio: borrowInterestFree / borrowWithInterest (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n    event LogOperate(\n        address indexed user,\n        address indexed token,\n        int256 supplyAmount,\n        int256 borrowAmount,\n        address withdrawTo,\n        address borrowTo,\n        uint256 totalAmounts,\n        uint256 exchangePricesAndConfig\n    );\n}\n"
    },
    "contracts/liquidity/userModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nimport { BigMathMinified } from \"../../libraries/bigMathMinified.sol\";\nimport { LiquidityCalcs } from \"../../libraries/liquidityCalcs.sol\";\nimport { LiquiditySlotsLink } from \"../../libraries/liquiditySlotsLink.sol\";\nimport { SafeTransfer } from \"../../libraries/safeTransfer.sol\";\nimport { CommonHelpers } from \"../common/helpers.sol\";\nimport { Events } from \"./events.sol\";\nimport { ErrorTypes } from \"../errorTypes.sol\";\nimport { Error } from \"../error.sol\";\n\ninterface IProtocol {\n    function liquidityCallback(address token_, uint256 amount_, bytes calldata data_) external;\n}\n\nabstract contract CoreInternals is Error, CommonHelpers, Events {\n    using BigMathMinified for uint256;\n\n    /// @dev supply or withdraw for both with interest & interest free.\n    /// positive `amount_` is deposit, negative `amount_` is withdraw.\n    function _supplyOrWithdraw(\n        address token_,\n        int256 amount_,\n        uint256 supplyExchangePrice_\n    ) internal returns (int256 newSupplyInterestRaw_, int256 newSupplyInterestFree_) {\n        uint256 userSupplyData_ = _userSupplyData[msg.sender][token_];\n\n        if (userSupplyData_ == 0) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserNotDefined);\n        }\n        if ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_IS_PAUSED) & 1 == 1) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserPaused);\n        }\n\n        // extract user supply amount\n        uint256 userSupply_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64;\n        userSupply_ = (userSupply_ >> DEFAULT_EXPONENT_SIZE) << (userSupply_ & DEFAULT_EXPONENT_MASK);\n\n        // calculate current, updated (expanded etc.) withdrawal limit\n        uint256 newWithdrawalLimit_ = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(userSupplyData_, userSupply_);\n\n        // calculate updated user supply amount\n        if (userSupplyData_ & 1 == 1) {\n            // mode: with interest\n            if (amount_ > 0) {\n                // convert amount from normal to raw (divide by exchange price) -> round down for deposit\n                newSupplyInterestRaw_ = (amount_ * int256(EXCHANGE_PRICES_PRECISION)) / int256(supplyExchangePrice_);\n                userSupply_ = userSupply_ + uint256(newSupplyInterestRaw_);\n            } else {\n                // convert amount from normal to raw (divide by exchange price) -> round up for withdraw\n                newSupplyInterestRaw_ = -int256(\n                    FixedPointMathLib.mulDivUp(uint256(-amount_), EXCHANGE_PRICES_PRECISION, supplyExchangePrice_)\n                );\n                // if withdrawal is more than user's supply then solidity will throw here\n                userSupply_ = userSupply_ - uint256(-newSupplyInterestRaw_);\n            }\n        } else {\n            // mode: without interest\n            newSupplyInterestFree_ = amount_;\n            if (newSupplyInterestFree_ > 0) {\n                userSupply_ = userSupply_ + uint256(newSupplyInterestFree_);\n            } else {\n                // if withdrawal is more than user's supply then solidity will throw here\n                userSupply_ = userSupply_ - uint256(-newSupplyInterestFree_);\n            }\n        }\n\n        if (amount_ < 0 && userSupply_ < newWithdrawalLimit_) {\n            // if withdraw, then check the user supply after withdrawal is above withdrawal limit\n            revert FluidLiquidityError(ErrorTypes.UserModule__WithdrawalLimitReached);\n        }\n\n        // calculate withdrawal limit to store as previous withdrawal limit in storage\n        newWithdrawalLimit_ = LiquidityCalcs.calcWithdrawalLimitAfterOperate(\n            userSupplyData_,\n            userSupply_,\n            newWithdrawalLimit_\n        );\n\n        // Converting user's supply into BigNumber\n        userSupply_ = userSupply_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n        if (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64) == userSupply_) {\n            // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\n        }\n\n        // Converting withdrawal limit into BigNumber\n        newWithdrawalLimit_ = newWithdrawalLimit_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        // Updating on storage\n        _userSupplyData[msg.sender][token_] =\n            // mask to update bits 1-161 (supply amount, withdrawal limit, timestamp)\n            (userSupplyData_ & 0xfffffffffffffffffffffffc0000000000000000000000000000000000000001) |\n            (userSupply_ << LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) | // converted to BigNumber can not overflow\n            (newWithdrawalLimit_ << LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP);\n    }\n\n    /// @dev borrow or payback for both with interest & interest free.\n    /// positive `amount_` is borrow, negative `amount_` is payback.\n    function _borrowOrPayback(\n        address token_,\n        int256 amount_,\n        uint256 borrowExchangePrice_\n    ) internal returns (int256 newBorrowInterestRaw_, int256 newBorrowInterestFree_) {\n        uint256 userBorrowData_ = _userBorrowData[msg.sender][token_];\n\n        if (userBorrowData_ == 0) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserNotDefined);\n        }\n        if ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_IS_PAUSED) & 1 == 1) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__UserPaused);\n        }\n\n        // extract user borrow amount\n        uint256 userBorrow_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64;\n        userBorrow_ = (userBorrow_ >> DEFAULT_EXPONENT_SIZE) << (userBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        // calculate current, updated (expanded etc.) borrow limit\n        uint256 newBorrowLimit_ = LiquidityCalcs.calcBorrowLimitBeforeOperate(userBorrowData_, userBorrow_);\n\n        // calculate updated user borrow amount\n        if (userBorrowData_ & 1 == 1) {\n            // with interest\n            if (amount_ > 0) {\n                // convert amount normal to raw (divide by exchange price) -> round up for borrow\n                newBorrowInterestRaw_ = int256(\n                    FixedPointMathLib.mulDivUp(uint256(amount_), EXCHANGE_PRICES_PRECISION, borrowExchangePrice_)\n                );\n                userBorrow_ = userBorrow_ + uint256(newBorrowInterestRaw_);\n            } else {\n                // convert amount from normal to raw (divide by exchange price) -> round down for payback\n                newBorrowInterestRaw_ = (amount_ * int256(EXCHANGE_PRICES_PRECISION)) / int256(borrowExchangePrice_);\n                userBorrow_ = userBorrow_ - uint256(-newBorrowInterestRaw_);\n            }\n        } else {\n            // without interest\n            newBorrowInterestFree_ = amount_;\n            if (newBorrowInterestFree_ > 0) {\n                // borrowing\n                userBorrow_ = userBorrow_ + uint256(newBorrowInterestFree_);\n            } else {\n                // payback\n                userBorrow_ = userBorrow_ - uint256(-newBorrowInterestFree_);\n            }\n        }\n\n        if (amount_ > 0 && userBorrow_ > newBorrowLimit_) {\n            // if borrow, then check the user borrow amount after borrowing is below borrow limit\n            revert FluidLiquidityError(ErrorTypes.UserModule__BorrowLimitReached);\n        }\n\n        // calculate borrow limit to store as previous borrow limit in storage\n        newBorrowLimit_ = LiquidityCalcs.calcBorrowLimitAfterOperate(userBorrowData_, userBorrow_, newBorrowLimit_);\n\n        // Converting user's borrowings into bignumber\n        userBorrow_ = userBorrow_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_UP\n        );\n\n        if (((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64) == userBorrow_) {\n            // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\n            // is present then rounding will be in the right direction to avoid any potential manipulation.\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\n        }\n\n        // Converting borrow limit into bignumber\n        newBorrowLimit_ = newBorrowLimit_.toBigNumber(\n            DEFAULT_COEFFICIENT_SIZE,\n            DEFAULT_EXPONENT_SIZE,\n            BigMathMinified.ROUND_DOWN\n        );\n\n        // Updating on storage\n        _userBorrowData[msg.sender][token_] =\n            // mask to update bits 1-161 (borrow amount, borrow limit, timestamp)\n            (userBorrowData_ & 0xfffffffffffffffffffffffc0000000000000000000000000000000000000001) |\n            (userBorrow_ << LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) | // converted to BigNumber can not overflow\n            (newBorrowLimit_ << LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) | // converted to BigNumber can not overflow\n            (block.timestamp << LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP);\n    }\n\n    /// @dev checks if `supplyAmount_` & `borrowAmount_` amounts transfers can be skipped (DEX-protocol use-case).\n    /// -   Requirements:\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function _isInOutBalancedOut(\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes memory callbackData_\n    ) internal view returns (bool) {\n        // callbackData_ being at least > 63 in length is already verified before calling this method.\n\n        // 1. SKIP_TRANSFERS must be set in callbackData_ 32 bytes before last 32 bytes\n        bytes32 skipTransfers_;\n        assembly {\n            skipTransfers_ := mload(\n                add(\n                    // add padding for length as present for dynamic arrays in memory\n                    add(callbackData_, 32),\n                    // Load from memory offset of 2 slots (64 bytes): 1 slot: bytes32 skipTransfers_ + 2 slot: address inFrom_\n                    sub(mload(callbackData_), 64)\n                )\n            )\n        }\n        if (skipTransfers_ != SKIP_TRANSFERS) {\n            return false;\n        }\n        // after here, if invalid, protocol intended to skip transfers, but something is invalid. so we don't just\n        // NOT skip transfers, we actually revert because there must be something wrong on protocol side.\n\n        // 2. amounts must be\n        // a) equal: supply(+) == borrow(+), withdraw(-) == payback(-) OR\n        // b) Liquidity must be on the winning side.\n        // EITHER:\n        // deposit and borrow, both positive. there must be more borrow than deposit.\n        // so supply amount must be less, e.g. 80 deposit and 100 borrow.\n        // OR:\n        // withdraw and payback, both negative. there must be more withdraw than payback.\n        // so supplyAmount must be less (e.g. -100 withdraw and -80 payback )\n        if (\n            msg.value != 0 || // no msg.value should be sent along when trying to skip transfers.\n            supplyAmount_ == 0 ||\n            borrowAmount_ == 0 || // it must be a 2 actions operation, not just e.g. only deposit or only payback.\n            supplyAmount_ > borrowAmount_ // allow case a) and b): supplyAmount must be <=\n        ) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__SkipTransfersInvalid);\n        }\n\n        // 3. inFrom_ must be in last 32 bytes and must match receiver\n        address inFrom_;\n        assembly {\n            inFrom_ := mload(\n                add(\n                    // add padding for length as present for dynamic arrays in memory\n                    add(callbackData_, 32),\n                    // assembly expects address with leading zeros / left padded so need to use 32 as length here\n                    sub(mload(callbackData_), 32)\n                )\n            )\n        }\n\n        if (supplyAmount_ > 0) {\n            // deposit and borrow\n            if (!(inFrom_ == borrowTo_ && inFrom_ == msg.sender)) {\n                revert FluidLiquidityError(ErrorTypes.UserModule__SkipTransfersInvalid);\n            }\n        } else {\n            // withdraw and payback\n            if (!(inFrom_ == withdrawTo_ && inFrom_ == msg.sender)) {\n                revert FluidLiquidityError(ErrorTypes.UserModule__SkipTransfersInvalid);\n            }\n        }\n\n        return true;\n    }\n}\n\n/// @title  Fluid Liquidity UserModule\n/// @notice Fluid Liquidity public facing endpoint logic contract that implements the `operate()` method.\n///         operate can be used to deposit, withdraw, borrow & payback funds, given that they have the necessary\n///         user config allowance. Interacting users must be allowed via the Fluid Liquidity AdminModule first.\n///         Intended users are thus allow-listed protocols, e.g. the Lending protocol (fTokens), Vault protocol etc.\n/// @dev For view methods / accessing data, use the \"LiquidityResolver\" periphery contract.\ncontract FluidLiquidityUserModule is CoreInternals {\n    using BigMathMinified for uint256;\n\n    /// @dev struct for vars used in operate() that would otherwise cause a Stack too deep error\n    struct OperateMemoryVars {\n        bool skipTransfers;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalAmounts;\n        uint256 exchangePricesAndConfig;\n    }\n\n    /// @notice inheritdoc IFluidLiquidity\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable reentrancy returns (uint256 memVar3_, uint256 memVar4_) {\n        if (supplyAmount_ == 0 && borrowAmount_ == 0) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountsZero);\n        }\n        if (\n            supplyAmount_ < type(int128).min ||\n            supplyAmount_ > type(int128).max ||\n            borrowAmount_ < type(int128).min ||\n            borrowAmount_ > type(int128).max\n        ) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountOutOfBounds);\n        }\n        if ((supplyAmount_ < 0 && withdrawTo_ == address(0)) || (borrowAmount_ > 0 && borrowTo_ == address(0))) {\n            revert FluidLiquidityError(ErrorTypes.UserModule__ReceiverNotDefined);\n        }\n        if (token_ != NATIVE_TOKEN_ADDRESS && msg.value > 0) {\n            // revert: there should not be msg.value if the token is not the native token\n            revert FluidLiquidityError(ErrorTypes.UserModule__MsgValueForNonNativeToken);\n        }\n\n        OperateMemoryVars memory o_;\n\n        // @dev temporary memory variables used as helper in between to avoid assigning new memory variables\n        uint256 memVar_;\n        // memVar2_ => operateAmountIn: deposit + payback\n        uint256 memVar2_ = uint256((supplyAmount_ > 0 ? supplyAmount_ : int256(0))) +\n            uint256((borrowAmount_ < 0 ? -borrowAmount_ : int256(0)));\n\n        // check if token transfers can be skipped. see `_isInOutBalancedOut` for details.\n        if (\n            callbackData_.length > 63 &&\n            _isInOutBalancedOut(supplyAmount_, borrowAmount_, withdrawTo_, borrowTo_, callbackData_)\n        ) {\n            memVar2_ = 0; // set to 0 to skip transfers IN\n            o_.skipTransfers = true; // set flag to true to skip transfers OUT\n        }\n        if (token_ == NATIVE_TOKEN_ADDRESS) {\n            unchecked {\n                // check supply and payback amount is covered by available sent msg.value and\n                // protection that msg.value is not unintentionally way more than actually used in operate()\n                if (\n                    memVar2_ > msg.value ||\n                    msg.value > (memVar2_ * (FOUR_DECIMALS + MAX_INPUT_AMOUNT_EXCESS)) / FOUR_DECIMALS\n                ) {\n                    revert FluidLiquidityError(ErrorTypes.UserModule__TransferAmountOutOfBounds);\n                }\n            }\n            memVar2_ = 0; // set to 0 to skip transfers IN more gas efficient. No need for native token.\n        }\n        // if supply or payback or both -> transfer token amount from sender to here.\n        // for native token this is already covered by msg.value checks in operate(). memVar2_ is set to 0\n        // for same amounts in same operate(): supply(+) == borrow(+), withdraw(-) == payback(-). memVar2_ is set to 0\n        if (memVar2_ > 0) {\n            // memVar_ => initial token balance of this contract\n            memVar_ = IERC20(token_).balanceOf(address(this));\n            // trigger protocol to send token amount and pass callback data\n            IProtocol(msg.sender).liquidityCallback(token_, memVar2_, callbackData_);\n            // memVar_ => current token balance of this contract - initial balance\n            memVar_ = IERC20(token_).balanceOf(address(this)) - memVar_;\n            unchecked {\n                if (\n                    memVar_ < memVar2_ ||\n                    memVar_ > (memVar2_ * (FOUR_DECIMALS + MAX_INPUT_AMOUNT_EXCESS)) / FOUR_DECIMALS\n                ) {\n                    // revert if protocol did not send enough to cover supply / payback\n                    // or if protocol sent more than expected, with 1% tolerance for any potential rounding issues (and for DEX revenue cut)\n                    revert FluidLiquidityError(ErrorTypes.UserModule__TransferAmountOutOfBounds);\n                }\n            }\n        }\n\n        o_.exchangePricesAndConfig = _exchangePricesAndConfig[token_];\n\n        // calculate updated exchange prices\n        (o_.supplyExchangePrice, o_.borrowExchangePrice) = LiquidityCalcs.calcExchangePrices(\n            o_.exchangePricesAndConfig\n        );\n\n        // Extract total supply / borrow amounts for the token\n        o_.totalAmounts = _totalAmounts[token_];\n        memVar_ = o_.totalAmounts & X64;\n        o_.supplyRawInterest = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\n        memVar_ = (o_.totalAmounts >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        o_.supplyInterestFree = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\n        memVar_ = (o_.totalAmounts >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        o_.borrowRawInterest = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        memVar_ = (o_.totalAmounts >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        o_.borrowInterestFree = (memVar_ >> DEFAULT_EXPONENT_SIZE) << (memVar_ & DEFAULT_EXPONENT_MASK);\n\n        if (supplyAmount_ != 0) {\n            // execute supply or withdraw and update total amounts\n            {\n                uint256 totalAmountsBefore_ = o_.totalAmounts;\n                (int256 newSupplyInterestRaw_, int256 newSupplyInterestFree_) = _supplyOrWithdraw(\n                    token_,\n                    supplyAmount_,\n                    o_.supplyExchangePrice\n                );\n                // update total amounts. this is done here so that values are only written to storage once\n                // if a borrow / payback also happens in the same `operate()` call\n                if (newSupplyInterestFree_ == 0) {\n                    // Note newSupplyInterestFree_ can ONLY be 0 if mode is with interest,\n                    // easy to check as that variable is NOT the result of a dvision etc.\n                    // supply or withdraw with interest -> raw amount\n                    if (newSupplyInterestRaw_ > 0) {\n                        o_.supplyRawInterest += uint256(newSupplyInterestRaw_);\n                    } else {\n                        unchecked {\n                            o_.supplyRawInterest = o_.supplyRawInterest > uint256(-newSupplyInterestRaw_)\n                                ? o_.supplyRawInterest - uint256(-newSupplyInterestRaw_)\n                                : 0; // withdraw amount is > total supply -> withdraw total supply down to 0\n                            // Note no risk here as if the user withdraws more than supplied it would revert already\n                            // earlier. Total amounts can end up < sum of user amounts because of rounding\n                        }\n                    }\n\n                    // Note check for revert {UserModule}__ValueOverflow__TOTAL_SUPPLY is further down when we anyway\n                    // calculate the normal amount from raw\n\n                    // Converting the updated total amount into big number for storage\n                    memVar_ = o_.supplyRawInterest.toBigNumber(\n                        DEFAULT_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_DOWN\n                    );\n                    // update total supply with interest at total amounts in storage (only update changed values)\n                    o_.totalAmounts =\n                        // mask to update bits 0-63\n                        (o_.totalAmounts & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000) |\n                        memVar_; // converted to BigNumber can not overflow\n                } else {\n                    // supply or withdraw interest free -> normal amount\n                    if (newSupplyInterestFree_ > 0) {\n                        o_.supplyInterestFree += uint256(newSupplyInterestFree_);\n                    } else {\n                        unchecked {\n                            o_.supplyInterestFree = o_.supplyInterestFree > uint256(-newSupplyInterestFree_)\n                                ? o_.supplyInterestFree - uint256(-newSupplyInterestFree_)\n                                : 0; // withdraw amount is > total supply -> withdraw total supply down to 0\n                            // Note no risk here as if the user withdraws more than supplied it would revert already\n                            // earlier. Total amounts can end up < sum of user amounts because of rounding\n                        }\n                    }\n                    if (o_.supplyInterestFree > MAX_TOKEN_AMOUNT_CAP) {\n                        // only withdrawals allowed if total supply interest free reaches MAX_TOKEN_AMOUNT_CAP\n                        revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_SUPPLY);\n                    }\n                    // Converting the updated total amount into big number for storage\n                    memVar_ = o_.supplyInterestFree.toBigNumber(\n                        DEFAULT_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_DOWN\n                    );\n                    // update total supply interest free at total amounts in storage (only update changed values)\n                    o_.totalAmounts =\n                        // mask to update bits 64-127\n                        (o_.totalAmounts & 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff) |\n                        (memVar_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE); // converted to BigNumber can not overflow\n                }\n                if (totalAmountsBefore_ == o_.totalAmounts) {\n                    // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\n                    // is present then rounding will be in the right direction to avoid any potential manipulation.\n                    revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\n                }\n            }\n        }\n        if (borrowAmount_ != 0) {\n            // execute borrow or payback and update total amounts\n            {\n                uint256 totalAmountsBefore_ = o_.totalAmounts;\n                (int256 newBorrowInterestRaw_, int256 newBorrowInterestFree_) = _borrowOrPayback(\n                    token_,\n                    borrowAmount_,\n                    o_.borrowExchangePrice\n                );\n                // update total amounts. this is done here so that values are only written to storage once\n                // if a supply / withdraw also happens in the same `operate()` call\n                if (newBorrowInterestFree_ == 0) {\n                    // Note newBorrowInterestFree_ can ONLY be 0 if mode is with interest,\n                    // easy to check as that variable is NOT the result of a dvision etc.\n                    // borrow or payback with interest -> raw amount\n                    if (newBorrowInterestRaw_ > 0) {\n                        o_.borrowRawInterest += uint256(newBorrowInterestRaw_);\n                    } else {\n                        unchecked {\n                            o_.borrowRawInterest = o_.borrowRawInterest > uint256(-newBorrowInterestRaw_)\n                                ? o_.borrowRawInterest - uint256(-newBorrowInterestRaw_)\n                                : 0; // payback amount is > total borrow -> payback total borrow down to 0\n                        }\n                    }\n\n                    // Note check for revert UserModule__ValueOverflow__TOTAL_BORROW is further down when we anyway\n                    // calculate the normal amount from raw\n\n                    // Converting the updated total amount into big number for storage\n                    memVar_ = o_.borrowRawInterest.toBigNumber(\n                        DEFAULT_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_UP\n                    );\n                    // update total borrow with interest at total amounts in storage (only update changed values)\n                    o_.totalAmounts =\n                        // mask to update bits 128-191\n                        (o_.totalAmounts & 0xffffffffffffffff0000000000000000ffffffffffffffffffffffffffffffff) |\n                        (memVar_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST); // converted to BigNumber can not overflow\n                } else {\n                    // borrow or payback interest free -> normal amount\n                    if (newBorrowInterestFree_ > 0) {\n                        o_.borrowInterestFree += uint256(newBorrowInterestFree_);\n                    } else {\n                        unchecked {\n                            o_.borrowInterestFree = o_.borrowInterestFree > uint256(-newBorrowInterestFree_)\n                                ? o_.borrowInterestFree - uint256(-newBorrowInterestFree_)\n                                : 0; // payback amount is > total borrow -> payback total borrow down to 0\n                        }\n                    }\n                    if (o_.borrowInterestFree > MAX_TOKEN_AMOUNT_CAP) {\n                        // only payback allowed if total borrow interest free reaches MAX_TOKEN_AMOUNT_CAP\n                        revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_BORROW);\n                    }\n                    // Converting the updated total amount into big number for storage\n                    memVar_ = o_.borrowInterestFree.toBigNumber(\n                        DEFAULT_COEFFICIENT_SIZE,\n                        DEFAULT_EXPONENT_SIZE,\n                        BigMathMinified.ROUND_UP\n                    );\n                    // update total borrow interest free at total amounts in storage (only update changed values)\n                    o_.totalAmounts =\n                        // mask to update bits 192-255\n                        (o_.totalAmounts & 0x0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff) |\n                        (memVar_ << LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE); // converted to BigNumber can not overflow\n                }\n                if (totalAmountsBefore_ == o_.totalAmounts) {\n                    // make sure that operate amount is not so small that it wouldn't affect storage update. if a difference\n                    // is present then rounding will be in the right direction to avoid any potential manipulation.\n                    revert FluidLiquidityError(ErrorTypes.UserModule__OperateAmountInsufficient);\n                }\n            }\n        }\n        // Updating total amounts on storage\n        _totalAmounts[token_] = o_.totalAmounts;\n        {\n            // update exchange prices / utilization / ratios\n            // exchangePricesAndConfig is only written to storage if either utilization, supplyRatio or borrowRatio\n            // change is above the required storageUpdateThreshold config value or if the last write was > 1 day ago.\n\n            // 1. calculate new supply ratio, borrow ratio & utilization.\n            // 2. check if last storage write was > 1 day ago.\n            // 3. If false -> check if utilization is above update threshold\n            // 4. If false -> check if supply ratio is above update threshold\n            // 5. If false -> check if borrow ratio is above update threshold\n            // 6. If any true, then update on storage\n\n            // ########## calculating supply ratio ##########\n            // supplyWithInterest in normal amount\n            memVar3_ = ((o_.supplyRawInterest * o_.supplyExchangePrice) / EXCHANGE_PRICES_PRECISION);\n            if (memVar3_ > MAX_TOKEN_AMOUNT_CAP && supplyAmount_ > 0) {\n                // only withdrawals allowed if total supply raw reaches MAX_TOKEN_AMOUNT_CAP\n                revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_SUPPLY);\n            }\n            // memVar_ => total supply. set here so supplyWithInterest (memVar3_) is only calculated once. For utilization\n            memVar_ = o_.supplyInterestFree + memVar3_;\n            if (memVar3_ > o_.supplyInterestFree) {\n                // memVar3_ is ratio with 1 bit as 0 as supply interest raw is bigger\n                memVar3_ = ((o_.supplyInterestFree * FOUR_DECIMALS) / memVar3_) << 1;\n                // because of checking to divide by bigger amount, ratio can never be > 100%\n            } else if (memVar3_ < o_.supplyInterestFree) {\n                // memVar3_ is ratio with 1 bit as 1 as supply interest free is bigger\n                memVar3_ = (((memVar3_ * FOUR_DECIMALS) / o_.supplyInterestFree) << 1) | 1;\n                // because of checking to divide by bigger amount, ratio can never be > 100%\n            } else if (memVar_ > 0) {\n                // supplies match exactly (memVar3_  == o_.supplyInterestFree) and total supplies are not 0\n                // -> set ratio to 1 (with first bit set to 0, doesn't matter)\n                memVar3_ = FOUR_DECIMALS << 1;\n            } // else if total supply = 0, memVar3_ (supplyRatio) is already 0.\n\n            // ########## calculating borrow ratio ##########\n            // borrowWithInterest in normal amount\n            memVar4_ = ((o_.borrowRawInterest * o_.borrowExchangePrice) / EXCHANGE_PRICES_PRECISION);\n            if (memVar4_ > MAX_TOKEN_AMOUNT_CAP && borrowAmount_ > 0) {\n                // only payback allowed if total borrow raw reaches MAX_TOKEN_AMOUNT_CAP\n                revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__TOTAL_BORROW);\n            }\n            // memVar2_ => total borrow. set here so borrowWithInterest (memVar4_) is only calculated once. For utilization\n            memVar2_ = o_.borrowInterestFree + memVar4_;\n            if (memVar4_ > o_.borrowInterestFree) {\n                // memVar4_ is ratio with 1 bit as 0 as borrow interest raw is bigger\n                memVar4_ = ((o_.borrowInterestFree * FOUR_DECIMALS) / memVar4_) << 1;\n                // because of checking to divide by bigger amount, ratio can never be > 100%\n            } else if (memVar4_ < o_.borrowInterestFree) {\n                // memVar4_ is ratio with 1 bit as 1 as borrow interest free is bigger\n                memVar4_ = (((memVar4_ * FOUR_DECIMALS) / o_.borrowInterestFree) << 1) | 1;\n                // because of checking to divide by bigger amount, ratio can never be > 100%\n            } else if (memVar2_ > 0) {\n                // borrows match exactly (memVar4_  == o_.borrowInterestFree) and total borrows are not 0\n                // -> set ratio to 1 (with first bit set to 0, doesn't matter)\n                memVar4_ = FOUR_DECIMALS << 1;\n            } // else if total borrow = 0, memVar4_ (borrowRatio) is already 0.\n\n            // calculate utilization. If there is no supply, utilization must be 0 (avoid division by 0)\n            uint256 utilization_;\n            if (memVar_ > 0) {\n                utilization_ = ((memVar2_ * FOUR_DECIMALS) / memVar_);\n\n                // for borrow operations, ensure max utilization is not reached\n                if (borrowAmount_ > 0) {\n                    // memVar_ => max utilization\n                    // if any max utilization other than 100% is set, the flag usesConfigs2 in\n                    // exchangePricesAndConfig is 1. (optimized to avoid SLOAD if not needed).\n                    memVar_ = (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_USES_CONFIGS2) &\n                        1 ==\n                        1\n                        ? (_configs2[token_] & X14) // read configured max utilization\n                        : FOUR_DECIMALS; // default max utilization = 100%\n\n                    if (utilization_ > memVar_) {\n                        revert FluidLiquidityError(ErrorTypes.UserModule__MaxUtilizationReached);\n                    }\n                }\n            }\n\n            // check if time difference is big enough (> 1 day)\n            unchecked {\n                if (\n                    block.timestamp >\n                    // extract last update timestamp + 1 day\n                    (((o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33) +\n                        FORCE_STORAGE_WRITE_AFTER_TIME)\n                ) {\n                    memVar_ = 1; // set write to storage flag\n                } else {\n                    memVar_ = 0;\n                }\n            }\n\n            if (memVar_ == 0) {\n                // time difference is not big enough to cause storage write -> check utilization\n\n                // memVar_ => extract last utilization\n                memVar_ = (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14;\n                // memVar2_ => storage update threshold in percent\n                memVar2_ =\n                    (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD) &\n                    X14;\n                unchecked {\n                    // set memVar_ to 1 if current utilization to previous utilization difference is > update storage threshold\n                    memVar_ = (utilization_ > memVar_ ? utilization_ - memVar_ : memVar_ - utilization_) > memVar2_\n                        ? 1\n                        : 0;\n                    if (memVar_ == 0) {\n                        // utilization & time difference is not big enough -> check supplyRatio difference\n                        // memVar_ => extract last supplyRatio\n                        memVar_ =\n                            (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) &\n                            X15;\n                        // set memVar_ to 1 if current supplyRatio to previous supplyRatio difference is > update storage threshold\n                        if ((memVar_ & 1) == (memVar3_ & 1)) {\n                            memVar_ = memVar_ >> 1;\n                            memVar_ = (\n                                (memVar3_ >> 1) > memVar_ ? (memVar3_ >> 1) - memVar_ : memVar_ - (memVar3_ >> 1)\n                            ) > memVar2_\n                                ? 1\n                                : 0; // memVar3_ = supplyRatio, memVar_ = previous supplyRatio, memVar2_ = update storage threshold\n                        } else {\n                            // if inverse bit is changing then always update on storage\n                            memVar_ = 1;\n                        }\n                        if (memVar_ == 0) {\n                            // utilization, time, and supplyRatio difference is not big enough -> check borrowRatio difference\n                            // memVar_ => extract last borrowRatio\n                            memVar_ =\n                                (o_.exchangePricesAndConfig >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                                X15;\n                            // set memVar_ to 1 if current borrowRatio to previous borrowRatio difference is > update storage threshold\n                            if ((memVar_ & 1) == (memVar4_ & 1)) {\n                                memVar_ = memVar_ >> 1;\n                                memVar_ = (\n                                    (memVar4_ >> 1) > memVar_ ? (memVar4_ >> 1) - memVar_ : memVar_ - (memVar4_ >> 1)\n                                ) > memVar2_\n                                    ? 1\n                                    : 0; // memVar4_ = borrowRatio, memVar_ = previous borrowRatio, memVar2_ = update storage threshold\n                            } else {\n                                // if inverse bit is changing then always update on storage\n                                memVar_ = 1;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // memVar_ is 1 if either time diff was enough or if\n            // utilization, supplyRatio or borrowRatio difference was > update storage threshold\n            if (memVar_ == 1) {\n                // memVar_ => calculate new borrow rate for utilization. includes value overflow check.\n                memVar_ = LiquidityCalcs.calcBorrowRateFromUtilization(_rateData[token_], utilization_);\n                // ensure values written to storage do not exceed the dedicated bit space in packed uint256 slots\n                if (o_.supplyExchangePrice > X64 || o_.borrowExchangePrice > X64) {\n                    revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__EXCHANGE_PRICES);\n                }\n                if (utilization_ > X14) {\n                    revert FluidLiquidityError(ErrorTypes.UserModule__ValueOverflow__UTILIZATION);\n                }\n                o_.exchangePricesAndConfig =\n                    (o_.exchangePricesAndConfig &\n                        // mask to update bits: 0-15 (borrow rate), 30-43 (utilization), 58-248 (timestamp, exchange prices, ratios)\n                        0xfe000000000000000000000000000000000000000000000003fff0003fff0000) |\n                    memVar_ | // calcBorrowRateFromUtilization already includes an overflow check\n                    (utilization_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) |\n                    (block.timestamp << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) |\n                    (o_.supplyExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) |\n                    (o_.borrowExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) |\n                    // ratios can never be > 100%, no overflow check needed\n                    (memVar3_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) | // supplyRatio (memVar3_ holds that value)\n                    (memVar4_ << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO); // borrowRatio (memVar4_ holds that value)\n                // Updating on storage\n                _exchangePricesAndConfig[token_] = o_.exchangePricesAndConfig;\n            } else {\n                // do not update in storage but update o_.exchangePricesAndConfig for updated exchange prices at\n                // event emit of LogOperate\n                o_.exchangePricesAndConfig =\n                    (o_.exchangePricesAndConfig &\n                        // mask to update bits: 91-218 (exchange prices)\n                        0xfffffffffc00000000000000000000000000000007ffffffffffffffffffffff) |\n                    (o_.supplyExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) |\n                    (o_.borrowExchangePrice << LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE);\n            }\n        }\n        // sending tokens to user at the end after updating everything\n        // only transfer to user in case of withdraw or borrow.\n        // do not transfer for same amounts in same operate(): supply(+) == borrow(+), withdraw(-) == payback(-). (DEX protocol use-case)\n        if ((supplyAmount_ < 0 || borrowAmount_ > 0) && !o_.skipTransfers) {\n            // sending tokens to user at the end after updating everything\n            // set memVar2_ to borrowAmount (if borrow) or reset memVar2_ var to 0 because\n            // it is used with > 0 check below to transfer withdraw / borrow / both\n            memVar2_ = borrowAmount_ > 0 ? uint256(borrowAmount_) : 0;\n            if (supplyAmount_ < 0) {\n                unchecked {\n                    memVar_ = uint256(-supplyAmount_);\n                }\n            } else {\n                memVar_ = 0;\n            }\n            if (memVar_ > 0 && memVar2_ > 0 && withdrawTo_ == borrowTo_) {\n                // if user is doing borrow & withdraw together and address for both is the same\n                // then transfer tokens of borrow & withdraw together to save on gas\n                if (token_ == NATIVE_TOKEN_ADDRESS) {\n                    SafeTransfer.safeTransferNative(withdrawTo_, memVar_ + memVar2_);\n                } else {\n                    SafeTransfer.safeTransfer(token_, withdrawTo_, memVar_ + memVar2_);\n                }\n            } else {\n                if (token_ == NATIVE_TOKEN_ADDRESS) {\n                    // if withdraw\n                    if (memVar_ > 0) {\n                        SafeTransfer.safeTransferNative(withdrawTo_, memVar_);\n                    }\n                    // if borrow\n                    if (memVar2_ > 0) {\n                        SafeTransfer.safeTransferNative(borrowTo_, memVar2_);\n                    }\n                } else {\n                    // if withdraw\n                    if (memVar_ > 0) {\n                        SafeTransfer.safeTransfer(token_, withdrawTo_, memVar_);\n                    }\n                    // if borrow\n                    if (memVar2_ > 0) {\n                        SafeTransfer.safeTransfer(token_, borrowTo_, memVar2_);\n                    }\n                }\n            }\n        }\n        // emit Operate event\n        emit LogOperate(\n            msg.sender,\n            token_,\n            supplyAmount_,\n            borrowAmount_,\n            withdrawTo_,\n            borrowTo_,\n            o_.totalAmounts,\n            o_.exchangePricesAndConfig\n        );\n        // set return values\n        memVar3_ = o_.supplyExchangePrice;\n        memVar4_ = o_.borrowExchangePrice;\n    }\n}\n"
    },
    "contracts/mocks/mockProtocol.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { FluidLiquidityUserModule } from \"../liquidity/userModule/main.sol\";\nimport { IFluidLiquidity } from \"../liquidity/interfaces/iLiquidity.sol\";\n\n/// @title    Mock Protocol\n/// @notice   Mock protocol for testing, implements:\n///           function liquidityCallback(address token_, uint256 amount_, bytes calldata data_) external;\n///           This callback method MUST transferFrom data_ decoded from address to the liquidity contract\ncontract MockProtocol {\n    using SafeERC20 for IERC20;\n\n    /// @dev address that is mapped to the chain native token\n    address internal constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address public immutable liquidityContract;\n\n    /// @notice thrown when liquidity callback is called for a native token operation\n    error MockProtocol__UnexpectedLiquidityCallback();\n\n    bool transferInsufficientMode = false;\n    bool transferExcessMode = false;\n    bool reentrancyFromCallback = false;\n    address transferFromAddress;\n\n    /// @notice   Construct a new MockProtocol\n    /// @param    liquidityContract_ The address of the liquidity contract\n    constructor(address liquidityContract_) {\n        liquidityContract = liquidityContract_;\n    }\n\n    receive() external payable {}\n\n    function setTransferInsufficientMode(bool transferInsufficientMode_) public {\n        transferInsufficientMode = transferInsufficientMode_;\n    }\n\n    function setTransferExcessMode(bool transferExcessMode_) public {\n        transferExcessMode = transferExcessMode_;\n    }\n\n    function setReentrancyFromCallback(bool reentrancyFromCallback_) public {\n        reentrancyFromCallback = reentrancyFromCallback_;\n    }\n\n    function setTransferFromAddress(address transferFromAddress_) public {\n        transferFromAddress = transferFromAddress_;\n    }\n\n    /// @notice   Mock liquidity callback\n    /// @param    token_ The token being transferred\n    /// @param    amount_ The amount being transferred\n    function liquidityCallback(address token_, uint256 amount_, bytes memory data_) external {\n        if (reentrancyFromCallback) {\n            // call operate with some random values (should not matter as it reverts anyway)\n            IFluidLiquidity(liquidityContract).operate(\n                token_,\n                10,\n                0,\n                address(0),\n                address(0),\n                abi.encode(address(this))\n            );\n        }\n\n        if (token_ == NATIVE_TOKEN_ADDRESS) {\n            revert MockProtocol__UnexpectedLiquidityCallback();\n        }\n\n        address from_;\n        if (transferFromAddress == address(0)) {\n            // take the last 20 bytes of data_ and decode them to address. Gives more flexibility in type of\n            // data that can be passed in to Liquidity at mock calls while ensuring mock Protocol can do what it\n            // is supposed to do: transfer amount of token to liquidity.\n            assembly {\n                from_ := mload(\n                    add(\n                        // add padding for length as present for dynamic arrays in memory\n                        add(data_, 32),\n                        // assembly expects address with leading zeros / left padded so need to use 32 as length here\n                        sub(mload(data_), 32)\n                    )\n                )\n            }\n        } else {\n            from_ = transferFromAddress;\n        }\n\n        if (amount_ > 0) {\n            if (transferExcessMode) {\n                amount_ += (amount_ * 10101) / 10000; // max excess is 1%\n            } else if (transferInsufficientMode) {\n                amount_ -= 1;\n            }\n        }\n\n        if (from_ == address(this)) {\n            // use approve and transferFrom for more consistent testing of methods called\n            // (always transferFrom instead of transfer)\n            IERC20(token_).safeApprove(address(this), amount_);\n            IERC20(token_).safeTransferFrom(address(this), liquidityContract, amount_);\n        } else {\n            IERC20(token_).safeTransferFrom(from_, liquidityContract, amount_);\n        }\n    }\n\n    /// @notice   Proxy method for executing `operate` on the liquidity contract\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        uint256 valueAmount = msg.value;\n\n        if (valueAmount > 0) {\n            if (transferExcessMode) {\n                valueAmount += (valueAmount * 10101) / 10000; // max excess is 1%\n            } else if (transferInsufficientMode) {\n                valueAmount -= 1;\n            }\n        }\n\n        return\n            FluidLiquidityUserModule(liquidityContract).operate{ value: valueAmount }(\n                token_,\n                supplyAmount_,\n                borrowAmount_,\n                withdrawTo_,\n                borrowTo_,\n                callbackData_\n            );\n    }\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_) {\n        result_ = IFluidLiquidity(liquidityContract).readFromStorage(slot_);\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexLite/constantVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./interfaces.sol\";\n\nabstract contract ConstantVariables {\n    /*//////////////////////////////////////////////////////////////\n                                CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// bytes32(uint256(keccak256(\"FLUID_DEX_LITE_EXTRA_DATA\")) - 1)\n    bytes32 internal constant EXTRA_DATA_SLOT = 0x7e8134afb5ed35d36cb65e24b9a4712a52bb77d952806c1acf50970d2107797f;\n\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1\n    /// The exact slot which stored the admin address in infinite proxy of liquidity contracts\n    bytes32 internal constant LIQUIDITY_GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    bool internal constant SWAP_SINGLE = true;\n    bool internal constant SWAP_HOP = false;\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal constant NATIVE_TOKEN_DECIMALS = 18;\n    uint256 internal constant TOKENS_DECIMALS_PRECISION = 9;\n\n    uint8 internal constant MIN_TOKEN_DECIMALS = 6;\n    uint8 internal constant MAX_TOKEN_DECIMALS = 18;\n\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 20;\n    uint256 internal constant BIG_COEFFICIENT_SIZE = 32;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant X1 = 0x1;\n    uint256 internal constant X2 = 0x3;\n    uint256 internal constant X5 = 0x1f;\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X13 = 0x1fff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X19 = 0x7ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X56 = 0xffffffffffffff;\n    uint256 internal constant X60 = 0xfffffffffffffff;\n    uint256 internal constant X73 = 0x1ffffffffffffffffff;\n    uint256 internal constant X120 = 0xffffffffffffffffffffffffffffff;\n    uint256 internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n   \n    uint256 internal constant TWO_DECIMALS = 1e2;\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant SIX_DECIMALS = 1e6;\n\n    uint256 internal constant PRICE_PRECISION = 1e27;\n\n    /// after swap token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_SWAP\n    /// after swap token1 reserves should not be less than token0InToken1 / MINIMUM_LIQUIDITY_SWAP\n    uint256 internal constant MINIMUM_LIQUIDITY_SWAP = 1e4;\n\n    bytes32 internal constant ESTIMATE_SWAP = keccak256(bytes(\"ESTIMATE_SWAP\"));\n}\n"
    },
    "contracts/periphery/resolvers/dexLite/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./immutableVariables.sol\";\nimport { DexLiteSlotsLink as DSL } from \"../../../libraries/dexLiteSlotsLink.sol\";\nimport { AddressCalcs as AC } from \"../../../libraries/addressCalcs.sol\";\nimport { FixedPointMathLib as FPM } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nabstract contract Helpers is ImmutableVariables {\n    function _readDexKeyAtIndex(uint256 index) internal view returns (DexKey memory) {\n        bytes32 baseSlot = keccak256(abi.encode(DSL.DEX_LITE_DEXES_LIST_SLOT));\n\n        // Each DexKey takes 3 storage slots (token0, token1, salt)\n        address token0 = address(uint160(uint256(DEX_LITE.readFromStorage(bytes32(uint256(baseSlot) + index * 3)))));\n        address token1 = address(\n            uint160(uint256(DEX_LITE.readFromStorage(bytes32(uint256(baseSlot) + index * 3 + 1))))\n        );\n        bytes32 salt = DEX_LITE.readFromStorage(bytes32(uint256(baseSlot) + index * 3 + 2));\n\n        return DexKey(token0, token1, salt);\n    }\n\n    function _calculateDexId(DexKey memory dexKey_) internal pure returns (bytes8) {\n        return bytes8(keccak256(abi.encode(dexKey_)));\n    }\n\n    function _calculatePoolStateSlot(bytes8 dexId, uint256 baseSlot) internal pure returns (bytes32) {\n        return keccak256(abi.encode(bytes32(dexId), baseSlot));\n    }\n\n    function _readPoolState(\n        bytes8 dexId_\n    )\n        internal\n        view\n        returns (uint256 dexVariables_, uint256 centerPriceShift_, uint256 rangeShift_, uint256 thresholdShift_)\n    {\n        dexVariables_ = uint256(\n            DEX_LITE.readFromStorage(_calculatePoolStateSlot(dexId_, DSL.DEX_LITE_DEX_VARIABLES_SLOT))\n        );\n        centerPriceShift_ = uint256(\n            DEX_LITE.readFromStorage(_calculatePoolStateSlot(dexId_, DSL.DEX_LITE_CENTER_PRICE_SHIFT_SLOT))\n        );\n        rangeShift_ = uint256(DEX_LITE.readFromStorage(_calculatePoolStateSlot(dexId_, DSL.DEX_LITE_RANGE_SHIFT_SLOT)));\n        thresholdShift_ = uint256(\n            DEX_LITE.readFromStorage(_calculatePoolStateSlot(dexId_, DSL.DEX_LITE_THRESHOLD_SHIFT_SLOT))\n        );\n    }\n\n    function _unpackDexVariables(uint256 dexVariables_) internal view returns (DexVariables memory) {\n        bool isCenterPriceShiftActive_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE) &\n            X1 ==\n            1;\n\n        uint256 centerPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n\n        address centerPriceContractAddress_ = AC.addressCalc(\n            DEPLOYER_CONTRACT,\n            (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) & X19\n        );\n        bool isRangePercentShiftActive_ = (dexVariables_ >>\n            DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) &\n            X1 ==\n            1;\n        bool isThresholdPercentShiftActive_ = (dexVariables_ >>\n            DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) &\n            X1 ==\n            1;\n\n        return\n            DexVariables(\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) & X13,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) & X7,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) & X2,\n                isCenterPriceShiftActive_,\n                centerPrice_,\n                centerPriceContractAddress_,\n                isRangePercentShiftActive_,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14,\n                isThresholdPercentShiftActive_,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) & X7,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) & X7,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60\n            );\n    }\n\n    function _unpackCenterPriceShift(uint256 centerPriceShift_) internal pure returns (CenterPriceShift memory) {\n        uint256 maxCenterPrice_ = (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) & X28;\n        maxCenterPrice_ = (maxCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (maxCenterPrice_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 minCenterPrice_ = (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE) & X28;\n        minCenterPrice_ = (minCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (minCenterPrice_ & DEFAULT_EXPONENT_MASK);\n\n        return\n            CenterPriceShift(\n                (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33,\n                (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24,\n                maxCenterPrice_,\n                minCenterPrice_,\n                (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT) & X20,\n                (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT) & X20,\n                (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP) & X33\n            );\n    }\n\n    function _unpackRangeShift(uint256 rangeShift_) internal pure returns (RangeShift memory) {\n        return\n            RangeShift(\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT) & X14,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT) & X14,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT) & X20,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP) & X33\n            );\n    }\n\n    function _unpackThresholdShift(uint256 thresholdShift_) internal pure returns (ThresholdShift memory) {\n        return\n            ThresholdShift(\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT) & X7,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT) & X7,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT) & X20,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP) & X33\n            );\n    }\n\n    /// @dev getting reserves outside range.\n    /// @param gp_ is geometric mean pricing of upper percent & lower percent\n    /// @param pa_ price of upper range or lower range\n    /// @param rx_ real reserves of token0 or token1\n    /// @param ry_ whatever is rx_ the other will be ry_\n    function _calculateReservesOutsideRange(\n        uint256 gp_,\n        uint256 pa_,\n        uint256 rx_,\n        uint256 ry_\n    ) internal pure returns (uint256 xa_, uint256 yb_) {\n        // equations we have:\n        // 1. x*y = k\n        // 2. xa*ya = k\n        // 3. xb*yb = k\n        // 4. Pa = ya / xa = upperRange_ (known)\n        // 5. Pb = yb / xb = lowerRange_ (known)\n        // 6. x - xa = rx = real reserve of x (known)\n        // 7. y - yb = ry = real reserve of y (known)\n        // With solving we get:\n        // ((Pa*Pb)^(1/2) - Pa)*xa^2 + (rx * (Pa*Pb)^(1/2) + ry)*xa + rx*ry = 0\n        // yb = yb = xa * (Pa * Pb)^(1/2)\n\n        // xa = (GP⋅rx + ry + (-rx⋅ry⋅4⋅(GP - Pa) + (GP⋅rx + ry)^2)^0.5) / (2Pa - 2GP)\n        // multiply entire equation by 1e27 to remove the price decimals precision of 1e27\n        // xa = (GP⋅rx + ry⋅1e27 + (rx⋅ry⋅4⋅(Pa - GP)⋅1e27 + (GP⋅rx + ry⋅1e27)^2)^0.5) / 2*(Pa - GP)\n        // dividing the equation with 2*(Pa - GP). Pa is always > GP so answer will be positive.\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅4⋅(Pa - GP)⋅1e27) / 4*(Pa - GP)^2) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅1e27) / (Pa - GP)) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n\n        // dividing in 3 parts for simplification:\n        // part1 = (Pa - GP)\n        // part2 = (GP⋅rx + ry⋅1e27) / (2*part1)\n        // part3 = rx⋅ry\n        // note: part1 will almost always be < 1e28 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e29\n        unchecked {\n            uint256 p1_ = pa_ - gp_;\n            uint256 p2_ = ((gp_ * rx_) + (ry_ * PRICE_PRECISION)) / (2 * p1_);\n\n            // removed <1e50 check becuase rx_ * ry_ will never be greater than 1e50\n            // Directly used p3_ below instead of using a variable for it\n            // uint256 p3_ = (rx_ * ry_ * PRICE_PRECISION) / p1_;\n\n            // xa = part2 + (part3 + (part2 * part2))^(1/2)\n            // yb = xa_ * gp_\n            xa_ = p2_ + FPM.sqrt((((rx_ * ry_ * PRICE_PRECISION) / p1_) + (p2_ * p2_)));\n            yb_ = (xa_ * gp_) / PRICE_PRECISION;\n        }\n    }\n\n    function _calcShiftingDone(\n        uint256 current_,\n        uint256 old_,\n        uint256 timePassed_,\n        uint256 shiftDuration_\n    ) internal pure returns (uint256) {\n        unchecked {\n            if (current_ > old_) {\n                return (old_ + (((current_ - old_) * timePassed_) / shiftDuration_));\n            } else {\n                return (old_ - (((old_ - current_) * timePassed_) / shiftDuration_));\n            }\n        }\n    }\n\n    function _calcRangeShifting(\n        uint256 upperRange_,\n        uint256 lowerRange_,\n        uint256 rangeShift_\n    ) internal returns (uint256, uint256) {\n        // rangeShift_ = _rangeShift[dexId_];\n        uint256 shiftDuration_ = (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT) & X20;\n        uint256 startTimeStamp_ = (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP) & X33;\n\n        uint256 timePassed_;\n        unchecked {\n            if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n                // shifting fully done\n                // delete _rangeShift[dexId_];\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables only updates from this function and _calcThresholdShifting.\n                // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE);\n                return (upperRange_, lowerRange_);\n            }\n            timePassed_ = block.timestamp - startTimeStamp_;\n        }\n        return (\n            _calcShiftingDone(\n                upperRange_,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT) & X14,\n                timePassed_,\n                shiftDuration_\n            ),\n            _calcShiftingDone(\n                lowerRange_,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT) & X14,\n                timePassed_,\n                shiftDuration_\n            )\n        );\n    }\n\n    function _calcThresholdShifting(\n        uint256 upperThreshold_,\n        uint256 lowerThreshold_,\n        uint256 thresholdShift_\n    ) internal returns (uint256, uint256) {\n        // uint256 thresholdShift_ = _thresholdShift[dexId_];\n        uint256 shiftDuration_ = (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT) & X20;\n        uint256 startTimeStamp_ = (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP) & X33;\n\n        uint256 timePassed_;\n        unchecked {\n            if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n                // shifting fully done\n                // delete _thresholdShift[dexId_];\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcRangeShifting.\n                // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE);\n                return (upperThreshold_, lowerThreshold_);\n            }\n            timePassed_ = block.timestamp - startTimeStamp_;\n        }\n        return (\n            _calcShiftingDone(\n                upperThreshold_,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT) & X7,\n                timePassed_,\n                shiftDuration_\n            ),\n            _calcShiftingDone(\n                lowerThreshold_,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT) & X7,\n                timePassed_,\n                shiftDuration_\n            )\n        );\n    }\n\n    function _calcCenterPrice(\n        DexKey memory dexKey_,\n        uint256 dexVariables_,\n        uint256 centerPriceShift_\n    ) internal returns (uint256 newCenterPrice_) {\n        uint256 oldCenterPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n        oldCenterPrice_ = (oldCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (oldCenterPrice_ & DEFAULT_EXPONENT_MASK);\n        // uint256 centerPriceShift_ = _centerPriceShift[dexId_];\n        uint256 startTimeStamp_ = (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP) & X33;\n\n        uint256 fromTimeStamp_ = (centerPriceShift_ >>\n            DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33;\n        fromTimeStamp_ = fromTimeStamp_ > startTimeStamp_ ? fromTimeStamp_ : startTimeStamp_;\n\n        newCenterPrice_ = ICenterPrice(\n            AC.addressCalc(\n                DEPLOYER_CONTRACT,\n                ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) & X19)\n            )\n        ).centerPrice(dexKey_.token0, dexKey_.token1);\n\n        unchecked {\n            uint256 priceShift_ = (oldCenterPrice_ *\n                ((centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT) & X20) *\n                (block.timestamp - fromTimeStamp_)) /\n                (((centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT) & X20) * SIX_DECIMALS);\n\n            if (newCenterPrice_ > oldCenterPrice_) {\n                // shift on positive side\n                oldCenterPrice_ += priceShift_;\n                if (newCenterPrice_ > oldCenterPrice_) {\n                    newCenterPrice_ = oldCenterPrice_;\n                } else {\n                    // shifting fully done\n                    // _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n                    // making active shift as 0 because shift is over\n                    // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                    // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n                }\n            } else {\n                oldCenterPrice_ = oldCenterPrice_ > priceShift_ ? oldCenterPrice_ - priceShift_ : 0;\n                // In case of oldCenterPrice_ ending up 0, which could happen when a lot of time has passed (pool has no swaps for many days or weeks)\n                // then below we get into the else logic which will fully conclude shifting and return newCenterPrice_\n                // as it was fetched from the external center price source.\n                // not ideal that this would ever happen unless the pool is not in use and all/most users have left leaving not enough liquidity to trade on\n                if (newCenterPrice_ < oldCenterPrice_) {\n                    newCenterPrice_ = oldCenterPrice_;\n                } else {\n                    // shifting fully done\n                    // _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n                    // making active shift as 0 because shift is over\n                    // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                    // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates and returns the current prices and exchange prices for the pool\n    /// @param dexVariables_ The first set of DEX variables containing various pool parameters\n    function _getPricesAndReserves(\n        DexKey memory dexKey_,\n        uint256 dexVariables_,\n        uint256 centerPriceShift_,\n        uint256 rangeShift_,\n        uint256 thresholdShift_,\n        uint256 token0Supply_,\n        uint256 token1Supply_\n    ) internal returns (Prices memory prices_, Reserves memory reserves_) {\n        // Fetch center price\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE) & X1) == 0) {\n            // prices_.centerPrice => center price nonce\n            prices_.centerPrice =\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) &\n                X19;\n            if (prices_.centerPrice == 0) {\n                prices_.centerPrice = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n                prices_.centerPrice =\n                    (prices_.centerPrice >> DEFAULT_EXPONENT_SIZE) <<\n                    (prices_.centerPrice & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n                prices_.centerPrice = ICenterPrice(AC.addressCalc(DEPLOYER_CONTRACT, prices_.centerPrice))\n                    .centerPrice(dexKey_.token0, dexKey_.token1);\n            }\n        } else {\n            // an active prices_.centerPrice shift is going on\n            prices_.centerPrice = _calcCenterPrice(dexKey_, dexVariables_, centerPriceShift_);\n        }\n\n        uint256 upperRangePercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14;\n        uint256 lowerRangePercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14;\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) & X1) == 1) {\n            // an active range shift is going on\n            (upperRangePercent_, lowerRangePercent_) = _calcRangeShifting(\n                upperRangePercent_,\n                lowerRangePercent_,\n                rangeShift_\n            );\n        }\n\n        unchecked {\n            // 1% = 1e2, 100% = 1e4\n            prices_.upperRangePrice = (prices_.centerPrice * FOUR_DECIMALS) / (FOUR_DECIMALS - upperRangePercent_);\n            // 1% = 1e2, 100% = 1e4\n            prices_.lowerRangePrice = (prices_.centerPrice * (FOUR_DECIMALS - lowerRangePercent_)) / FOUR_DECIMALS;\n        }\n\n        // Rebalance center price if rebalancing is on\n        // temp_ => rebalancingStatus_\n        uint256 temp_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) & X2;\n        uint256 temp2_;\n        if (temp_ > 1) {\n            unchecked {\n                // temp2_ => centerPriceShift_\n                if (temp_ == 2) {\n                    temp2_ = centerPriceShift_;\n                    uint256 shiftingTime_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24;\n                    uint256 timeElapsed_ = block.timestamp -\n                        ((temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33);\n                    // price shifting towards upper range\n                    if (timeElapsed_ < shiftingTime_) {\n                        prices_.centerPrice =\n                            prices_.centerPrice +\n                            (((prices_.upperRangePrice - prices_.centerPrice) * timeElapsed_) / shiftingTime_);\n                    } else {\n                        // 100% price shifted\n                        prices_.centerPrice = prices_.upperRangePrice;\n                    }\n                } else if (temp_ == 3) {\n                    temp2_ = centerPriceShift_;\n                    uint256 shiftingTime_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24;\n                    uint256 timeElapsed_ = block.timestamp -\n                        ((temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33);\n                    // price shifting towards lower range\n                    if (timeElapsed_ < shiftingTime_) {\n                        prices_.centerPrice =\n                            prices_.centerPrice -\n                            (((prices_.centerPrice - prices_.lowerRangePrice) * timeElapsed_) / shiftingTime_);\n                    } else {\n                        // 100% price shifted\n                        prices_.centerPrice = prices_.lowerRangePrice;\n                    }\n                }\n\n                // If rebalancing actually happened then make sure price is within min and max bounds, and update range prices\n                if (temp2_ > 0) {\n                    // Make sure center price is within min and max bounds\n                    // temp_ => max center price\n                    temp_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) & X28;\n                    temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n                    if (prices_.centerPrice > temp_) {\n                        // if center price is greater than max center price\n                        prices_.centerPrice = temp_;\n                    } else {\n                        // check if center price is less than min center price\n                        // temp_ => min center price\n                        temp_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE) & X28;\n                        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n                        if (prices_.centerPrice < temp_) prices_.centerPrice = temp_;\n                    }\n\n                    // Update range prices as center price moved\n                    prices_.upperRangePrice =\n                        (prices_.centerPrice * FOUR_DECIMALS) /\n                        (FOUR_DECIMALS - upperRangePercent_);\n                    prices_.lowerRangePrice =\n                        (prices_.centerPrice * (FOUR_DECIMALS - lowerRangePercent_)) /\n                        FOUR_DECIMALS;\n                }\n            }\n        }\n\n        // Calculate threshold prices\n        uint256 upperThresholdPercent_ = (dexVariables_ >>\n            DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) & X7;\n        uint256 lowerThresholdPercent_ = (dexVariables_ >>\n            DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) & X7;\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) & X1) == 1) {\n            // if active shift is going on for threshold then calculate threshold real time\n            (upperThresholdPercent_, lowerThresholdPercent_) = _calcThresholdShifting(\n                upperThresholdPercent_,\n                lowerThresholdPercent_,\n                thresholdShift_\n            );\n        }\n\n        unchecked {\n            prices_.upperThresholdPrice = (prices_.centerPrice +\n                ((prices_.upperRangePrice - prices_.centerPrice) * (TWO_DECIMALS - upperThresholdPercent_)) /\n                TWO_DECIMALS);\n            prices_.lowerThresholdPrice = (prices_.centerPrice -\n                ((prices_.centerPrice - prices_.lowerRangePrice) * (TWO_DECIMALS - lowerThresholdPercent_)) /\n                TWO_DECIMALS);\n        }\n\n        // temp_ => geometricMeanPrice_\n        unchecked {\n            if (prices_.upperRangePrice < 1e38) {\n                // 1e38 * 1e38 = 1e76 which is less than max uint limit\n                temp_ = FPM.sqrt(prices_.upperRangePrice * prices_.lowerRangePrice);\n            } else {\n                // upperRange_ price is pretty large hence lowerRange_ will also be pretty large\n                temp_ =\n                    FPM.sqrt((prices_.upperRangePrice / 1e18) * (prices_.lowerRangePrice / 1e18)) *\n                    1e18;\n            }\n        }\n\n        if (temp_ < 1e27) {\n            (reserves_.token0ImaginaryReserves, reserves_.token1ImaginaryReserves) = _calculateReservesOutsideRange(\n                temp_,\n                prices_.upperRangePrice,\n                token0Supply_,\n                token1Supply_\n            );\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            unchecked {\n                (reserves_.token1ImaginaryReserves, reserves_.token0ImaginaryReserves) = _calculateReservesOutsideRange(\n                    (1e54 / temp_),\n                    (1e54 / prices_.lowerRangePrice),\n                    token1Supply_,\n                    token0Supply_\n                );\n            }\n        }\n\n        unchecked {\n            reserves_.token0ImaginaryReserves += token0Supply_;\n            reserves_.token1ImaginaryReserves += token1Supply_;\n            reserves_.token0RealReserves = token0Supply_;\n            reserves_.token1RealReserves = token1Supply_;\n        }\n\n        prices_.poolPrice = (reserves_.token1ImaginaryReserves * PRICE_PRECISION) / reserves_.token0ImaginaryReserves;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexLite/immutableVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./constantVariables.sol\";\n\nabstract contract ImmutableVariables is ConstantVariables {\n    // IMMUTABLE VARIABLES\n    IDexLite internal immutable DEX_LITE;\n    address internal immutable LIQUIDITY;\n    address internal immutable DEPLOYER_CONTRACT;\n}"
    },
    "contracts/periphery/resolvers/dexLite/interfaces.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./structs.sol\";\nimport { ICenterPrice } from \"../../../protocols/dexLite/other/interfaces.sol\";\n\ninterface IDexLite {\n    function swapSingle(\n        DexKey calldata dexKey_, \n        bool swap0To1_, \n        int256 amountSpecified_,\n        uint256 amountLimit_,\n        address to_,\n        bool isCallback_,\n        bytes calldata callbackData_,\n        bytes calldata extraData_\n    ) external payable returns (uint256 amountUnspecified_);\n\n    function swapHop(\n        address[] calldata path_,\n        DexKey[] calldata dexKeys_,\n        int256 amountSpecified_,\n        uint256[] calldata amountLimits_,\n        TransferParams calldata transferParams_\n    ) external payable returns (uint256 amountUnspecified_);\n\n    function readFromStorage(bytes32 slot) external view returns (bytes32);\n}"
    },
    "contracts/periphery/resolvers/dexLite/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./helpers.sol\";\n\ncontract FluidDexLiteResolver is Helpers {\n    constructor(address dexLite_, address liquidity_, address deployerContract_) {\n        DEX_LITE = IDexLite(dexLite_);\n        LIQUIDITY = liquidity_;\n        DEPLOYER_CONTRACT = deployerContract_;\n    }\n\n    function getAllDexes() public view returns (DexKey[] memory) {\n        uint256 totalDexes = uint256(DEX_LITE.readFromStorage(bytes32(DSL.DEX_LITE_DEXES_LIST_SLOT)));\n        DexKey[] memory dexes = new DexKey[](totalDexes);\n        for (uint256 i = 0; i < totalDexes; i++) {\n            dexes[i] = _readDexKeyAtIndex(i);\n        }\n        return dexes;\n    }\n\n    function getDexState(DexKey memory dexKey) public view returns (DexState memory) {\n        bytes8 dexId_ = _calculateDexId(dexKey);\n        (\n            uint256 dexVariables_,\n            uint256 centerPriceShift_,\n            uint256 rangeShift_,\n            uint256 thresholdShift_\n        ) = _readPoolState(dexId_);\n\n        return\n            DexState(\n                _unpackDexVariables(dexVariables_),\n                _unpackCenterPriceShift(centerPriceShift_),\n                _unpackRangeShift(rangeShift_),\n                _unpackThresholdShift(thresholdShift_)\n            );\n    }\n\n    function getPricesAndReserves(\n        DexKey memory dexKey\n    ) public returns (Prices memory prices_, Reserves memory reserves_) {\n        bytes8 dexId_ = _calculateDexId(dexKey);\n        (\n            uint256 dexVariables_,\n            uint256 centerPriceShift_,\n            uint256 rangeShift_,\n            uint256 thresholdShift_\n        ) = _readPoolState(dexId_);\n\n        uint256 token0Supply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60;\n        uint256 token1Supply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60;\n\n        return\n            _getPricesAndReserves(\n                dexKey,\n                dexVariables_,\n                centerPriceShift_,\n                rangeShift_,\n                thresholdShift_,\n                token0Supply_,\n                token1Supply_\n            );\n    }\n\n    function getDexEntireData(DexKey memory dexKey_) public returns (DexEntireData memory entireData_) {\n        entireData_.dexKey = dexKey_;\n        entireData_.constantViews = ConstantViews(\n            LIQUIDITY,\n            DEPLOYER_CONTRACT\n        );\n        entireData_.dexId = _calculateDexId(dexKey_);\n        entireData_.dexState = getDexState(dexKey_);\n        (entireData_.prices, entireData_.reserves) = getPricesAndReserves(dexKey_);\n    }\n\n    function getAllDexesEntireData() public returns (DexEntireData[] memory allDexesEntireData_) {\n        DexKey[] memory dexes_ = getAllDexes();\n        allDexesEntireData_ = new DexEntireData[](dexes_.length);\n        for (uint256 i = 0; i < dexes_.length; i++) {\n            allDexesEntireData_[i] = getDexEntireData(dexes_[i]);\n        }\n        return allDexesEntireData_;\n    }\n\n    function estimateSwapSingle(\n        DexKey calldata dexKey_,\n        bool swap0To1_,\n        int256 amountSpecified_\n    ) public returns (uint256 amountUnspecified_) {\n        try\n            DEX_LITE.swapSingle(\n                dexKey_,\n                swap0To1_,\n                amountSpecified_,\n                amountSpecified_ > 0 ? 0 : type(uint256).max,\n                address(0),\n                false,\n                \"\",\n                abi.encode(ESTIMATE_SWAP)\n            )\n        {\n            // Should not reach here\n            revert(\"Estimation Failed\");\n        } catch (bytes memory reason) {\n            // Check if this is the EstimateSwap error\n            if (reason.length >= 36) {\n                bytes4 errorSelector = bytes4(reason);\n                // EstimateSwap error selector should match\n                if (errorSelector == bytes4(keccak256(\"EstimateSwap(uint256)\"))) {\n                    // Skip the 4-byte selector and decode the uint256 parameter\n                    assembly {\n                        amountUnspecified_ := mload(add(reason, 36))\n                    }\n                } else {\n                    revert(\"Estimation Failed - Wrong Error\");\n                }\n            } else {\n                revert(\"Estimation Failed - Invalid Reason\");\n            }\n        }\n    }\n\n    function estimateSwapHop(\n        address[] calldata path_,\n        DexKey[] calldata dexKeys_,\n        int256 amountSpecified_\n    ) public returns (uint256 amountUnspecified_) {\n        uint256[] memory amountLimits_ = new uint256[](dexKeys_.length);\n        if (amountSpecified_ < 0) {\n            for (uint256 i = 0; i < dexKeys_.length; i++) {\n                amountLimits_[i] = type(uint256).max;\n            }\n        }\n\n        try\n            DEX_LITE.swapHop(\n                path_,\n                dexKeys_,\n                amountSpecified_,\n                amountLimits_,\n                TransferParams(address(0), false, \"\", abi.encode(ESTIMATE_SWAP))\n            )\n        {\n            // Should not reach here\n            revert(\"Estimation Failed\");\n        } catch (bytes memory reason) {\n            // Check if this is the EstimateSwap error\n            if (reason.length >= 36) {\n                bytes4 errorSelector = bytes4(reason);\n                // EstimateSwap error selector should match\n                if (errorSelector == bytes4(keccak256(\"EstimateSwap(uint256)\"))) {\n                    // Skip the 4-byte selector and decode the uint256 parameter\n                    assembly {\n                        amountUnspecified_ := mload(add(reason, 36))\n                    }\n                } else {\n                    revert(\"Estimation Failed - Wrong Error\");\n                }\n            } else {\n                revert(\"Estimation Failed - Invalid Reason\");\n            }\n        }\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexLite/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport { DexKey, TransferParams } from \"../../../protocols/dexLite/other/structs.sol\";\n\nstruct ConstantViews {\n    address liquidity;\n    address deployer;\n}\n\nstruct Prices {\n    uint256 poolPrice;\n    uint256 centerPrice;\n    uint256 upperRangePrice;\n    uint256 lowerRangePrice;\n    uint256 upperThresholdPrice;\n    uint256 lowerThresholdPrice;\n}\n\nstruct Reserves {\n    uint256 token0RealReserves;\n    uint256 token1RealReserves;\n    uint256 token0ImaginaryReserves;\n    uint256 token1ImaginaryReserves;\n}\n\nstruct DexVariables {\n    uint256 fee;\n    uint256 revenueCut;\n    uint256 rebalancingStatus;\n    bool isCenterPriceShiftActive;\n    uint256 centerPrice;\n    address centerPriceAddress;\n    bool isRangePercentShiftActive;\n    uint256 upperRangePercent;\n    uint256 lowerRangePercent;\n    bool isThresholdPercentShiftActive;\n    uint256 upperShiftThresholdPercent;\n    uint256 lowerShiftThresholdPercent;\n    uint256 token0Decimals;\n    uint256 token1Decimals;\n    uint256 totalToken0AdjustedAmount;\n    uint256 totalToken1AdjustedAmount;\n}\n\nstruct CenterPriceShift {\n    uint256 lastInteractionTimestamp;\n    // REBALANCING RELATED THINGS\n    uint256 rebalancingShiftingTime;\n    uint256 maxCenterPrice;\n    uint256 minCenterPrice;\n    // CENTER PRICE SHIFT RELATED THINGS\n    uint256 shiftPercentage;\n    uint256 centerPriceShiftingTime;\n    uint256 startTimestamp;\n}\n\nstruct RangeShift {\n    uint256 oldUpperRangePercent;\n    uint256 oldLowerRangePercent;\n    uint256 shiftingTime;\n    uint256 startTimestamp;\n}\n\nstruct ThresholdShift {\n    uint256 oldUpperThresholdPercent;\n    uint256 oldLowerThresholdPercent;\n    uint256 shiftingTime;\n    uint256 startTimestamp;\n}\n\nstruct DexState {\n    DexVariables dexVariables;\n    CenterPriceShift centerPriceShift;\n    RangeShift rangeShift;\n    ThresholdShift thresholdShift;\n}\n\nstruct DexEntireData {\n    bytes8 dexId;\n    DexKey dexKey;\n    ConstantViews constantViews;\n    Prices prices;\n    Reserves reserves;\n    DexState dexState;\n}"
    },
    "contracts/periphery/resolvers/liquidity/iLiquidityResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { Structs as LiquidityStructs } from \"../../../periphery/resolvers/liquidity/structs.sol\";\n\ninterface IFluidLiquidityResolver {\n    /// @notice gets the `revenueAmount_` for a `token_`.\n    function getRevenue(address token_) external view returns (uint256 revenueAmount_);\n\n    /// @notice address of contract that gets sent the revenue. Configurable by governance\n    function getRevenueCollector() external view returns (address);\n\n    /// @notice Liquidity contract paused status: status = 1 -> normal. status = 2 -> paused.\n    function getStatus() external view returns (uint256);\n\n    /// @notice checks if `auth_` is an allowed auth on Liquidity.\n    /// Auths can set most config values. E.g. contracts that automate certain flows like e.g. adding a new fToken.\n    /// Governance can add/remove auths. Governance is auth by default.\n    function isAuth(address auth_) external view returns (uint256);\n\n    /// @notice checks if `guardian_` is an allowed Guardian on Liquidity.\n    /// Guardians can pause lower class users.\n    /// Governance can add/remove guardians. Governance is guardian by default.\n    function isGuardian(address guardian_) external view returns (uint256);\n\n    /// @notice gets user class for `user_`. Class defines which protocols can be paused by guardians.\n    /// Currently there are 2 classes: 0 can be paused by guardians. 1 cannot be paused by guardians.\n    /// New protocols are added as class 0 and will be upgraded to 1 over time.\n    function getUserClass(address user_) external view returns (uint256);\n\n    /// @notice gets exchangePricesAndConfig packed uint256 storage slot for `token_`.\n    function getExchangePricesAndConfig(address token_) external view returns (uint256);\n\n    /// @notice gets rateConfig packed uint256 storage slot for `token_`.\n    function getRateConfig(address token_) external view returns (uint256);\n\n    /// @notice gets totalAmounts packed uint256 storage slot for `token_`.\n    function getTotalAmounts(address token_) external view returns (uint256);\n\n    /// @notice gets configs2 packed uint256 storage slot for `token_`.\n    function getConfigs2(address token_) external view returns (uint256);\n\n    /// @notice gets userSupply data packed uint256 storage slot for `user_` and `token_`.\n    function getUserSupply(address user_, address token_) external view returns (uint256);\n\n    /// @notice gets userBorrow data packed uint256 storage slot for `user_` and `token_`.\n    function getUserBorrow(address user_, address token_) external view returns (uint256);\n\n    /// @notice returns all `listedTokens_` at the Liquidity contract. Once configured, a token can never be removed.\n    function listedTokens() external view returns (address[] memory listedTokens_);\n\n    /// @notice get the Rate config data `rateData_` for a `token_` compiled from the packed uint256 rateConfig storage slot\n    function getTokenRateData(address token_) external view returns (LiquidityStructs.RateData memory rateData_);\n\n    /// @notice get the Rate config datas `rateDatas_` for multiple `tokens_` compiled from the packed uint256 rateConfig storage slot\n    function getTokensRateData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.RateData[] memory rateDatas_);\n\n    /// @notice returns general data for `token_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokenData(\n        address token_\n    ) external view returns (LiquidityStructs.OverallTokenData memory overallTokenData_);\n\n    /// @notice returns general data for multiple `tokens_` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getOverallTokensData(\n        address[] calldata tokens_\n    ) external view returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns general data for all `listedTokens()` such as rates, exchange prices, utilization, fee, total amounts etc.\n    function getAllOverallTokensData()\n        external\n        view\n        returns (LiquidityStructs.OverallTokenData[] memory overallTokensData_);\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserSupplyData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData memory userSupplyData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleSupplyData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for `token_`\n    function getUserBorrowData(\n        address user_,\n        address token_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData memory userBorrowData_,\n            LiquidityStructs.OverallTokenData memory overallTokenData_\n        );\n\n    /// @notice returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `tokens_`\n    function getUserMultipleBorrowData(\n        address user_,\n        address[] calldata tokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallTokensData_\n        );\n\n    /// @notice returns `user_` supply data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `supplyTokens_`\n    ///     and returns `user_` borrow data and general data (such as rates, exchange prices, utilization, fee, total amounts etc.) for multiple `borrowTokens_`\n    function getUserMultipleBorrowSupplyData(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    )\n        external\n        view\n        returns (\n            LiquidityStructs.UserSupplyData[] memory userSuppliesData_,\n            LiquidityStructs.OverallTokenData[] memory overallSupplyTokensData_,\n            LiquidityStructs.UserBorrowData[] memory userBorrowingsData_,\n            LiquidityStructs.OverallTokenData[] memory overallBorrowTokensData_\n        );\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { LiquidityCalcs } from \"../../../libraries/liquidityCalcs.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\nimport { LiquiditySlotsLink } from \"../../../libraries/liquiditySlotsLink.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport { IFluidLiquidityResolver } from \"./iLiquidityResolver.sol\";\nimport { Structs } from \"./structs.sol\";\nimport { Variables } from \"./variables.sol\";\n\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\n/// @notice Fluid Liquidity resolver\n/// Implements various view-only methods to give easy access to Liquidity data.\ncontract FluidLiquidityResolver is IFluidLiquidityResolver, Variables, Structs {\n    /// @dev address that is mapped to the chain native token\n    address internal constant _NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice thrown if an input param address is zero\n    error FluidLiquidityResolver__AddressZero();\n\n    constructor(IFluidLiquidity liquidity_) Variables(liquidity_) {\n        if (address(liquidity_) == address(0)) {\n            revert FluidLiquidityResolver__AddressZero();\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getRevenueCollector() public view returns (address) {\n        return address(uint160(LIQUIDITY.readFromStorage(bytes32(0))));\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getRevenue(address token_) public view returns (uint256 revenueAmount_) {\n        uint256 liquidityTokenBalance_ = token_ == _NATIVE_TOKEN_ADDRESS\n            ? address(LIQUIDITY).balance\n            : IERC20(token_).balanceOf(address(LIQUIDITY));\n\n        uint256 exchangePricesAndConfig_ = getExchangePricesAndConfig(token_);\n        if (exchangePricesAndConfig_ == 0) {\n            return 0;\n        }\n\n        return LiquidityCalcs.calcRevenue(getTotalAmounts(token_), exchangePricesAndConfig_, liquidityTokenBalance_);\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getStatus() public view returns (uint256) {\n        return LIQUIDITY.readFromStorage(bytes32(LiquiditySlotsLink.LIQUIDITY_STATUS_SLOT));\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function isAuth(address auth_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(LiquiditySlotsLink.LIQUIDITY_AUTHS_MAPPING_SLOT, auth_)\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function isGuardian(address guardian_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_GUARDIANS_MAPPING_SLOT,\n                    guardian_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserClass(address user_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_USER_CLASS_MAPPING_SLOT,\n                    user_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getExchangePricesAndConfig(address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getRateConfig(address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_RATE_DATA_MAPPING_SLOT,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getTotalAmounts(address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getConfigs2(address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_CONFIGS2_MAPPING_SLOT,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserSupply(address user_, address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                    user_,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserBorrow(address user_, address token_) public view returns (uint256) {\n        return\n            LIQUIDITY.readFromStorage(\n                LiquiditySlotsLink.calculateDoubleMappingStorageSlot(\n                    LiquiditySlotsLink.LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT,\n                    user_,\n                    token_\n                )\n            );\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function listedTokens() public view returns (address[] memory listedTokens_) {\n        uint256 length_ = LIQUIDITY.readFromStorage(bytes32(LiquiditySlotsLink.LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT));\n\n        listedTokens_ = new address[](length_);\n\n        uint256 startingSlotForArrayElements_ = uint256(\n            keccak256(abi.encode(LiquiditySlotsLink.LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT))\n        );\n\n        for (uint256 i; i < length_; i++) {\n            listedTokens_[i] = address(uint160(LIQUIDITY.readFromStorage(bytes32(startingSlotForArrayElements_ + i))));\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getTokenRateData(address token_) public view returns (RateData memory rateData_) {\n        uint256 rateConfig_ = getRateConfig(token_);\n\n        rateData_.version = rateConfig_ & 0xF;\n\n        if (rateData_.version == 1) {\n            rateData_.rateDataV1.token = token_;\n            rateData_.rateDataV1.rateAtUtilizationZero =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) &\n                X16;\n            rateData_.rateDataV1.kink = (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n            rateData_.rateDataV1.rateAtUtilizationKink =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) &\n                X16;\n            rateData_.rateDataV1.rateAtUtilizationMax =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) &\n                X16;\n        } else if (rateData_.version == 2) {\n            rateData_.rateDataV2.token = token_;\n            rateData_.rateDataV2.rateAtUtilizationZero =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) &\n                X16;\n            rateData_.rateDataV2.kink1 =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) &\n                X16;\n            rateData_.rateDataV2.rateAtUtilizationKink1 =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) &\n                X16;\n            rateData_.rateDataV2.kink2 =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) &\n                X16;\n            rateData_.rateDataV2.rateAtUtilizationKink2 =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) &\n                X16;\n            rateData_.rateDataV2.rateAtUtilizationMax =\n                (rateConfig_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) &\n                X16;\n        } else if (rateData_.version > 0) {\n            // when version is 0 -> token not configured yet. do not revert, just return 0 for all values\n            revert(\"not-valid-rate-version\");\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getTokensRateData(address[] calldata tokens_) public view returns (RateData[] memory rateDatas_) {\n        uint256 length_ = tokens_.length;\n        rateDatas_ = new RateData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            rateDatas_[i] = getTokenRateData(tokens_[i]);\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getOverallTokenData(\n        address token_\n    ) public view returns (Structs.OverallTokenData memory overallTokenData_) {\n        overallTokenData_.rateData = getTokenRateData(token_);\n\n        uint256 exchangePriceAndConfig_ = getExchangePricesAndConfig(token_);\n        if (exchangePriceAndConfig_ > 0) {\n            uint256 totalAmounts_ = getTotalAmounts(token_);\n\n            (overallTokenData_.supplyExchangePrice, overallTokenData_.borrowExchangePrice) = LiquidityCalcs\n                .calcExchangePrices(exchangePriceAndConfig_);\n\n            overallTokenData_.borrowRate = exchangePriceAndConfig_ & X16;\n            overallTokenData_.fee = (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14;\n            overallTokenData_.lastStoredUtilization =\n                (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) &\n                X14;\n            overallTokenData_.storageUpdateThreshold =\n                (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD) &\n                X14;\n            overallTokenData_.lastUpdateTimestamp =\n                (exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) &\n                X33;\n            overallTokenData_.maxUtilization = FOUR_DECIMALS;\n            if ((exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_USES_CONFIGS2) & 1 == 1) {\n                overallTokenData_.maxUtilization = getConfigs2(token_) & X14;\n            }\n\n            // Extract supply & borrow amounts\n            uint256 temp_ = totalAmounts_ & X64;\n            overallTokenData_.supplyRawInterest = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n            temp_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n            overallTokenData_.supplyInterestFree = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n            temp_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n            overallTokenData_.borrowRawInterest = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n            // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n            temp_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n            overallTokenData_.borrowInterestFree = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n            uint256 supplyWithInterest_;\n            uint256 borrowWithInterest_;\n            if (overallTokenData_.supplyRawInterest > 0) {\n                // use old exchange prices for supply rate to be at same level as borrow rate from storage.\n                // Note the rate here can be a tiny bit with higher precision because we use borrowWithInterest_ / supplyWithInterest_\n                // which has higher precision than the utilization used from storage in LiquidityCalcs\n                supplyWithInterest_ =\n                    (overallTokenData_.supplyRawInterest *\n                        ((exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n                            X64)) /\n                    EXCHANGE_PRICES_PRECISION; // normalized from raw\n                borrowWithInterest_ =\n                    (overallTokenData_.borrowRawInterest *\n                        ((exchangePriceAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n                            X64)) /\n                    EXCHANGE_PRICES_PRECISION; // normalized from raw\n\n                overallTokenData_.supplyRate = supplyWithInterest_ == 0\n                    ? 0\n                    : (overallTokenData_.borrowRate * (FOUR_DECIMALS - overallTokenData_.fee) * borrowWithInterest_) /\n                        (supplyWithInterest_ * FOUR_DECIMALS);\n            }\n\n            supplyWithInterest_ =\n                (overallTokenData_.supplyRawInterest * overallTokenData_.supplyExchangePrice) /\n                EXCHANGE_PRICES_PRECISION; // normalized from raw\n            overallTokenData_.totalSupply = supplyWithInterest_ + overallTokenData_.supplyInterestFree;\n            borrowWithInterest_ =\n                (overallTokenData_.borrowRawInterest * overallTokenData_.borrowExchangePrice) /\n                EXCHANGE_PRICES_PRECISION; // normalized from raw\n            overallTokenData_.totalBorrow = borrowWithInterest_ + overallTokenData_.borrowInterestFree;\n\n            overallTokenData_.revenue = getRevenue(token_);\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getOverallTokensData(\n        address[] memory tokens_\n    ) public view returns (Structs.OverallTokenData[] memory overallTokensData_) {\n        uint256 length_ = tokens_.length;\n        overallTokensData_ = new Structs.OverallTokenData[](length_);\n        for (uint256 i; i < length_; i++) {\n            overallTokensData_[i] = getOverallTokenData(tokens_[i]);\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getAllOverallTokensData() public view returns (Structs.OverallTokenData[] memory overallTokensData_) {\n        return getOverallTokensData(listedTokens());\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserSupplyData(\n        address user_,\n        address token_\n    )\n        public\n        view\n        returns (Structs.UserSupplyData memory userSupplyData_, Structs.OverallTokenData memory overallTokenData_)\n    {\n        overallTokenData_ = getOverallTokenData(token_);\n        uint256 userSupply_ = getUserSupply(user_, token_);\n\n        if (userSupply_ > 0) {\n            // if userSupply_ == 0 -> user not configured yet for token at Liquidity\n            userSupplyData_.modeWithInterest = userSupply_ & 1 == 1;\n            userSupplyData_.supply = BigMathMinified.fromBigNumber(\n                (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_AMOUNT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            // get updated expanded withdrawal limit\n            userSupplyData_.withdrawalLimit = LiquidityCalcs.calcWithdrawalLimitBeforeOperate(\n                userSupply_,\n                userSupplyData_.supply\n            );\n\n            userSupplyData_.lastUpdateTimestamp =\n                (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) &\n                X33;\n            userSupplyData_.expandPercent = (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n            userSupplyData_.expandDuration = (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24;\n            userSupplyData_.baseWithdrawalLimit = BigMathMinified.fromBigNumber(\n                (userSupply_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            if (userSupplyData_.modeWithInterest) {\n                // convert raw amounts to normal for withInterest mode\n                userSupplyData_.supply =\n                    (userSupplyData_.supply * overallTokenData_.supplyExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n                userSupplyData_.withdrawalLimit =\n                    (userSupplyData_.withdrawalLimit * overallTokenData_.supplyExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n                userSupplyData_.baseWithdrawalLimit =\n                    (userSupplyData_.baseWithdrawalLimit * overallTokenData_.supplyExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n            }\n\n            userSupplyData_.withdrawableUntilLimit = userSupplyData_.supply > userSupplyData_.withdrawalLimit\n                ? userSupplyData_.supply - userSupplyData_.withdrawalLimit\n                : 0;\n            uint balanceOf_ = token_ == _NATIVE_TOKEN_ADDRESS\n                ? address(LIQUIDITY).balance\n                : TokenInterface(token_).balanceOf(address(LIQUIDITY));\n\n            userSupplyData_.withdrawable = balanceOf_ > userSupplyData_.withdrawableUntilLimit\n                ? userSupplyData_.withdrawableUntilLimit\n                : balanceOf_;\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserMultipleSupplyData(\n        address user_,\n        address[] calldata tokens_\n    )\n        public\n        view\n        returns (\n            Structs.UserSupplyData[] memory userSuppliesData_,\n            Structs.OverallTokenData[] memory overallTokensData_\n        )\n    {\n        uint256 length_ = tokens_.length;\n        userSuppliesData_ = new Structs.UserSupplyData[](length_);\n        overallTokensData_ = new Structs.OverallTokenData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            (userSuppliesData_[i], overallTokensData_[i]) = getUserSupplyData(user_, tokens_[i]);\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserBorrowData(\n        address user_,\n        address token_\n    )\n        public\n        view\n        returns (Structs.UserBorrowData memory userBorrowData_, Structs.OverallTokenData memory overallTokenData_)\n    {\n        overallTokenData_ = getOverallTokenData(token_);\n        uint256 userBorrow_ = getUserBorrow(user_, token_);\n\n        if (userBorrow_ > 0) {\n            // if userBorrow_ == 0 -> user not configured yet for token at Liquidity\n\n            userBorrowData_.modeWithInterest = userBorrow_ & 1 == 1;\n\n            userBorrowData_.borrow = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_AMOUNT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            // get updated expanded borrow limit\n            userBorrowData_.borrowLimit = LiquidityCalcs.calcBorrowLimitBeforeOperate(\n                userBorrow_,\n                userBorrowData_.borrow\n            );\n\n            userBorrowData_.lastUpdateTimestamp =\n                (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) &\n                X33;\n            userBorrowData_.expandPercent = (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n            userBorrowData_.expandDuration = (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24;\n            userBorrowData_.baseBorrowLimit = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n            userBorrowData_.maxBorrowLimit = BigMathMinified.fromBigNumber(\n                (userBorrow_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n            if (userBorrowData_.modeWithInterest) {\n                // convert raw amounts to normal for withInterest mode\n                userBorrowData_.borrow =\n                    (userBorrowData_.borrow * overallTokenData_.borrowExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n                userBorrowData_.borrowLimit =\n                    (userBorrowData_.borrowLimit * overallTokenData_.borrowExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n                userBorrowData_.baseBorrowLimit =\n                    (userBorrowData_.baseBorrowLimit * overallTokenData_.borrowExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n                userBorrowData_.maxBorrowLimit =\n                    (userBorrowData_.maxBorrowLimit * overallTokenData_.borrowExchangePrice) /\n                    EXCHANGE_PRICES_PRECISION;\n            }\n\n            userBorrowData_.borrowLimitUtilization =\n                (overallTokenData_.maxUtilization * overallTokenData_.totalSupply) /\n                1e4;\n\n            // uncollected revenue is counting towards available balanceOf.\n            // because of this \"borrowable\" would be showing an amount that can go above 100% utilization, causing a revert.\n            // need to take into consideration the borrowable amount until the max utilization limit, which depends on the total\n            // borrow amount (not user specific)\n            uint borrowableUntilUtilizationLimit_ = userBorrowData_.borrowLimitUtilization >\n                overallTokenData_.totalBorrow\n                ? userBorrowData_.borrowLimitUtilization - overallTokenData_.totalBorrow\n                : 0;\n\n            uint borrowableUntilBorrowLimit_ = userBorrowData_.borrowLimit > userBorrowData_.borrow\n                ? userBorrowData_.borrowLimit - userBorrowData_.borrow\n                : 0;\n\n            userBorrowData_.borrowableUntilLimit = borrowableUntilBorrowLimit_ > borrowableUntilUtilizationLimit_\n                ? borrowableUntilUtilizationLimit_\n                : borrowableUntilBorrowLimit_;\n\n            // if available balance at Liquidity is less than the borrowableUntilLimit amount, then the balance is\n            // the limiting borrowable amount.\n            uint balanceOf_ = token_ == _NATIVE_TOKEN_ADDRESS\n                ? address(LIQUIDITY).balance\n                : TokenInterface(token_).balanceOf(address(LIQUIDITY));\n\n            userBorrowData_.borrowable = balanceOf_ > userBorrowData_.borrowableUntilLimit\n                ? userBorrowData_.borrowableUntilLimit\n                : balanceOf_;\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserMultipleBorrowData(\n        address user_,\n        address[] calldata tokens_\n    )\n        public\n        view\n        returns (\n            Structs.UserBorrowData[] memory userBorrowingsData_,\n            Structs.OverallTokenData[] memory overallTokensData_\n        )\n    {\n        uint256 length_ = tokens_.length;\n        userBorrowingsData_ = new UserBorrowData[](length_);\n        overallTokensData_ = new Structs.OverallTokenData[](length_);\n\n        for (uint256 i; i < length_; i++) {\n            (userBorrowingsData_[i], overallTokensData_[i]) = getUserBorrowData(user_, tokens_[i]);\n        }\n    }\n\n    /// @inheritdoc IFluidLiquidityResolver\n    function getUserMultipleBorrowSupplyData(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    )\n        public\n        view\n        returns (\n            Structs.UserSupplyData[] memory userSuppliesData_,\n            Structs.OverallTokenData[] memory overallSupplyTokensData_,\n            Structs.UserBorrowData[] memory userBorrowingsData_,\n            Structs.OverallTokenData[] memory overallBorrowTokensData_\n        )\n    {\n        uint256 length_ = supplyTokens_.length;\n        userSuppliesData_ = new Structs.UserSupplyData[](length_);\n        overallSupplyTokensData_ = new Structs.OverallTokenData[](length_);\n        for (uint256 i; i < length_; i++) {\n            (userSuppliesData_[i], overallSupplyTokensData_[i]) = getUserSupplyData(user_, supplyTokens_[i]);\n        }\n\n        length_ = borrowTokens_.length;\n        userBorrowingsData_ = new UserBorrowData[](length_);\n        overallBorrowTokensData_ = new Structs.OverallTokenData[](length_);\n        for (uint256 i; i < length_; i++) {\n            (userBorrowingsData_[i], overallBorrowTokensData_[i]) = getUserBorrowData(user_, borrowTokens_[i]);\n        }\n    }\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { Structs as AdminModuleStructs } from \"../../../liquidity/adminModule/structs.sol\";\n\nabstract contract Structs {\n    struct RateData {\n        uint256 version;\n        AdminModuleStructs.RateDataV1Params rateDataV1;\n        AdminModuleStructs.RateDataV2Params rateDataV2;\n    }\n\n    struct OverallTokenData {\n        uint256 borrowRate;\n        uint256 supplyRate;\n        uint256 fee; // revenue fee\n        uint256 lastStoredUtilization;\n        uint256 storageUpdateThreshold;\n        uint256 lastUpdateTimestamp;\n        uint256 supplyExchangePrice;\n        uint256 borrowExchangePrice;\n        uint256 supplyRawInterest;\n        uint256 supplyInterestFree;\n        uint256 borrowRawInterest;\n        uint256 borrowInterestFree;\n        uint256 totalSupply;\n        uint256 totalBorrow;\n        uint256 revenue;\n        uint256 maxUtilization; // maximum allowed utilization\n        RateData rateData;\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserSupplyData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 supply; // user supply amount\n        // the withdrawal limit (e.g. if 10% is the limit, and 100M is supplied, it would be 90M)\n        uint256 withdrawalLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent; // withdrawal limit expand percent in 1e2\n        uint256 expandDuration; // withdrawal limit expand duration in seconds\n        uint256 baseWithdrawalLimit;\n        // the current actual max withdrawable amount (e.g. if 10% is the limit, and 100M is supplied, it would be 10M)\n        uint256 withdrawableUntilLimit;\n        uint256 withdrawable; // actual currently withdrawable amount (supply - withdrawal Limit) & considering balance\n    }\n\n    // amounts are always in normal (for withInterest already multiplied with exchange price)\n    struct UserBorrowData {\n        bool modeWithInterest; // true if mode = with interest, false = without interest\n        uint256 borrow; // user borrow amount\n        uint256 borrowLimit;\n        uint256 lastUpdateTimestamp;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n        uint256 borrowableUntilLimit; // borrowable amount until any borrow limit (incl. max utilization limit)\n        uint256 borrowable; // actual currently borrowable amount (borrow limit - already borrowed) & considering balance, max utilization\n        uint256 borrowLimitUtilization; // borrow limit for `maxUtilization`\n    }\n}\n"
    },
    "contracts/periphery/resolvers/liquidity/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\n\ncontract Variables {\n    /// @dev Storage slot with the admin of the contract. Logic from \"proxy.sol\".\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n    /// validated in the constructor.\n    bytes32 internal constant GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 10;\n    uint256 internal constant DEFAULT_COEFFICIENT_SIZE = 56;\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 10000;\n    uint256 internal constant X8 = 0xff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    /// @notice address of the liquidity contract\n    IFluidLiquidity public immutable LIQUIDITY;\n\n    constructor(IFluidLiquidity liquidity_) {\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n    }\n}\n"
    },
    "contracts/protocols/dexLite/adminModule/errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./structs.sol\";\n\nerror InvalidParams();\nerror OnlyDelegateCallAllowed();\nerror AddressNotAContract(address addr);\nerror InvalidTokenOrder(address token0, address token1);\nerror DexNotInitialized(bytes32 dexId);\nerror DexAlreadyInitialized(bytes32 dexId);\nerror InvalidRevenueCut(uint256 revenueCut);\nerror InsufficientMsgValue(uint256 msgValue, uint256 requiredAmount);\nerror SlippageLimitExceeded(uint256 price, uint256 priceMax, uint256 priceMin);"
    },
    "contracts/protocols/dexLite/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./errors.sol\";\n\nevent LogUpdateAuth(address auth, bool isAuth);\n\nevent LogInitialize(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 centerPriceShift, InitializeParams i);\n\nevent LogUpdateFeeAndRevenueCut(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 fee, uint256 revenueCut);\n\nevent LogUpdateRebalancingStatus(DexKey dexKey, bytes8 dexId, uint256 dexVariables, bool rebalancingStatus);\n\nevent LogUpdateRangePercents(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 rangeShift, uint256 upperPercent, uint256 lowerPercent, uint256 shiftTime);\n\nevent LogUpdateShiftTime(DexKey dexKey, bytes8 dexId, uint256 centerPriceShift, uint256 shiftTime);\n\nevent LogUpdateCenterPriceLimits(DexKey dexKey, bytes8 dexId, uint256 centerPriceShift, uint256 maxCenterPrice, uint256 minCenterPrice);\n\nevent LogUpdateThresholdPercent(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 thresholdShift, uint256 upperThresholdPercent, uint256 lowerThresholdPercent, uint256 shiftTime);\n\nevent LogUpdateCenterPriceAddress(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 centerPriceShift, uint256 centerPriceContract, uint256 percent, uint256 time);\n\nevent LogDeposit(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 token0Amount, uint256 token1Amount);\n\nevent LogWithdraw(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 token0Amount, uint256 token1Amount);\n\nevent LogCollectRevenue(address[] tokens, uint256[] amounts, address to);\n\nevent LogUpdateExtraDataAddress(address extraDataAddress);\n"
    },
    "contracts/protocols/dexLite/adminModule/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./immutableVariables.sol\";\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\nimport { DexLiteSlotsLink as DSL } from \"../../../libraries/dexLiteSlotsLink.sol\";\nimport { AddressCalcs as AC } from \"../../../libraries/addressCalcs.sol\";\nimport { FixedPointMathLib as FPM } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nabstract contract AdminModuleHelpers is AdminModuleImmutableVariables {\n    modifier _onlyDelegateCall() {\n        if (address(this) == THIS_ADDRESS) revert OnlyDelegateCallAllowed();\n        _;\n    }\n\n    /// @dev checks that `value_` address is a contract (which includes address zero check)\n    function _checkIsContract(address value_) internal view {\n        if (value_.code.length == 0) {\n            revert AddressNotAContract(value_);\n        }\n    }\n\n    function _calculateNumeratorAndDenominatorPrecisions(uint256 decimals_) internal pure returns (uint256 numerator_, uint256 denominator_) {\n        if (decimals_ > TOKENS_DECIMALS_PRECISION) {\n            numerator_ = 1;\n            denominator_ = 10 ** (decimals_ - TOKENS_DECIMALS_PRECISION);\n        } else {\n            numerator_ = 10 ** (TOKENS_DECIMALS_PRECISION - decimals_);\n            denominator_ = 1;\n        }\n    }\n\n    function _transferTokenIn(address token_, uint256 amount_) internal {\n        if (amount_ == 0) return;\n\n        if (token_ == NATIVE_TOKEN) {\n            if (msg.value < amount_) revert InsufficientMsgValue(msg.value, amount_);\n            if (msg.value > amount_) SafeTransfer.safeTransferNative(msg.sender, msg.value - amount_);\n        } else SafeTransfer.safeTransferFrom(token_, msg.sender, address(this), amount_);\n    }\n\n    function _transferTokenOut(address token_, uint256 amount_, address to_) internal {\n        if (amount_ == 0) return;\n\n        if (token_ == NATIVE_TOKEN) SafeTransfer.safeTransferNative(to_, amount_);\n        else SafeTransfer.safeTransfer(token_, to_, amount_);\n    }\n\n    function _calculateReservesOutsideRange(\n        uint256 gp_,\n        uint256 pa_,\n        uint256 rx_,\n        uint256 ry_\n    ) internal pure returns (uint256 xa_, uint256 yb_) {\n        // equations we have:\n        // 1. x*y = k\n        // 2. xa*ya = k\n        // 3. xb*yb = k\n        // 4. Pa = ya / xa = upperRange_ (known)\n        // 5. Pb = yb / xb = lowerRange_ (known)\n        // 6. x - xa = rx = real reserve of x (known)\n        // 7. y - yb = ry = real reserve of y (known)\n        // With solving we get:\n        // ((Pa*Pb)^(1/2) - Pa)*xa^2 + (rx * (Pa*Pb)^(1/2) + ry)*xa + rx*ry = 0\n        // yb = yb = xa * (Pa * Pb)^(1/2)\n\n        // xa = (GP⋅rx + ry + (-rx⋅ry⋅4⋅(GP - Pa) + (GP⋅rx + ry)^2)^0.5) / (2Pa - 2GP)\n        // multiply entire equation by 1e27 to remove the price decimals precision of 1e27\n        // xa = (GP⋅rx + ry⋅1e27 + (rx⋅ry⋅4⋅(Pa - GP)⋅1e27 + (GP⋅rx + ry⋅1e27)^2)^0.5) / 2*(Pa - GP)\n        // dividing the equation with 2*(Pa - GP). Pa is always > GP so answer will be positive.\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅4⋅(Pa - GP)⋅1e27) / 4*(Pa - GP)^2) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅1e27) / (Pa - GP)) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n\n        // dividing in 3 parts for simplification:\n        // part1 = (Pa - GP)\n        // part2 = (GP⋅rx + ry⋅1e27) / (2*part1)\n        // part3 = rx⋅ry\n        // note: part1 will almost always be < 1e28 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e29\n        unchecked {\n            uint256 p1_ = pa_ - gp_;\n            uint256 p2_ = ((gp_ * rx_) + (ry_ * PRICE_PRECISION)) / (2 * p1_);\n\n            // removed <1e50 check becuase rx_ * ry_ will never be greater than 1e50\n            // Directly used p3_ below instead of using a variable for it\n            // uint256 p3_ = (rx_ * ry_ * PRICE_PRECISION) / p1_;\n\n            // xa = part2 + (part3 + (part2 * part2))^(1/2)\n            // yb = xa_ * gp_\n            xa_ = p2_ + FPM.sqrt((((rx_ * ry_ * PRICE_PRECISION) / p1_) + (p2_ * p2_)));\n            yb_ = (xa_ * gp_) / PRICE_PRECISION;\n        }\n    }\n\n    function _calcShiftingDone(\n        uint256 current_,\n        uint256 old_,\n        uint256 timePassed_,\n        uint256 shiftDuration_\n    ) internal pure returns (uint256) {\n        unchecked {\n            if (current_ > old_) {\n                return (old_ + (((current_ - old_) * timePassed_) / shiftDuration_));\n            } else {\n                return (old_ - (((old_ - current_) * timePassed_) / shiftDuration_));\n            }\n        }\n    }\n\n    function _calcRangeShifting(\n        uint256 upperRange_,\n        uint256 lowerRange_,\n        bytes8 dexId_\n    ) internal view returns (uint256, uint256) {\n        uint256 rangeShift_ = _rangeShift[dexId_];\n        uint256 shiftDuration_ = (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT) & X20;\n        uint256 startTimeStamp_ = (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP) & X33;\n\n        uint256 timePassed_;\n        unchecked {\n            if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n                // shifting fully done\n                // delete _rangeShift[dexId_];\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables only updates from this function and _calcThresholdShifting.\n                // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE);\n                return (upperRange_, lowerRange_);\n            }\n            timePassed_ = block.timestamp - startTimeStamp_;\n        }\n        return (\n            _calcShiftingDone(\n                upperRange_,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT) & X14,\n                timePassed_,\n                shiftDuration_\n            ),\n            _calcShiftingDone(\n                lowerRange_,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT) & X14,\n                timePassed_,\n                shiftDuration_\n            )\n        );\n    }\n\n    function _calcThresholdShifting(\n        uint256 upperThreshold_,\n        uint256 lowerThreshold_,\n        bytes8 dexId_\n    ) internal view returns (uint256, uint256) {\n        uint256 thresholdShift_ = _thresholdShift[dexId_];\n        uint256 shiftDuration_ = (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT) & X20;\n        uint256 startTimeStamp_ = (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP) & X33;\n\n        uint256 timePassed_;\n        unchecked {\n            if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n                // shifting fully done\n                // delete _thresholdShift[dexId_];\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcRangeShifting.\n                // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE);\n                return (upperThreshold_, lowerThreshold_);\n            }\n            timePassed_ = block.timestamp - startTimeStamp_;\n        }\n        return (\n            _calcShiftingDone(\n                upperThreshold_,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT) & X7,\n                timePassed_,\n                shiftDuration_\n            ),\n            _calcShiftingDone(\n                lowerThreshold_,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT) & X7,\n                timePassed_,\n                shiftDuration_\n            )\n        );\n    }\n\n    function _calcCenterPrice(\n        DexKey memory dexKey_,\n        uint256 dexVariables_,\n        bytes8 dexId_\n    ) internal returns (uint256 newCenterPrice_) {\n        uint256 oldCenterPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n        oldCenterPrice_ = (oldCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (oldCenterPrice_ & DEFAULT_EXPONENT_MASK);\n        uint256 centerPriceShift_ = _centerPriceShift[dexId_];\n        uint256 startTimeStamp_ = (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP) & X33;\n\n        uint256 fromTimeStamp_ = (centerPriceShift_ >>\n            DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33;\n        fromTimeStamp_ = fromTimeStamp_ > startTimeStamp_ ? fromTimeStamp_ : startTimeStamp_;\n\n        newCenterPrice_ = ICenterPrice(\n            AC.addressCalc(\n                DEPLOYER_CONTRACT,\n                ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) & X19)\n            )\n        ).centerPrice(dexKey_.token0, dexKey_.token1);\n\n        unchecked {\n            uint256 priceShift_ = (oldCenterPrice_ *\n                ((centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT) & X20) *\n                (block.timestamp - fromTimeStamp_)) /\n                (((centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT) & X20) * SIX_DECIMALS);\n\n            if (newCenterPrice_ > oldCenterPrice_) {\n                // shift on positive side\n                oldCenterPrice_ += priceShift_;\n                if (newCenterPrice_ > oldCenterPrice_) {\n                    newCenterPrice_ = oldCenterPrice_;\n                } else {\n                    // shifting fully done\n                    // _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n                    // making active shift as 0 because shift is over\n                    // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                    // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n                }\n            } else {\n                oldCenterPrice_ = oldCenterPrice_ > priceShift_ ? oldCenterPrice_ - priceShift_ : 0;\n                // In case of oldCenterPrice_ ending up 0, which could happen when a lot of time has passed (pool has no swaps for many days or weeks)\n                // then below we get into the else logic which will fully conclude shifting and return newCenterPrice_\n                // as it was fetched from the external center price source.\n                // not ideal that this would ever happen unless the pool is not in use and all/most users have left leaving not enough liquidity to trade on\n                if (newCenterPrice_ < oldCenterPrice_) {\n                    newCenterPrice_ = oldCenterPrice_;\n                } else {\n                    // shifting fully done\n                    // _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n                    // making active shift as 0 because shift is over\n                    // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                    // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n                }\n            }\n        }\n    }\n\n    function _getPrice(\n        DexKey calldata dexKey_,\n        uint256 dexVariables_,\n        bytes8 dexId_,\n        uint256 token0Supply_,\n        uint256 token1Supply_\n    ) internal returns (uint256 price_) {\n        uint256 centerPrice_;\n        // Fetch center price\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE) & X1) == 0) {\n            // centerPrice_ => center price nonce\n            centerPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) & X19;\n            if (centerPrice_ == 0) {\n                centerPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n                centerPrice_ = \n                    ICenterPrice(AC.addressCalc(DEPLOYER_CONTRACT, centerPrice_)).centerPrice(dexKey_.token0, dexKey_.token1);\n            }\n        } else {\n            // an active centerPrice_ shift is going on\n            centerPrice_ = _calcCenterPrice(dexKey_, dexVariables_, dexId_);\n        }\n\n        uint256 upperRangePercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14;\n        uint256 lowerRangePercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14;\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) & X1) == 1) {\n            // an active range shift is going on\n            (upperRangePercent_, lowerRangePercent_) = _calcRangeShifting(upperRangePercent_, lowerRangePercent_, dexId_);\n        }\n\n        uint256 upperRangePrice_;\n        uint256 lowerRangePrice_;\n        unchecked {\n            // 1% = 1e2, 100% = 1e4\n            upperRangePrice_ = (centerPrice_ * FOUR_DECIMALS) / (FOUR_DECIMALS - upperRangePercent_);\n            // 1% = 1e2, 100% = 1e4\n            lowerRangePrice_ = (centerPrice_ * (FOUR_DECIMALS - lowerRangePercent_)) / FOUR_DECIMALS;\n        }\n\n        // Rebalance center price if rebalancing is on\n        // temp_ => rebalancingStatus_\n        uint256 temp_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) & X2;\n        uint256 temp2_;\n        if (temp_ > 1) {\n            unchecked {\n                // temp2_ => centerPriceShift_\n                if (temp_ == 2) {\n                    temp2_ = _centerPriceShift[dexId_];\n                    uint256 shiftingTime_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24;\n                    uint256 timeElapsed_ = block.timestamp - ((temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33);\n                    // price shifting towards upper range\n                    if (timeElapsed_ < shiftingTime_) {\n                        centerPrice_ = centerPrice_ + (((upperRangePrice_ - centerPrice_) * timeElapsed_) / shiftingTime_);\n                    } else {\n                        // 100% price shifted\n                        centerPrice_ = upperRangePrice_;\n                    }\n                } else if (temp_ == 3) {\n                    temp2_ = _centerPriceShift[dexId_];\n                    uint256 shiftingTime_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24;\n                    uint256 timeElapsed_ = block.timestamp - ((temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33);\n                    // price shifting towards lower range\n                    if (timeElapsed_ < shiftingTime_) {\n                        centerPrice_ = centerPrice_ - (((centerPrice_ - lowerRangePrice_) * timeElapsed_) / shiftingTime_);\n                    } else {\n                        // 100% price shifted\n                        centerPrice_ = lowerRangePrice_;\n                    }\n                }\n\n                // If rebalancing actually happened then make sure price is within min and max bounds, and update range prices\n                if (temp2_ > 0) {\n                    // Make sure center price is within min and max bounds\n                    // temp_ => max center price\n                    temp_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) & X28;\n                    temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n                    if (centerPrice_ > temp_) {\n                        // if center price is greater than max center price\n                        centerPrice_ = temp_;\n                    } else {\n                        // check if center price is less than min center price\n                        // temp_ => min center price\n                        temp_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE) & X28;\n                        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n                        if (centerPrice_ < temp_) centerPrice_ = temp_;\n                    }\n\n                    // Update range prices as center price moved\n                    upperRangePrice_ = (centerPrice_ * FOUR_DECIMALS) / (FOUR_DECIMALS - upperRangePercent_);\n                    lowerRangePrice_ = (centerPrice_ * (FOUR_DECIMALS - lowerRangePercent_)) / FOUR_DECIMALS;\n                }\n            }  \n        }\n\n        // temp_ => geometricMeanPrice_\n        unchecked {         \n            if (upperRangePrice_ < 1e38) {\n                // 1e38 * 1e38 = 1e76 which is less than max uint limit\n                temp_ = FPM.sqrt(upperRangePrice_ * lowerRangePrice_);\n            } else {\n                // upperRange_ price is pretty large hence lowerRange_ will also be pretty large\n                temp_ = FPM.sqrt((upperRangePrice_ / 1e18) * (lowerRangePrice_ / 1e18)) * 1e18;\n            }\n        }\n\n        uint256 token0ImaginaryReserves_;\n        uint256 token1ImaginaryReserves_;\n\n        if (temp_ < 1e27) {\n            (token0ImaginaryReserves_, token1ImaginaryReserves_) = \n                _calculateReservesOutsideRange(temp_, upperRangePrice_, token0Supply_, token1Supply_);\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            unchecked {\n                (token1ImaginaryReserves_, token0ImaginaryReserves_) = _calculateReservesOutsideRange(\n                    (1e54 / temp_),\n                    (1e54 / lowerRangePrice_),\n                    token1Supply_,\n                    token0Supply_\n                );\n            }\n        }\n\n        unchecked {\n            token0ImaginaryReserves_ += token0Supply_;\n            token1ImaginaryReserves_ += token1Supply_;\n        }\n\n        price_ = token1ImaginaryReserves_ * PRICE_PRECISION / token0ImaginaryReserves_;\n    }\n}\n"
    },
    "contracts/protocols/dexLite/adminModule/immutableVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./events.sol\";\n\nabstract contract AdminModuleImmutableVariables is CommonImport {\n    address internal immutable THIS_ADDRESS;\n}\n"
    },
    "contracts/protocols/dexLite/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport { BigMathMinified as BM } from \"../../../libraries/bigMathMinified.sol\";\nimport \"./helpers.sol\";\n\ncontract FluidDexLiteAdminModule is AdminModuleHelpers {\n    constructor(address liquidity_, address deployerContract_) {\n        THIS_ADDRESS = address(this);\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        DEPLOYER_CONTRACT = deployerContract_;\n    }\n\n    /// @dev update the auth for the dex\n    /// @param auth_ the address to update auth for\n    /// @param isAuth_ the auth status\n    function updateAuth(address auth_, bool isAuth_) external _onlyDelegateCall {\n        _isAuth[auth_] = isAuth_ ? 1 : 0;\n        \n        emit LogUpdateAuth(auth_, isAuth_);\n    }\n\n    /// @dev initialize the dex\n    /// @param i_ the initialize params\n    function initialize(InitializeParams memory i_) external payable _onlyDelegateCall {\n        if (i_.dexKey.token0 == address(0) || i_.dexKey.token1 == address(0) || i_.dexKey.token0 >= i_.dexKey.token1) {\n            revert InvalidTokenOrder(i_.dexKey.token0, i_.dexKey.token1);\n        }\n\n        InitializeVariables memory v_;\n\n        v_.dexId = bytes8(keccak256(abi.encode(i_.dexKey)));\n        if (_dexVariables[v_.dexId] != 0) {\n            revert DexAlreadyInitialized(v_.dexId);\n        }\n\n        v_.token0Decimals = i_.dexKey.token0 == NATIVE_TOKEN ? NATIVE_TOKEN_DECIMALS : IERC20WithDecimals(i_.dexKey.token0).decimals();\n        v_.token1Decimals = i_.dexKey.token1 == NATIVE_TOKEN ? NATIVE_TOKEN_DECIMALS : IERC20WithDecimals(i_.dexKey.token1).decimals();\n\n        // cut is an integer in storage slot which is more than enough\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\n        if (i_.revenueCut != 0 && i_.revenueCut < FOUR_DECIMALS) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert InvalidRevenueCut(i_.revenueCut);\n        }\n\n        i_.revenueCut = i_.revenueCut / FOUR_DECIMALS;\n\n        i_.upperPercent = i_.upperPercent / TWO_DECIMALS;\n        i_.lowerPercent = i_.lowerPercent / TWO_DECIMALS;\n\n        i_.upperShiftThreshold = i_.upperShiftThreshold / FOUR_DECIMALS;\n        i_.lowerShiftThreshold = i_.lowerShiftThreshold / FOUR_DECIMALS;\n\n        if (\n            (i_.fee > X13) ||\n            (i_.revenueCut > TWO_DECIMALS) ||\n            (i_.centerPrice <= i_.minCenterPrice) ||\n            (i_.centerPrice >= i_.maxCenterPrice) ||\n            (i_.centerPriceContract > X19) ||\n            (i_.upperPercent > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (i_.lowerPercent > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (i_.upperPercent == 0) ||\n            (i_.lowerPercent == 0) ||\n            (i_.upperShiftThreshold > TWO_DECIMALS) ||\n            (i_.lowerShiftThreshold > TWO_DECIMALS) ||\n            ((i_.upperShiftThreshold == 0) && (i_.lowerShiftThreshold > 0)) ||\n            ((i_.upperShiftThreshold > 0) && (i_.lowerShiftThreshold == 0)) ||\n            (i_.shiftTime == 0) ||\n            (i_.shiftTime > X24) ||\n            (i_.minCenterPrice == 0) || \n            (v_.token0Decimals < MIN_TOKEN_DECIMALS) ||\n            (v_.token0Decimals > MAX_TOKEN_DECIMALS) ||\n            (v_.token1Decimals < MIN_TOKEN_DECIMALS) ||\n            (v_.token1Decimals > MAX_TOKEN_DECIMALS)\n        ) {\n            revert InvalidParams();\n        }\n\n        _transferTokenIn(i_.dexKey.token0, i_.token0Amount);\n        _transferTokenIn(i_.dexKey.token1, i_.token1Amount);\n\n        (v_.token0NumeratorPrecision, v_.token0DenominatorPrecision) = _calculateNumeratorAndDenominatorPrecisions(v_.token0Decimals);\n        (v_.token1NumeratorPrecision, v_.token1DenominatorPrecision) = _calculateNumeratorAndDenominatorPrecisions(v_.token1Decimals);\n\n        _dexVariables[v_.dexId] = \n            (i_.fee << DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) |\n            (i_.revenueCut << DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) |\n            ((i_.rebalancingStatus ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) |\n            (BM.toBigNumber(i_.centerPrice, BIG_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_DOWN) << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) |\n            (i_.centerPriceContract << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) |\n            (i_.upperPercent << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) |\n            (i_.lowerPercent << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) |\n            (i_.upperShiftThreshold << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) |\n            (i_.lowerShiftThreshold << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) |\n            (v_.token0Decimals << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) |\n            (v_.token1Decimals << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) |\n            (((i_.token0Amount * v_.token0NumeratorPrecision) / v_.token0DenominatorPrecision) << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) |\n            (((i_.token1Amount * v_.token1NumeratorPrecision) / v_.token1DenominatorPrecision) << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        _centerPriceShift[v_.dexId] = \n            (block.timestamp << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) |\n            (i_.shiftTime << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) |\n            (BM.toBigNumber(i_.maxCenterPrice, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_UP) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) |\n            (BM.toBigNumber(i_.minCenterPrice, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_DOWN) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE);\n        \n        _dexesList.push(i_.dexKey);\n        \n        emit LogInitialize(i_.dexKey, v_.dexId, _dexVariables[v_.dexId], _centerPriceShift[v_.dexId], i_);\n    }\n\n    /// @dev update the fee and revenue cut for the dex\n    /// @param dexKey_ the dex key\n    /// @param fee_ in 4 decimals, 10000 = 1%\n    /// @param revenueCut_ in 4 decimals, 10000 = 1%\n    function updateFeeAndRevenueCut(DexKey calldata dexKey_, uint256 fee_, uint256 revenueCut_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        // cut is an integer in storage slot which is more than enough\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\n        if (revenueCut_ != 0 && revenueCut_ < FOUR_DECIMALS) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert InvalidRevenueCut(revenueCut_);\n        }\n\n        revenueCut_ = revenueCut_ / FOUR_DECIMALS;\n\n        if (fee_ > X13 || revenueCut_ > TWO_DECIMALS) {\n            revert InvalidParams();\n        }\n\n        _dexVariables[dexId_] = (dexVariables_ & ~(X20 << DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE)) | \n            (fee_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) |\n            (revenueCut_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT);\n\n        emit LogUpdateFeeAndRevenueCut(dexKey_, dexId_, _dexVariables[dexId_], fee_, revenueCut_ * FOUR_DECIMALS);\n    }\n\n    /// @dev update the rebalancing status for the dex\n    /// @param dexKey_ the dex key\n    /// @param rebalancingStatus_ the rebalancing status (true = on, false = off)\n    function updateRebalancingStatus(DexKey calldata dexKey_, bool rebalancingStatus_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n        \n        _dexVariables[dexId_] = (dexVariables_ & ~(X2 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS)) |\n            (rebalancingStatus_ ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS;\n\n        emit LogUpdateRebalancingStatus(dexKey_, dexId_, _dexVariables[dexId_], rebalancingStatus_);\n    }\n\n    /// @dev update the range percents for the dex\n    /// @param dexKey_ the dex key\n    /// @param upperPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerPercent_ in 4 decimals, 10000 = 1%\n    /// @param shiftTime_ in secs, in how much time the upper percent configs change should be fully done\n    function updateRangePercents(\n        DexKey calldata dexKey_,\n        uint256 upperPercent_,\n        uint256 lowerPercent_,\n        uint256 shiftTime_\n    ) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        upperPercent_ = upperPercent_ / TWO_DECIMALS;\n        lowerPercent_ = lowerPercent_ / TWO_DECIMALS;\n\n        if (\n            (upperPercent_ > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (lowerPercent_ > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (upperPercent_ == 0) ||\n            (lowerPercent_ == 0) ||\n            (shiftTime_ > X20) ||\n            (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) & X1) == 1) // if last shift is still active then don't allow a newer shift\n        ) {\n            revert InvalidParams();\n        }\n\n        _dexVariables[dexId_] = (dexVariables_ & ~(X28 << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT)) |\n            ((shiftTime_ > 0 ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) |\n            (upperPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) |\n            (lowerPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT);\n\n        uint256 oldUpperPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14;\n        uint256 oldLowerPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14;\n\n        if (shiftTime_ > 0) {\n            _rangeShift[dexId_] = \n                (oldUpperPercent_ << DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT) | \n                (oldLowerPercent_ << DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT) | \n                (shiftTime_ << DSL.BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT) | \n                (block.timestamp << DSL.BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP);\n        }\n        // Note _rangeShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\n\n        emit LogUpdateRangePercents(dexKey_, dexId_, _dexVariables[dexId_], _rangeShift[dexId_], upperPercent_ * TWO_DECIMALS, lowerPercent_ * TWO_DECIMALS, shiftTime_);\n    }\n\n    /// @dev update the shift time for the dex for rebalancing\n    /// @param dexKey_ the dex key\n    /// @param shiftTime_ in secs, in how much time rebalancing should be fully done.\n    function updateShiftTime(DexKey calldata dexKey_, uint256 shiftTime_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n        \n        if (shiftTime_ == 0 || shiftTime_ > X24) {\n            revert InvalidParams();\n        }\n\n        _centerPriceShift[dexId_] = (_centerPriceShift[dexId_] & ~(X24 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME)) | \n            (shiftTime_ << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME);\n\n        emit LogUpdateShiftTime(dexKey_, dexId_, _centerPriceShift[dexId_], shiftTime_);\n    }\n\n    /// @dev update the center price limits for the dex\n    /// @param dexKey_ the dex key\n    /// @param maxCenterPrice_ 1:1 means 1e27 \n    /// @param minCenterPrice_ 1:1 means 1e27\n    function updateCenterPriceLimits(DexKey calldata dexKey_, uint256 maxCenterPrice_, uint256 minCenterPrice_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        uint256 centerPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n\n        if (\n            (maxCenterPrice_ <= minCenterPrice_) ||\n            (centerPrice_ <= minCenterPrice_) ||\n            (centerPrice_ >= maxCenterPrice_) ||\n            (minCenterPrice_ == 0)\n        ) {\n            revert InvalidParams();\n        }\n\n        _centerPriceShift[dexId_] = (_centerPriceShift[dexId_] & ~(X56 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE)) | \n            (BM.toBigNumber(maxCenterPrice_, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_UP) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) |\n            (BM.toBigNumber(minCenterPrice_, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_DOWN) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE);\n\n        emit LogUpdateCenterPriceLimits(dexKey_, dexId_, _centerPriceShift[dexId_], maxCenterPrice_, minCenterPrice_);\n    }\n\n    /// @dev update the threshold percent for the dex\n    /// @param dexKey_ the dex key\n    /// @param upperThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param shiftTime_ in secs, in how much time the upper config changes should be fully done.\n    function updateThresholdPercent(\n        DexKey calldata dexKey_,\n        uint256 upperThresholdPercent_,\n        uint256 lowerThresholdPercent_,\n        uint256 shiftTime_\n    ) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        // thresholds are with 1% precision, hence removing last 4 decimals.\n        // we are allowing to send in 4 decimals to maintain consistency with other params\n        upperThresholdPercent_ = upperThresholdPercent_ / FOUR_DECIMALS;\n        lowerThresholdPercent_ = lowerThresholdPercent_ / FOUR_DECIMALS;\n        if (\n            (upperThresholdPercent_ > TWO_DECIMALS) ||\n            (lowerThresholdPercent_ > TWO_DECIMALS) ||\n            ((upperThresholdPercent_ == 0) && (lowerThresholdPercent_ > 0)) ||\n            ((upperThresholdPercent_ > 0) && (lowerThresholdPercent_ == 0)) ||\n            (shiftTime_ > X20) ||\n            (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) & X1) == 1) // if last shift is still active then don't allow a newer shift\n        ) {\n            revert InvalidParams();\n        }\n\n        _dexVariables[dexId_] =\n            (dexVariables_ & ~(X14 << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT)) |\n            ((shiftTime_ > 0 ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) |\n            (upperThresholdPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) |\n            (lowerThresholdPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT);\n\n        uint oldUpperThresholdPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) & X7;\n        uint oldLowerThresholdPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) & X7;\n\n        if (shiftTime_ > 0) {\n            _thresholdShift[dexId_] = \n                (oldUpperThresholdPercent_ << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT) |\n                (oldLowerThresholdPercent_ << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT) |\n                (shiftTime_ << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT) |\n                (block.timestamp << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP);\n        }\n        // Note _thresholdShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\n\n        emit LogUpdateThresholdPercent(dexKey_, dexId_, _dexVariables[dexId_], _thresholdShift[dexId_], upperThresholdPercent_ * FOUR_DECIMALS, lowerThresholdPercent_ * FOUR_DECIMALS, shiftTime_);\n    }\n\n    /// @dev update the center price address (nonce) for the dex\n    /// @param dexKey_ the dex key\n    /// @param centerPriceAddress_ nonce < X19, this nonce will be used to calculate contract address\n    /// @param percent_ in 4 decimals, 10000 = 1%\n    /// @param time_ in secs, in how much time the center price should be fully shifted.\n    function updateCenterPriceAddress(\n        DexKey calldata dexKey_,\n        uint256 centerPriceAddress_,\n        uint256 percent_,\n        uint256 time_\n    ) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        if ((centerPriceAddress_ > X19) || (percent_ == 0) || (percent_ > X20) || (time_ == 0) || (time_ > X20)) {\n            revert InvalidParams();\n        }\n\n        if (centerPriceAddress_ > 0) {\n            address centerPrice_ = AC.addressCalc(DEPLOYER_CONTRACT, centerPriceAddress_);\n            _checkIsContract(centerPrice_);\n            // note: if address is made 0 then as well in the last swap currentPrice is updated on storage, so code will start using that automatically\n            _dexVariables[dexId_] =\n                (dexVariables_ & ~(X19 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS)) |\n                (centerPriceAddress_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) |\n                (uint256(1) << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n\n            _centerPriceShift[dexId_] = (_centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT)) |\n                (percent_ << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT) |\n                (time_ << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT) |\n                (block.timestamp << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP);\n        } else {\n            _dexVariables[dexId_] = (_dexVariables[dexId_] & ~(X19 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS));\n\n            _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n        }\n\n        emit LogUpdateCenterPriceAddress(dexKey_, dexId_, _dexVariables[dexId_], _centerPriceShift[dexId_], centerPriceAddress_, percent_, time_);\n    }\n\n    /// @dev deposit tokens into the dex\n    /// @param dexKey_ the dex key\n    /// @param token0Amount_ the token0 amount\n    /// @param token1Amount_ the token1 amount\n    function deposit(DexKey calldata dexKey_, uint256 token0Amount_, uint256 token1Amount_, uint256 priceMax_, uint256 priceMin_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        _transferTokenIn(dexKey_.token0, token0Amount_);\n        _transferTokenIn(dexKey_.token1, token1Amount_);\n\n        uint256 token0Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5;\n        if (token0Decimals_ > TOKENS_DECIMALS_PRECISION) token0Amount_ /= 10 ** (token0Decimals_ - TOKENS_DECIMALS_PRECISION);\n        else token0Amount_ *= 10 ** (TOKENS_DECIMALS_PRECISION - token0Decimals_);\n\n        uint256 token1Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5;\n        if (token1Decimals_ > TOKENS_DECIMALS_PRECISION) token1Amount_ /= 10 ** (token1Decimals_ - TOKENS_DECIMALS_PRECISION);\n        else token1Amount_ *= 10 ** (TOKENS_DECIMALS_PRECISION - token1Decimals_);\n\n        uint256 token0TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60) + token0Amount_;\n        uint256 token1TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60) + token1Amount_;\n\n        dexVariables_ = (dexVariables_ & ~(X120 << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED)) |\n            (token0TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) |\n            (token1TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        _dexVariables[dexId_] = dexVariables_;\n        \n        uint256 price_ = _getPrice(dexKey_, dexVariables_, dexId_, token0TotalSupply_, token1TotalSupply_);\n\n        if (price_ > priceMax_ || price_ < priceMin_) revert SlippageLimitExceeded(price_, priceMax_, priceMin_);\n\n        emit LogDeposit(dexKey_, dexId_, dexVariables_, token0Amount_, token1Amount_);\n    }\n\n    /// @dev withdraw tokens from the dex\n    /// @param dexKey_ the dex key\n    /// @param token0Amount_ the token0 amount\n    /// @param token1Amount_ the token1 amount\n    /// @param to_ the address to send the tokens to\n    function withdraw(DexKey calldata dexKey_, uint256 token0Amount_, uint256 token1Amount_, address to_, uint256 priceMax_, uint256 priceMin_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        _transferTokenOut(dexKey_.token0, token0Amount_, to_);\n        _transferTokenOut(dexKey_.token1, token1Amount_, to_);\n\n        uint256 token0Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5;\n        if (token0Decimals_ > TOKENS_DECIMALS_PRECISION) token0Amount_ /= 10 ** (token0Decimals_ - TOKENS_DECIMALS_PRECISION);\n        else token0Amount_ *= 10 ** (TOKENS_DECIMALS_PRECISION - token0Decimals_);\n\n        uint256 token1Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5;\n        if (token1Decimals_ > TOKENS_DECIMALS_PRECISION) token1Amount_ /= 10 ** (token1Decimals_ - TOKENS_DECIMALS_PRECISION);\n        else token1Amount_ *= 10 ** (TOKENS_DECIMALS_PRECISION - token1Decimals_);\n\n        uint256 token0TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60) - token0Amount_;\n        uint256 token1TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60) - token1Amount_;\n\n        dexVariables_ = (dexVariables_ & ~(X120 << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED)) |\n            (token0TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) |\n            (token1TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n        \n        _dexVariables[dexId_] = dexVariables_;\n\n        uint256 price_ = _getPrice(dexKey_, dexVariables_, dexId_, token0TotalSupply_, token1TotalSupply_);\n        if (price_ > priceMax_ || price_ < priceMin_) revert SlippageLimitExceeded(price_, priceMax_, priceMin_);\n\n        emit LogWithdraw(dexKey_, dexId_, dexVariables_, token0Amount_, token1Amount_);\n    }\n\n    /// @dev update the extra data address in storage slot\n    /// @param extraDataAddress_ the address to set in the extra data slot\n    function updateExtraDataAddress(address extraDataAddress_) public _onlyDelegateCall {\n        assembly {\n            sstore(EXTRA_DATA_SLOT, extraDataAddress_)\n        }\n\n        emit LogUpdateExtraDataAddress(extraDataAddress_);\n    }\n\n    /// @dev collect revenue from the dex\n    /// @param tokens_ the tokens to collect revenue from\n    /// @param amounts_ the amounts of tokens to collect revenue from\n    /// @param to_ the address to send the tokens to\n    function collectRevenue(address[] calldata tokens_, uint256[] calldata amounts_, address to_) public _onlyDelegateCall {\n        for (uint256 i = 0; i < tokens_.length; ) {\n            _transferTokenOut(tokens_[i], amounts_[i], to_);\n            unchecked {++i;}\n        }\n\n        emit LogCollectRevenue(tokens_, amounts_, to_);\n    }\n}\n\n"
    },
    "contracts/protocols/dexLite/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"../other/commonImport.sol\";\n\nstruct InitializeParams {\n    DexKey dexKey;\n    uint256 fee;\n    uint256 revenueCut;\n    bool rebalancingStatus;\n    uint256 centerPrice;\n    uint256 centerPriceContract; // nonce\n    uint256 upperPercent;\n    uint256 lowerPercent;\n    uint256 upperShiftThreshold;\n    uint256 lowerShiftThreshold;\n    uint256 shiftTime; // in seconds // for rebalancing\n    uint256 minCenterPrice;\n    uint256 maxCenterPrice;\n    uint256 token0Amount;\n    uint256 token1Amount;\n}\n\nstruct InitializeVariables {\n    bytes8 dexId;\n    uint256 token0Decimals;\n    uint256 token1Decimals;\n    uint256 token0NumeratorPrecision;\n    uint256 token0DenominatorPrecision;\n    uint256 token1NumeratorPrecision;\n    uint256 token1DenominatorPrecision;\n}"
    },
    "contracts/protocols/dexLite/core/coreInternals.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./helpers.sol\";\n\nabstract contract CoreInternals is Helpers {\n    function _swapIn(\n        DexKey calldata dexKey_,\n        bool swap0To1_,\n        uint256 amountIn_\n    ) internal returns (uint256 amountOut_) {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        uint256 token0AdjustedSupply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60;\n        uint256 token1AdjustedSupply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60;\n        (uint256 centerPrice_, uint256 token0ImaginaryReserves_, uint256 token1ImaginaryReserves_) = \n            _getPricesAndReserves(dexKey_, dexVariables_, dexId_, token0AdjustedSupply_, token1AdjustedSupply_);\n\n        unchecked {\n            if (swap0To1_) {\n                uint256 token0Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5;\n                if (token0Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                    amountIn_ /= _tenPow(token0Decimals_ - TOKENS_DECIMALS_PRECISION);\n                } else {\n                    amountIn_ *= _tenPow(TOKENS_DECIMALS_PRECISION - token0Decimals_);\n                }\n\n                if (amountIn_ < FOUR_DECIMALS || amountIn_ > X60) {\n                    revert InvalidSwapAmounts(amountIn_);\n                }\n                if (amountIn_ > (token0ImaginaryReserves_ / 2)) {\n                    revert ExcessiveSwapAmount(amountIn_, token0ImaginaryReserves_);\n                }\n\n                uint256 fee_ = (amountIn_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) & X13)) / SIX_DECIMALS;\n                // amountOut = (amountIn * iReserveOut) / (iReserveIn + amountIn)\n                amountOut_ = ((amountIn_ - fee_) * token1ImaginaryReserves_) / (token0ImaginaryReserves_ + (amountIn_ - fee_));\n                token0AdjustedSupply_ += amountIn_ - ((fee_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) & X7)) / TWO_DECIMALS);\n\n                if (token1AdjustedSupply_ < amountOut_) {\n                    revert TokenReservesTooLow(amountOut_, token1AdjustedSupply_);\n                }\n                token1AdjustedSupply_ -= amountOut_;\n\n                if (((token1AdjustedSupply_) < ((token0AdjustedSupply_ * centerPrice_) / (PRICE_PRECISION * MINIMUM_LIQUIDITY_SWAP)))) {\n                    revert TokenReservesRatioTooHigh(token0AdjustedSupply_, token1AdjustedSupply_);\n                }\n            } else {\n                uint256 token1Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5;\n                if (token1Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                    amountIn_ /= _tenPow(token1Decimals_ - TOKENS_DECIMALS_PRECISION);\n                } else {\n                    amountIn_ *= _tenPow(TOKENS_DECIMALS_PRECISION - token1Decimals_);\n                }\n\n                if (amountIn_ < FOUR_DECIMALS || amountIn_ > X60) {\n                    revert InvalidSwapAmounts(amountIn_);\n                }\n                if (amountIn_ > (token1ImaginaryReserves_ / 2)) {\n                    revert ExcessiveSwapAmount(amountIn_, token1ImaginaryReserves_);\n                }\n\n                uint256 fee_ = (amountIn_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) & X13)) / SIX_DECIMALS;\n                // amountOut = (amountIn * iReserveOut) / (iReserveIn + amountIn)\n                amountOut_ = ((amountIn_ - fee_) * token0ImaginaryReserves_) / (token1ImaginaryReserves_ + (amountIn_ - fee_));\n                token1AdjustedSupply_ += amountIn_ - ((fee_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) & X7)) / TWO_DECIMALS);\n\n                if (token0AdjustedSupply_ < amountOut_) {\n                    revert TokenReservesTooLow(amountOut_, token0AdjustedSupply_);\n                }\n                token0AdjustedSupply_ -= amountOut_;\n\n                if (((token0AdjustedSupply_) < ((token1AdjustedSupply_ * PRICE_PRECISION) / (centerPrice_ * MINIMUM_LIQUIDITY_SWAP)))) {\n                    revert TokenReservesRatioTooHigh(token0AdjustedSupply_, token1AdjustedSupply_);\n                }\n            }\n        }\n\n        {\n            uint256 rebalancingStatus_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) & X2;\n            if (rebalancingStatus_ > 0) {\n                // rebalancing is active\n                uint256 price_;\n                unchecked {\n                    price_ = (swap0To1_ ? (token1ImaginaryReserves_ - amountOut_) * PRICE_PRECISION / (token0ImaginaryReserves_ + amountIn_) : \n                        (token1ImaginaryReserves_ + amountIn_) * PRICE_PRECISION / (token0ImaginaryReserves_ - amountOut_));\n                }\n                rebalancingStatus_ = _getRebalancingStatus(dexVariables_, dexId_, rebalancingStatus_, price_, centerPrice_);\n            }\n            // NOTE: we are using dexVariables_ and not _dexVariables[dexId_] here to check if the center price shift is active\n            // _dexVariables[dexId_] might have become inactive in this transaction above, but still we are storing the timestamp for this transaction\n            // storing the timestamp is not important, but we are still doing it because we don't want to use _dexVariables[dexId_] here because of gas\n            if (rebalancingStatus_ > 1 || ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE) & X1) == 1) {\n                _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X33 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) | \n                    (block.timestamp << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP);\n            }\n        }\n\n        if (token0AdjustedSupply_ > X60 || token1AdjustedSupply_ > X60) {\n            revert AdjustedSupplyOverflow(dexId_, token0AdjustedSupply_, token1AdjustedSupply_);\n        }\n\n        dexVariables_ = _dexVariables[dexId_] & ~(X120 << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) | \n            (token0AdjustedSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) | \n            (token1AdjustedSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        _dexVariables[dexId_] = dexVariables_;\n\n        if (swap0To1_) {\n            emit LogSwap(\n                (uint256(uint64(dexId_)) << DSL.BITS_DEX_LITE_SWAP_DATA_DEX_ID) | \n                (uint256(1) << DSL.BITS_DEX_LITE_SWAP_DATA_SWAP_0_TO_1) | // swap 0 to 1 bit is 1\n                (amountIn_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN) | \n                (amountOut_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT), \n                dexVariables_\n            );\n\n            uint256 token1Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5;\n            if (token1Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                amountOut_ *= _tenPow(token1Decimals_ - TOKENS_DECIMALS_PRECISION);\n            } else {\n                amountOut_ /= _tenPow(TOKENS_DECIMALS_PRECISION - token1Decimals_);\n            }\n\n        } else {\n            emit LogSwap(\n                (uint256(uint64(dexId_)) << DSL.BITS_DEX_LITE_SWAP_DATA_DEX_ID) | \n                // swap 0 to 1 bit is 0\n                (amountIn_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN) | \n                (amountOut_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT), \n                dexVariables_\n            );\n\n            uint256 token0Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5;\n            if (token0Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                amountOut_ *= _tenPow(token0Decimals_ - TOKENS_DECIMALS_PRECISION);\n            } else {\n                amountOut_ /= _tenPow(TOKENS_DECIMALS_PRECISION - token0Decimals_);\n            }\n        }\n    }\n\n    function _swapOut(\n        DexKey calldata dexKey_,\n        bool swap0To1_,\n        uint256 amountOut_\n    ) internal returns (uint256 amountIn_) {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n    \n        uint256 token0AdjustedSupply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60;\n        uint256 token1AdjustedSupply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60;\n        (uint256 centerPrice_, uint256 token0ImaginaryReserves_, uint256 token1ImaginaryReserves_) = \n            _getPricesAndReserves(dexKey_, dexVariables_, dexId_, token0AdjustedSupply_, token1AdjustedSupply_);\n\n        unchecked {\n            if (swap0To1_) {\n                uint256 token1Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5;\n                if (token1Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                    amountOut_ /= _tenPow(token1Decimals_ - TOKENS_DECIMALS_PRECISION);\n                } else {\n                    amountOut_ *= _tenPow(TOKENS_DECIMALS_PRECISION - token1Decimals_);\n                }\n\n                if (amountOut_ < FOUR_DECIMALS || amountOut_ > X60) {\n                    revert InvalidSwapAmounts(amountOut_);\n                }\n                if (amountOut_ > (token1ImaginaryReserves_ / 2)) {\n                    revert ExcessiveSwapAmount(amountOut_, token1ImaginaryReserves_);\n                }\n\n                // amountIn = (amountOut * iReserveIn) / (iReserveOut - amountOut)\n                amountIn_ = (amountOut_ * token0ImaginaryReserves_) / (token1ImaginaryReserves_ - amountOut_);\n                uint256 fee_ = ((amountIn_ * SIX_DECIMALS) / (SIX_DECIMALS - ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) & X13))) - amountIn_;\n                amountIn_ += fee_;\n                token0AdjustedSupply_ += amountIn_ - ((fee_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) & X7)) / TWO_DECIMALS);\n\n                if (token1AdjustedSupply_ < amountOut_) {\n                    revert TokenReservesTooLow(amountOut_, token1AdjustedSupply_);\n                }\n                token1AdjustedSupply_ -= amountOut_;\n\n                if (((token1AdjustedSupply_) < ((token0AdjustedSupply_ * centerPrice_) / (PRICE_PRECISION * MINIMUM_LIQUIDITY_SWAP)))) {\n                    revert TokenReservesRatioTooHigh(token0AdjustedSupply_, token1AdjustedSupply_);\n                }\n            } else {\n                uint256 token0Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5;\n                if (token0Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                    amountOut_ /= _tenPow(token0Decimals_ - TOKENS_DECIMALS_PRECISION);\n                } else {\n                    amountOut_ *= _tenPow(TOKENS_DECIMALS_PRECISION - token0Decimals_);\n                }\n                \n                if (amountOut_ < FOUR_DECIMALS || amountOut_ > X60) {\n                    revert InvalidSwapAmounts(amountOut_);\n                }\n                if (amountOut_ > (token0ImaginaryReserves_ / 2)) {\n                    revert ExcessiveSwapAmount(amountOut_, token0ImaginaryReserves_);\n                }\n\n                // amountIn = (amountOut * iReserveIn) / (iReserveOut - amountOut)\n                amountIn_ = (amountOut_ * token1ImaginaryReserves_) / (token0ImaginaryReserves_ - amountOut_);\n                uint256 fee_ = ((amountIn_ * SIX_DECIMALS) / (SIX_DECIMALS - ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) & X13))) - amountIn_;\n                amountIn_ += fee_;\n                token1AdjustedSupply_ += amountIn_ - ((fee_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) & X7)) / TWO_DECIMALS);\n\n                if (token0AdjustedSupply_ < amountOut_) {\n                    revert TokenReservesTooLow(amountOut_, token0AdjustedSupply_);\n                }\n                token0AdjustedSupply_ -= amountOut_;\n\n                if (((token0AdjustedSupply_) < ((token1AdjustedSupply_ * PRICE_PRECISION) / (centerPrice_ * MINIMUM_LIQUIDITY_SWAP)))) {\n                    revert TokenReservesRatioTooHigh(token0AdjustedSupply_, token1AdjustedSupply_);\n                }\n            }\n        }\n\n        {\n            uint256 rebalancingStatus_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) & X2;\n            if (rebalancingStatus_ > 0) {\n                // rebalancing is active\n                uint256 price_;\n                unchecked {\n                    price_ = (swap0To1_ ? (token1ImaginaryReserves_ - amountOut_) * PRICE_PRECISION / (token0ImaginaryReserves_ + amountIn_) : \n                        (token1ImaginaryReserves_ + amountIn_) * PRICE_PRECISION / (token0ImaginaryReserves_ - amountOut_));\n                }\n                rebalancingStatus_ = _getRebalancingStatus(dexVariables_, dexId_, rebalancingStatus_, price_, centerPrice_);\n            }\n            if (rebalancingStatus_ > 1 || ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE) & X1) == 1) {\n                _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X33 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) | \n                    (block.timestamp << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP);\n            }\n        }\n\n        if (token0AdjustedSupply_ > X60 || token1AdjustedSupply_ > X60) {\n            revert AdjustedSupplyOverflow(dexId_, token0AdjustedSupply_, token1AdjustedSupply_);\n        }\n\n        dexVariables_ = _dexVariables[dexId_] & ~(X120 << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) | \n            (token0AdjustedSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) | \n            (token1AdjustedSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        _dexVariables[dexId_] = dexVariables_;\n\n        if (swap0To1_) {\n            emit LogSwap(\n                (uint256(uint64(dexId_)) << DSL.BITS_DEX_LITE_SWAP_DATA_DEX_ID) | \n                (uint256(1) << DSL.BITS_DEX_LITE_SWAP_DATA_SWAP_0_TO_1) | // swap 0 to 1 bit is 1\n                (amountIn_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN) | \n                (amountOut_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT), \n                dexVariables_\n            );\n\n            uint256 token0Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5;\n            if (token0Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                amountIn_ *= _tenPow(token0Decimals_ - TOKENS_DECIMALS_PRECISION);\n            } else {\n                amountIn_ /= _tenPow(TOKENS_DECIMALS_PRECISION - token0Decimals_);\n            }\n        } else {\n            emit LogSwap(\n                (uint256(uint64(dexId_)) << DSL.BITS_DEX_LITE_SWAP_DATA_DEX_ID) | \n                // swap 0 to 1 bit is 0\n                (amountIn_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN) | \n                (amountOut_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT), \n                dexVariables_\n            );\n\n            uint256 token1Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5;\n            if (token1Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                amountIn_ *= _tenPow(token1Decimals_ - TOKENS_DECIMALS_PRECISION);\n            } else {\n                amountIn_ /= _tenPow(TOKENS_DECIMALS_PRECISION - token1Decimals_);\n            }\n        }\n    }\n}\n"
    },
    "contracts/protocols/dexLite/core/errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport \"../other/commonImport.sol\";\n\n// --- Custom Errors ---\nerror EstimateSwap(uint256 amountUnspecified);\nerror AmountLimitExceeded(uint256 amountUnspecified, uint256 amountLimit);\nerror AmountLimitNotMet(uint256 amountUnspecified, uint256 amountLimit);\nerror EmptyDexKeysArray();\nerror InvalidPathLength(uint256 pathLength, uint256 dexKeysLength);\nerror InvalidAmountLimitsLength(uint256 dexKeysLength, uint256 amountLimitsLength);\nerror InvalidPathTokenOrder();\nerror UnauthorizedCaller(address caller);\nerror DexNotInitialized(bytes32 dexId);\nerror AdjustedSupplyOverflow(bytes32 dexId, uint256 token0AdjustedSupply, uint256 token1AdjustedSupply);\nerror ZeroAddress();\nerror InvalidPower(uint256 power);\nerror InvalidSwapAmounts(uint256 adjustedAmount);\nerror ExcessiveSwapAmount(uint256 adjustedAmount, uint256 imaginaryReserve);\nerror TokenReservesTooLow(uint256 adjustedAmount, uint256 realReserve);\nerror TokenReservesRatioTooHigh(uint256 token0RealReserve, uint256 token1RealReserve);\nerror InvalidMsgValue();\nerror InsufficientNativeTokenReceived(uint256 receivedAmount, uint256 requiredAmount);\nerror InsufficientERC20Received(uint256 receivedAmount, uint256 requiredAmount);\nerror DelegateCallFailed();"
    },
    "contracts/protocols/dexLite/core/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport \"./errors.sol\";\nimport { DexLiteSlotsLink as DSL } from \"../../../libraries/dexLiteSlotsLink.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\nimport { ReentrancyLock } from \"../../../libraries/reentrancyLock.sol\";\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\n\nabstract contract Helpers is CommonImport {\n    using BigMathMinified for uint256;\n\n    modifier _reentrancyLock() {\n        ReentrancyLock.lock();\n        _;\n        ReentrancyLock.unlock();\n    }\n\n    function _getExtraDataSlot() internal view returns (address extraDataAddress_) {\n        assembly {\n            extraDataAddress_ := sload(EXTRA_DATA_SLOT)\n        }\n    }\n\n    function _getGovernanceAddr() internal view returns (address governance_) {\n        governance_ = address(uint160(LIQUIDITY.readFromStorage(LIQUIDITY_GOVERNANCE_SLOT)));\n    }\n\n    function _callExtraDataSlot(bytes memory data_) internal {\n        address extraDataAddress_ = _getExtraDataSlot();\n        if (extraDataAddress_ == address(0)) {\n            revert ZeroAddress();\n        }\n        _spell(extraDataAddress_, data_);\n    }\n\n    function _tenPow(uint256 power_) internal pure returns (uint256) {\n        // keeping the most used powers at the top for better gas optimization\n        if (power_ == 3) {\n            return 1_000; // used for 6 or 12 decimals (USDC, USDT)\n        }\n        if (power_ == 9) {\n            return 1_000_000_000; // used for 18 decimals (ETH, and many more)\n        }\n        if (power_ == 1) {\n            return 10; // used for 1 decimals (WBTC and more)\n        }\n\n        if (power_ == 0) {\n            return 1;\n        }\n        if (power_ == 2) {\n            return 100;\n        }\n        if (power_ == 4) {\n            return 10_000;\n        }\n        if (power_ == 5) {\n            return 100_000;\n        }\n        if (power_ == 6) {\n            return 1_000_000;\n        }\n        if (power_ == 7) {\n            return 10_000_000;\n        }\n        if (power_ == 8) {\n            return 100_000_000;\n        }\n\n        // We will only need powers from 0 to 9 as token decimals can only be 6 to 18\n        revert InvalidPower(power_);\n    }\n\n    /// @dev getting reserves outside range.\n    /// @param gp_ is geometric mean pricing of upper percent & lower percent\n    /// @param pa_ price of upper range or lower range\n    /// @param rx_ real reserves of token0 or token1\n    /// @param ry_ whatever is rx_ the other will be ry_\n    function _calculateReservesOutsideRange(uint256 gp_, uint256 pa_, uint256 rx_, uint256 ry_) internal pure returns (uint256 xa_, uint256 yb_) {\n        // equations we have:\n        // 1. x*y = k\n        // 2. xa*ya = k\n        // 3. xb*yb = k\n        // 4. Pa = ya / xa = upperRange_ (known)\n        // 5. Pb = yb / xb = lowerRange_ (known)\n        // 6. x - xa = rx = real reserve of x (known)\n        // 7. y - yb = ry = real reserve of y (known)\n        // With solving we get:\n        // ((Pa*Pb)^(1/2) - Pa)*xa^2 + (rx * (Pa*Pb)^(1/2) + ry)*xa + rx*ry = 0\n        // yb = yb = xa * (Pa * Pb)^(1/2)\n\n        // xa = (GP⋅rx + ry + (-rx⋅ry⋅4⋅(GP - Pa) + (GP⋅rx + ry)^2)^0.5) / (2Pa - 2GP)\n        // multiply entire equation by 1e27 to remove the price decimals precision of 1e27\n        // xa = (GP⋅rx + ry⋅1e27 + (rx⋅ry⋅4⋅(Pa - GP)⋅1e27 + (GP⋅rx + ry⋅1e27)^2)^0.5) / 2*(Pa - GP)\n        // dividing the equation with 2*(Pa - GP). Pa is always > GP so answer will be positive.\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅4⋅(Pa - GP)⋅1e27) / 4*(Pa - GP)^2) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅1e27) / (Pa - GP)) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n\n        // dividing in 3 parts for simplification:\n        // part1 = (Pa - GP)\n        // part2 = (GP⋅rx + ry⋅1e27) / (2*part1)\n        // part3 = rx⋅ry\n        // note: part1 will almost always be < 1e28 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e29\n        unchecked {\n            uint256 p1_ = pa_ - gp_;\n            uint256 p2_ = ((gp_ * rx_) + (ry_ * PRICE_PRECISION)) / (2 * p1_);\n\n            // removed <1e50 check becuase rx_ * ry_ will never be greater than 1e50\n            // Directly used p3_ below instead of using a variable for it\n            // uint256 p3_ = (rx_ * ry_ * PRICE_PRECISION) / p1_;\n\n            // xa = part2 + (part3 + (part2 * part2))^(1/2)\n            // yb = xa_ * gp_\n            xa_ = p2_ + FixedPointMathLib.sqrt((((rx_ * ry_ * PRICE_PRECISION) / p1_) + (p2_ * p2_)));\n            yb_ = (xa_ * gp_) / PRICE_PRECISION;\n        }\n    }\n    \n\n    /// @dev This function calculates the new value of a parameter after a shifting process\n    /// @param current_ The current value is the final value where the shift ends\n    /// @param old_ The old value from where shifting started\n    /// @param timePassed_ The time passed since shifting started\n    /// @param shiftDuration_ The total duration of the shift when old_ reaches current_\n    /// @return The new value of the parameter after the shift\n    function _calcShiftingDone(uint256 current_, uint256 old_, uint256 timePassed_, uint256 shiftDuration_) internal pure returns (uint256) {\n        unchecked {\n            if (current_ > old_) {\n                return (old_ + (((current_ - old_) * timePassed_) / shiftDuration_));\n            } else {\n                return (old_ - (((old_ - current_) * timePassed_) / shiftDuration_));\n            }\n        }\n    }\n\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @notice This function handles the gradual shifting of range values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcRangeShifting(\n        uint256 upperRange_,\n        uint256 lowerRange_,\n        bytes8 dexId_\n    ) internal returns (uint256, uint256) {\n        uint256 rangeShift_ = _rangeShift[dexId_];\n        uint256 shiftDuration_ = (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT) & X20;\n        uint256 startTimeStamp_ = (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP) & X33;\n\n        uint256 timePassed_;\n        unchecked {\n            if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n                // shifting fully done\n                delete _rangeShift[dexId_];\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables only updates from this function and _calcThresholdShifting.\n                _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE);\n                return (upperRange_, lowerRange_);\n            }\n            timePassed_ = block.timestamp - startTimeStamp_;\n        }\n        return (\n            _calcShiftingDone(upperRange_, (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT) & X14, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerRange_, (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT) & X14, timePassed_, shiftDuration_)\n        );\n    }\n\n    /// @dev Calculates the new upper and lower threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @return The updated upper threshold, lower threshold\n    /// @notice This function handles the gradual shifting of threshold values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcThresholdShifting(\n        uint256 upperThreshold_,\n        uint256 lowerThreshold_,\n        bytes8 dexId_\n    ) internal returns (uint256, uint256) {\n        uint256 thresholdShift_ = _thresholdShift[dexId_];\n        uint256 shiftDuration_ = (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT) & X20;\n        uint256 startTimeStamp_ = (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP) & X33;\n\n        uint256 timePassed_;\n        unchecked {\n            if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n                // shifting fully done\n                delete _thresholdShift[dexId_];\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcRangeShifting.\n                _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE);\n                return (upperThreshold_, lowerThreshold_);\n            }\n            timePassed_ = block.timestamp - startTimeStamp_;\n        }\n        return (\n            _calcShiftingDone(upperThreshold_, (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT) & X7, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerThreshold_, (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT) & X7, timePassed_, shiftDuration_)\n        );\n    }\n\n    /// @dev Calculates the new center price during an active price shift\n    /// @param dexVariables_ The current state of dex variables\n    /// @return newCenterPrice_ The updated center price\n    /// @notice This function gradually shifts the center price towards a new target price over time\n    /// @notice It uses an external price source (via ICenterPrice) to determine the target price\n    /// @notice The shift continues until the current price reaches the target, or the shift duration ends\n    /// @notice Once the shift is complete, it updates the state and clears the shift data\n    /// @notice The shift rate is dynamic and depends on:\n    /// @notice - Time remaining in the shift duration\n    /// @notice - The new center price (fetched externally, which may change)\n    /// @notice - The current (old) center price\n    /// @notice This results in a fuzzy shifting mechanism where the rate can change as these parameters evolve\n    /// @notice The externally fetched new center price is expected to not differ significantly from the last externally fetched center price\n    function _calcCenterPrice(\n        DexKey calldata dexKey_,\n        uint256 dexVariables_,\n        bytes8 dexId_\n    ) internal returns (uint256 newCenterPrice_) {\n        uint256 oldCenterPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n        oldCenterPrice_ = (oldCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (oldCenterPrice_ & DEFAULT_EXPONENT_MASK);\n        uint256 centerPriceShift_ = _centerPriceShift[dexId_];\n        uint256 startTimeStamp_ = (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP) & X33;\n\n        uint256 fromTimeStamp_ = (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33;\n        fromTimeStamp_ = fromTimeStamp_ > startTimeStamp_ ? fromTimeStamp_ : startTimeStamp_;\n\n        newCenterPrice_ = ICenterPrice(\n            AddressCalcs.addressCalc(DEPLOYER_CONTRACT, ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) & X19)))\n            .centerPrice(dexKey_.token0, dexKey_.token1);\n        \n        unchecked {\n            uint256 priceShift_ = (oldCenterPrice_ * ((centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT) & X20) * (block.timestamp - fromTimeStamp_)) \n                                    / (((centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT) & X20) * SIX_DECIMALS);\n\n            if (newCenterPrice_ > oldCenterPrice_) {\n                // shift on positive side\n                oldCenterPrice_ += priceShift_;\n                if (newCenterPrice_ > oldCenterPrice_) {\n                    newCenterPrice_ = oldCenterPrice_;\n                } else {\n                    // shifting fully done\n                    _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n                    // making active shift as 0 because shift is over\n                    // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                    _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n                }\n            } else {\n                oldCenterPrice_ = oldCenterPrice_ > priceShift_ ? oldCenterPrice_ - priceShift_ : 0;\n                // In case of oldCenterPrice_ ending up 0, which could happen when a lot of time has passed (pool has no swaps for many days or weeks)\n                // then below we get into the else logic which will fully conclude shifting and return newCenterPrice_\n                // as it was fetched from the external center price source.\n                // not ideal that this would ever happen unless the pool is not in use and all/most users have left leaving not enough liquidity to trade on\n                if (newCenterPrice_ < oldCenterPrice_) {\n                    newCenterPrice_ = oldCenterPrice_;\n                } else {\n                    // shifting fully done\n                    _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n                    // making active shift as 0 because shift is over\n                    // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                    _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates and returns the current prices and exchange prices for the pool\n    /// @param dexVariables_ The first set of DEX variables containing various pool parameters\n    function _getPricesAndReserves(\n        DexKey calldata dexKey_,\n        uint256 dexVariables_,\n        bytes8 dexId_,\n        uint256 token0Supply_,\n        uint256 token1Supply_\n    ) internal returns (uint256 centerPrice_, uint256 token0ImaginaryReserves_, uint256 token1ImaginaryReserves_) {\n        // Fetch center price\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE) & X1) == 0) {\n            // centerPrice_ => center price nonce\n            centerPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) & X19;\n            if (centerPrice_ == 0) {\n                centerPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n                centerPrice_ = \n                    ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, centerPrice_)).centerPrice(dexKey_.token0, dexKey_.token1);\n            }\n        } else {\n            // an active centerPrice_ shift is going on\n            centerPrice_ = _calcCenterPrice(dexKey_, dexVariables_, dexId_);\n        }\n\n        uint256 upperRangePercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14;\n        uint256 lowerRangePercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14;\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) & X1) == 1) {\n            // an active range shift is going on\n            (upperRangePercent_, lowerRangePercent_) = _calcRangeShifting(upperRangePercent_, lowerRangePercent_, dexId_);\n        }\n\n        uint256 upperRangePrice_;\n        uint256 lowerRangePrice_;\n        unchecked {\n            // 1% = 1e2, 100% = 1e4\n            upperRangePrice_ = (centerPrice_ * FOUR_DECIMALS) / (FOUR_DECIMALS - upperRangePercent_);\n            // 1% = 1e2, 100% = 1e4\n            lowerRangePrice_ = (centerPrice_ * (FOUR_DECIMALS - lowerRangePercent_)) / FOUR_DECIMALS;\n        }\n\n        // Rebalance center price if rebalancing is on\n        // temp_ => rebalancingStatus_\n        uint256 temp_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) & X2;\n        uint256 temp2_;\n        if (temp_ > 1) {\n            unchecked {\n                // temp2_ => centerPriceShift_\n                if (temp_ == 2) {\n                    temp2_ = _centerPriceShift[dexId_];\n                    uint256 shiftingTime_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24;\n                    uint256 timeElapsed_ = block.timestamp - ((temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33);\n                    // price shifting towards upper range\n                    if (timeElapsed_ < shiftingTime_) {\n                        centerPrice_ = centerPrice_ + (((upperRangePrice_ - centerPrice_) * timeElapsed_) / shiftingTime_);\n                    } else {\n                        // 100% price shifted\n                        centerPrice_ = upperRangePrice_;\n                    }\n                } else if (temp_ == 3) {\n                    temp2_ = _centerPriceShift[dexId_];\n                    uint256 shiftingTime_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24;\n                    uint256 timeElapsed_ = block.timestamp - ((temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33);\n                    // price shifting towards lower range\n                    if (timeElapsed_ < shiftingTime_) {\n                        centerPrice_ = centerPrice_ - (((centerPrice_ - lowerRangePrice_) * timeElapsed_) / shiftingTime_);\n                    } else {\n                        // 100% price shifted\n                        centerPrice_ = lowerRangePrice_;\n                    }\n                }\n\n                // If rebalancing actually happened then make sure price is within min and max bounds, and update range prices\n                if (temp2_ > 0) {\n                    // Make sure center price is within min and max bounds\n                    // temp_ => max center price\n                    temp_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) & X28;\n                    temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n                    if (centerPrice_ > temp_) {\n                        // if center price is greater than max center price\n                        centerPrice_ = temp_;\n                    } else {\n                        // check if center price is less than min center price\n                        // temp_ => min center price\n                        temp_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE) & X28;\n                        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n                        if (centerPrice_ < temp_) centerPrice_ = temp_;\n                    }\n\n                    // Update range prices as center price moved\n                    upperRangePrice_ = (centerPrice_ * FOUR_DECIMALS) / (FOUR_DECIMALS - upperRangePercent_);\n                    lowerRangePrice_ = (centerPrice_ * (FOUR_DECIMALS - lowerRangePercent_)) / FOUR_DECIMALS;\n                }\n            }  \n        }\n\n        // temp_ => geometricMeanPrice_\n        unchecked {         \n            if (upperRangePrice_ < 1e38) {\n                // 1e38 * 1e38 = 1e76 which is less than max uint limit\n                temp_ = FixedPointMathLib.sqrt(upperRangePrice_ * lowerRangePrice_);\n            } else {\n                // upperRange_ price is pretty large hence lowerRange_ will also be pretty large\n                temp_ = FixedPointMathLib.sqrt((upperRangePrice_ / 1e18) * (lowerRangePrice_ / 1e18)) * 1e18;\n            }\n        }\n\n        if (temp_ < 1e27) {\n            (token0ImaginaryReserves_, token1ImaginaryReserves_) = \n                _calculateReservesOutsideRange(temp_, upperRangePrice_, token0Supply_, token1Supply_);\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            unchecked {\n                (token1ImaginaryReserves_, token0ImaginaryReserves_) = _calculateReservesOutsideRange(\n                    (1e54 / temp_),\n                    (1e54 / lowerRangePrice_),\n                    token1Supply_,\n                    token0Supply_\n                );\n            }\n        }\n\n        unchecked {\n            token0ImaginaryReserves_ += token0Supply_;\n            token1ImaginaryReserves_ += token1Supply_;\n        }\n    }\n\n    function _getRebalancingStatus(\n        uint256 dexVariables_, \n        bytes8 dexId_, \n        uint256 rebalancingStatus_, \n        uint256 price_, \n        uint256 centerPrice_\n    ) internal returns (uint256) {\n        uint256 upperRange_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14;\n        uint256 lowerRange_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14;\n\n        // NOTE: we are using dexVariables_ and not _dexVariables[dexId_] here to check if the range shift is active\n        // range shift might have already ended in this transaction above, but still calling _calcRangeShifting again because we don't want to use _dexVariables[dexId_] here because of gas\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) & X1) == 1) {\n            // an active range shift is going on\n            (upperRange_, lowerRange_) = _calcRangeShifting(upperRange_, lowerRange_, dexId_);\n        }\n\n        unchecked {\n            // adding into unchecked because upperRangePercent_ & lowerRangePercent_ can only be > 0 & < FOUR_DECIMALS\n            // 1% = 1e2, 100% = 1e4\n            upperRange_ = (centerPrice_ * FOUR_DECIMALS) / (FOUR_DECIMALS - upperRange_);\n            // 1% = 1e2, 100% = 1e4\n            lowerRange_ = (centerPrice_ * (FOUR_DECIMALS - lowerRange_)) / FOUR_DECIMALS;\n        }\n\n        // Calculate threshold prices\n        uint256 upperThreshold_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) & X7;\n        uint256 lowerThreshold_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) & X7;\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) & X1) == 1) {\n            // if active shift is going on for threshold then calculate threshold real time\n            (upperThreshold_, lowerThreshold_) = _calcThresholdShifting(upperThreshold_, lowerThreshold_, dexId_);\n        }\n\n        unchecked {\n            upperThreshold_ = \n                (centerPrice_ + ((upperRange_ - centerPrice_) * (TWO_DECIMALS - upperThreshold_)) / TWO_DECIMALS);\n            lowerThreshold_ = \n                (centerPrice_ - ((centerPrice_ - lowerRange_) * (TWO_DECIMALS - lowerThreshold_)) / TWO_DECIMALS);\n        }\n\n        if (price_ > upperThreshold_) {\n            if (rebalancingStatus_ != 2) {\n                _dexVariables[dexId_] = _dexVariables[dexId_] & ~(X2 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) | \n                    (2 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS);\n                return 2;\n            }\n        } else if (price_ < lowerThreshold_) {\n            if (rebalancingStatus_ != 3) {\n                _dexVariables[dexId_] = _dexVariables[dexId_] & ~(X2 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) | \n                    (3 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS);\n                return 3;\n            }\n        } else {\n            if (rebalancingStatus_ != 1) {\n                _dexVariables[dexId_] = _dexVariables[dexId_] & ~(X2 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) | \n                    (1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS);\n                return 1;\n            }\n        }\n\n        return rebalancingStatus_;\n    }\n\n    function _transferTokens(\n        address tokenIn_,\n        uint256 amountIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        address to_,\n        bool isCallback_,\n        bytes calldata callbackData_\n    ) internal {\n        if (to_ == address(0)) {\n            to_ = msg.sender;\n        }\n\n        // Transfer tokens out first\n        if (tokenOut_ == NATIVE_TOKEN) {\n            SafeTransfer.safeTransferNative(to_, amountOut_);\n        } else {\n            SafeTransfer.safeTransfer(tokenOut_, to_, amountOut_);\n        }\n\n        // Transfer tokens in\n        if (tokenIn_ == NATIVE_TOKEN) {\n            if (isCallback_ && msg.value == 0) {\n                uint256 ethBalance_ = address(this).balance;\n                IDexLiteCallback(msg.sender).dexCallback(tokenIn_, amountIn_, callbackData_);\n                if (address(this).balance - ethBalance_ < amountIn_) revert InsufficientNativeTokenReceived(address(this).balance - ethBalance_, amountIn_);\n            }  else {\n                if (msg.value < amountIn_) {\n                    revert InsufficientNativeTokenReceived(msg.value, amountIn_);\n                }\n                if (msg.value > amountIn_) {\n                    SafeTransfer.safeTransferNative(msg.sender, msg.value - amountIn_);\n                }\n                // if msg.value == amountIn_ then that means the transfer has already happened\n            }\n        } else {\n            if (msg.value > 0) {\n                revert InvalidMsgValue(); // msg.value should be 0 for non native tokens\n            }\n            if (isCallback_) {\n                uint256 tokenInBalance_ = IERC20(tokenIn_).balanceOf(address(this));\n                IDexLiteCallback(msg.sender).dexCallback(tokenIn_, amountIn_, callbackData_);\n                if ((IERC20(tokenIn_).balanceOf(address(this)) - tokenInBalance_) < amountIn_) {\n                    revert InsufficientERC20Received(IERC20(tokenIn_).balanceOf(address(this)) - tokenInBalance_, amountIn_);\n                }\n            } else {\n                SafeTransfer.safeTransferFrom(tokenIn_, msg.sender, address(this), amountIn_);\n            }\n        }\n    }\n\n    /// @dev            do any arbitrary call\n    /// @param target_  Address to which the call needs to be delegated\n    /// @param data_    Data to execute at the delegated address\n    function _spell(address target_, bytes memory data_) internal returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            if iszero(succeeded) {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/protocols/dexLite/core/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./coreInternals.sol\";\n\n/// @title FluidDexLite\ncontract FluidDexLite is CoreInternals {\n    constructor(address auth_, address liquidity_, address deployerContract_) {\n        _isAuth[auth_] = 1;\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        DEPLOYER_CONTRACT = deployerContract_;\n    }\n\n    /// @notice Swap through a single dex pool\n    /// @dev Uses _swapIn for positive amountSpecified_ (user provides input), _swapOut for negative (user receives output).\n    /// @param dexKey_ The dex pool to swap through.\n    /// @param swap0To1_ Whether to swap from token0 to token1 or vice versa.\n    /// @param amountSpecified_ The amount to swap (positive for exact input, negative for exact output).\n    /// @param amountLimit_ The minimum/maximum amount for the unspecified side.\n    /// @param to_ The recipient address.\n    function swapSingle(\n        DexKey calldata dexKey_, \n        bool swap0To1_, \n        int256 amountSpecified_,\n        uint256 amountLimit_,\n        address to_,\n        bool isCallback_,\n        bytes calldata callbackData_,\n        bytes calldata extraData_\n    ) external payable _reentrancyLock returns (uint256 amountUnspecified_) {\n        if (amountSpecified_ > 0) {\n            amountUnspecified_ = _swapIn(dexKey_, swap0To1_, uint256(amountSpecified_));\n\n            if (amountUnspecified_ < amountLimit_) {\n                revert AmountLimitNotMet(amountUnspecified_, amountLimit_);\n            }\n\n            if (extraData_.length == 0) {\n                if (swap0To1_) {\n                    _transferTokens(dexKey_.token0, uint256(amountSpecified_), dexKey_.token1, amountUnspecified_, to_, isCallback_, callbackData_);\n                } else {\n                    _transferTokens(dexKey_.token1, uint256(amountSpecified_), dexKey_.token0, amountUnspecified_, to_, isCallback_, callbackData_);\n                }\n            } else if (bytes32(extraData_) == ESTIMATE_SWAP) {\n                revert EstimateSwap(amountUnspecified_);\n            } else {\n                _callExtraDataSlot(\n                    abi.encode(\n                        SWAP_SINGLE, \n                        abi.encode(dexKey_, swap0To1_, amountSpecified_, amountUnspecified_, extraData_)\n                    )\n                );\n            }\n        } else {\n            amountUnspecified_ = _swapOut(dexKey_, swap0To1_, uint256(-amountSpecified_));\n\n            if (amountUnspecified_ > amountLimit_) {\n                revert AmountLimitExceeded(amountUnspecified_, amountLimit_);\n            }\n\n            if (extraData_.length == 0) {\n                if (swap0To1_) {\n                    _transferTokens(dexKey_.token0, amountUnspecified_, dexKey_.token1, uint256(-amountSpecified_), to_, isCallback_, callbackData_);\n                } else {\n                    _transferTokens(dexKey_.token1, amountUnspecified_, dexKey_.token0, uint256(-amountSpecified_), to_, isCallback_, callbackData_);\n                }\n            } else if (bytes32(extraData_) == ESTIMATE_SWAP) {\n                revert EstimateSwap(amountUnspecified_);\n            } else {\n                _callExtraDataSlot(\n                    abi.encode(\n                        SWAP_SINGLE, \n                        abi.encode(dexKey_, swap0To1_, amountSpecified_, amountUnspecified_, extraData_)\n                    )\n                );\n            }\n        }\n    }\n\n    /// @notice Swap through a path of dex pools\n    /// @dev Uses _swapIn for positive amountSpecified_ (user provides input), _swapOut for negative (user receives output).\n    /// @param path_ The path of the swap.\n    /// @param dexKeys_ The dex pools to swap through.\n    /// @param amountSpecified_ The amount to swap (positive for exact input, negative for exact output).\n    /// @param amountLimits_ The minimum/maximum amount for the unspecified side for all swaps.\n    /// @param transferParams_ The parameters for the transfer.\n    /// @return amountUnspecified_ The amount of the unspecified token.\n    function swapHop(\n        address[] calldata path_,\n        DexKey[] calldata dexKeys_,\n        int256 amountSpecified_,\n        uint256[] calldata amountLimits_,\n        TransferParams calldata transferParams_\n    ) external payable _reentrancyLock returns (uint256 amountUnspecified_) {\n        if (dexKeys_.length == 0) {\n            revert EmptyDexKeysArray();\n        }\n        if (path_.length - 1 != dexKeys_.length) {\n            revert InvalidPathLength(path_.length, dexKeys_.length);\n        }\n        if (amountLimits_.length != dexKeys_.length) {\n            revert InvalidAmountLimitsLength(amountLimits_.length, dexKeys_.length);\n        }\n\n        if (amountSpecified_ > 0) {\n            // Swap In (Exact input amount provided by the user)\n            amountUnspecified_ = uint256(amountSpecified_);\n\n            for (uint256 i = 0; i < dexKeys_.length; ) {\n                bool swap0To1_;\n                unchecked {\n                    if (path_[i] == dexKeys_[i].token0 && path_[i + 1] == dexKeys_[i].token1) {\n                        swap0To1_ = true;\n                    } else if (path_[i] == dexKeys_[i].token1 && path_[i + 1] == dexKeys_[i].token0) {\n                        swap0To1_ = false;\n                    } else {\n                        revert InvalidPathTokenOrder();\n                    }\n                }\n\n                amountUnspecified_ = _swapIn(dexKeys_[i], swap0To1_, amountUnspecified_);\n                if (amountUnspecified_ < amountLimits_[i]) {\n                    revert AmountLimitNotMet(amountUnspecified_, amountLimits_[i]);\n                }\n\n                unchecked { ++i; }\n            }\n\n            if (transferParams_.extraData.length == 0) {\n                _transferTokens(\n                    path_[0], \n                    uint256(amountSpecified_), \n                    path_[dexKeys_.length], \n                    amountUnspecified_, \n                    transferParams_.to, \n                    transferParams_.isCallback, \n                    transferParams_.callbackData\n                );\n            } else if (bytes32(transferParams_.extraData) == ESTIMATE_SWAP) {\n                revert EstimateSwap(amountUnspecified_);\n            } else {\n                _callExtraDataSlot(\n                    abi.encode(\n                        SWAP_HOP, \n                        abi.encode(path_, dexKeys_, amountSpecified_, amountUnspecified_, transferParams_.extraData)\n                    )\n                );\n            }\n                \n        } else {\n            // Swap Out (Exact output amount received by the user)\n            amountUnspecified_ = uint256(-amountSpecified_);\n\n            for (uint256 i = dexKeys_.length; i > 0; ) {\n                bool swap0To1_;\n                unchecked {\n                    if (path_[i - 1] == dexKeys_[i - 1].token0 && path_[i] == dexKeys_[i - 1].token1) {\n                        swap0To1_ = true;\n                    } else if (path_[i - 1] == dexKeys_[i - 1].token1 && path_[i] == dexKeys_[i - 1].token0) {\n                        swap0To1_ = false;\n                    } else {\n                        revert InvalidPathTokenOrder();\n                    }\n                }\n\n                amountUnspecified_ = _swapOut(dexKeys_[i - 1], swap0To1_, amountUnspecified_);\n                if (amountUnspecified_ > amountLimits_[i - 1]) {\n                    revert AmountLimitExceeded(amountUnspecified_, amountLimits_[i - 1]);\n                }\n\n                unchecked { --i; }\n            }\n\n            if (transferParams_.extraData.length == 0) {\n                _transferTokens(\n                    path_[0], \n                    amountUnspecified_, \n                    path_[dexKeys_.length], \n                    uint256(-amountSpecified_), \n                    transferParams_.to, \n                    transferParams_.isCallback, \n                    transferParams_.callbackData\n                );\n            } else if (bytes32(transferParams_.extraData) == ESTIMATE_SWAP) {\n                revert EstimateSwap(amountUnspecified_);\n            } else {\n                _callExtraDataSlot(\n                    abi.encode(\n                        SWAP_HOP, \n                        abi.encode(path_, dexKeys_, amountSpecified_, amountUnspecified_, transferParams_.extraData)\n                    )\n                );\n            }\n        }\n    }\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_) {\n        assembly {\n            result_ := sload(slot_)\n        }\n    }\n\n    fallback(bytes calldata data_) external payable _reentrancyLock returns (bytes memory) {\n        if (_isAuth[msg.sender] != 1 && _getGovernanceAddr() != msg.sender) {\n            revert UnauthorizedCaller(msg.sender);\n        }\n\n        (address target_, bytes memory spellData_) = abi.decode(data_, (address, bytes));\n        return _spell(target_, spellData_);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/protocols/dexLite/other/commonImport.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./variables.sol\";\n\nabstract contract CommonImport is Variables {}\n"
    },
    "contracts/protocols/dexLite/other/constantVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./events.sol\";\n\nabstract contract ConstantVariables {\n    /*//////////////////////////////////////////////////////////////\n                                CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// bytes32(uint256(keccak256(\"FLUID_DEX_LITE_EXTRA_DATA\")) - 1)\n    bytes32 internal constant EXTRA_DATA_SLOT = 0x7e8134afb5ed35d36cb65e24b9a4712a52bb77d952806c1acf50970d2107797f;\n\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1\n    /// The exact slot which stored the admin address in infinite proxy of liquidity contracts\n    bytes32 internal constant LIQUIDITY_GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    bool internal constant SWAP_SINGLE = true;\n    bool internal constant SWAP_HOP = false;\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal constant NATIVE_TOKEN_DECIMALS = 18;\n    uint256 internal constant TOKENS_DECIMALS_PRECISION = 9;\n\n    uint8 internal constant MIN_TOKEN_DECIMALS = 6;\n    uint8 internal constant MAX_TOKEN_DECIMALS = 18;\n\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 20;\n    uint256 internal constant BIG_COEFFICIENT_SIZE = 32;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant X1 = 0x1;\n    uint256 internal constant X2 = 0x3;\n    uint256 internal constant X5 = 0x1f;\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X13 = 0x1fff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X19 = 0x7ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X56 = 0xffffffffffffff;\n    uint256 internal constant X60 = 0xfffffffffffffff;\n    uint256 internal constant X73 = 0x1ffffffffffffffffff;\n    uint256 internal constant X120 = 0xffffffffffffffffffffffffffffff;\n    uint256 internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n   \n    uint256 internal constant TWO_DECIMALS = 1e2;\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant SIX_DECIMALS = 1e6;\n\n    uint256 internal constant PRICE_PRECISION = 1e27;\n\n    /// after swap token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_SWAP\n    /// after swap token1 reserves should not be less than token0InToken1 / MINIMUM_LIQUIDITY_SWAP\n    uint256 internal constant MINIMUM_LIQUIDITY_SWAP = 1e4;\n\n    bytes32 internal constant ESTIMATE_SWAP = keccak256(bytes(\"ESTIMATE_SWAP\"));\n}\n"
    },
    "contracts/protocols/dexLite/other/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./interfaces.sol\";\n\nevent LogSwap(uint256 swapData, uint256 dexVariables);\n// swapData\n// First 64 bits => 0   - 63  => dexId\n// Next  1  bit  => 64        => swap 0 to 1 (1 => true, 0 => false)\n// Next  60 bits => 65  - 124 => amount in adjusted\n// Next  60 bits => 125 - 184 => amount out adjusted\n\n// dexVariables\n// Same as variables.sol"
    },
    "contracts/protocols/dexLite/other/immutableVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport \"./constantVariables.sol\";\n\n// TODO\n// import { IFluidDexFactory } from \"../../interfaces/iDexFactory.sol\";\n// import { Error } from \"../../error.sol\";\n// import { ErrorTypes } from \"../../errorTypes.sol\";\n\nabstract contract ImmutableVariables is ConstantVariables {\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Address of liquidity contract\n    IFluidLiquidity internal immutable LIQUIDITY;\n\n    /// @dev Address of contract used for deploying center price & hook related contract\n    address internal immutable DEPLOYER_CONTRACT;\n}\n"
    },
    "contracts/protocols/dexLite/other/interfaces.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport \"./structs.sol\";\n\ninterface IERC20WithDecimals is IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ninterface IDexLiteCallback {\n    function dexCallback(address token_, uint256 amount_, bytes calldata data_) external;\n}\n\ninterface ICenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price The current price of token0 in terms of token1, expressed with 27 decimal places\n    function centerPrice(address token0_, address token1_) external returns (uint256);\n}"
    },
    "contracts/protocols/dexLite/other/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./events.sol\";\n\nstruct DexKey {\n    address token0;\n    address token1;\n    bytes32 salt;\n}\n\nstruct TransferParams {\n    address to;\n    bool isCallback;\n    bytes callbackData;\n    bytes extraData;\n}\n"
    },
    "contracts/protocols/dexLite/other/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./immutableVariables.sol\";\n\nabstract contract Variables is ImmutableVariables {\n    /// @dev admin address\n    mapping(address => uint256) internal _isAuth;\n\n    /// @dev dexes list\n    DexKey[] internal _dexesList;\n\n    // First 13 bits => 0   - 12  => fee (1% = 10000, max value: 8191 = .8191%)\n    // Next  7  bits => 13  - 19  => revenue cut (1 = 1%)\n    // Next  2  bit  => 20  - 21  => rebalancing status (0 = off, 1 = on but not active, 2 = rebalancing active towards upper range, 3 = rebalancing active towards lower range)\n    // Next  1  bit  => 22        => is center price shift active\n    // Next  40 bits => 23  - 62  => center price. Center price from where the ranges will be calculated. BigNumber (32 bits precision, 8 bits exponent)\n    // Next  19 bits => 63  - 81  => center price contract address (Deployment Factory Nonce)\n    // Next  1  bit  => 82        => range percent shift active or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time\n    // Next  14 bits => 83  - 96  => upperPercent (1% = 100) upperRange - upperRange * upperPercent = centerPrice. Hence, upperRange = centerPrice / (1 - upperPercent)\n    // Next  14 bits => 97  - 110 => lowerPercent (1% = 100) lowerRange = centerPrice - centerPrice * lowerPercent\n    // Next  1  bit  => 111       => threshold percent shift active or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time\n    // Next  7 bits  => 112 - 118 => upper shift threshold percent, 1 = 1%. 100 = 100%. if currentPrice > (centerPrice + (upperRange - centerPrice) * (100 - upperShiftThresholdPercent) / 100) then trigger shift\n    // Next  7 bits  => 119 - 125 => lower shift threshold percent, 1 = 1%. 100 = 100%. if currentPrice < (centerPrice - (centerPrice - lowerRange) * (100 - lowerShiftThresholdPercent) / 100) then trigger shift\n    // Next  5  bits => 126 - 130 => token 0 decimals\n    // Next  5  bits => 131 - 135 => token 1 decimals\n    // Next  60 bits => 136 - 195 => total token 0 adjusted amount\n    // Next  60 bits => 196 - 255 => total token 1 adjusted amount\n    /// @dev dex id => dex variables\n    mapping(bytes8 => uint256) internal _dexVariables;\n\n    /// NOTE: Center price shift is always fuzzy, and can shift because of rebalancing or center price shift\n    // First 33 bits => 0   - 32  => last interaction timestamp (only stored when either rebalancing or center price shift is active)\n    /// REBALANCING RELATED THINGS\n    // First 24 bits => 33  - 56  => shifting time (max ~194 days)\n    // Next  28 bits => 57  - 84  => max center price. BigNumber (20 bits precision, 8 bits exponent)\n    // Next  28 bits => 85  - 112 => min center price. BigNumber (20 bits precision, 8 bits exponent)\n    /// CENTER PRICE SHIFT RELATED THINGS\n    // First 20 bits => 113 - 132 => % shift (1% = 1000)\n    // Next  20 bits => 133 - 152 => time to shift that percent, ~12 days max\n    // Next  33 bits => 153 - 185 => timestamp of when the shift started\n    // Last 70 bits empty\n    /// @dev dex id => center price shift\n    mapping(bytes8 => uint256) internal _centerPriceShift;\n\n    /// Range Shift (first 128 bits)\n    // First 14 bits => 0  - 13 => old upper range percent\n    // Next  14 bits => 14 - 27 => old lower range percent\n    // Next  20 bits => 28 - 47 => time to shift in seconds, ~12 days max, shift can last for max ~12 days\n    // Next  33 bits => 48 - 80 => timestamp of when the shift has started.\n    // Last 175 bits empty\n    /// @dev dex id => range shift\n    mapping(bytes8 => uint256) internal _rangeShift;\n\n    // First 7  bits => 0  - 6  => old upper threshold percent\n    // Next  7  bits => 7  - 13 => old lower threshold percent\n    // Next  20 bits => 14 - 33 => time to shift in seconds, ~12 days max, shift can last for max ~12 days\n    // Next  33 bits => 34 - 66 => timestamp of when the shift has started\n    // Last 189 bits empty\n    /// @dev dex id => threshold shift\n    mapping(bytes8 => uint256) internal _thresholdShift;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "solmate/src/utils/CREATE3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"./Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(\n        bytes32 salt,\n        bytes memory creationCode,\n        uint256 value\n    ) internal returns (address deployed) {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        deployed = getDeployed(salt);\n        (bool success, ) = proxy.call{value: value}(creationCode);\n        require(success && deployed.code.length != 0, \"INITIALIZATION_FAILED\");\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address) {\n        address proxy = keccak256(\n            abi.encodePacked(\n                // Prefix:\n                bytes1(0xFF),\n                // Creator:\n                address(this),\n                // Salt:\n                salt,\n                // Bytecode hash:\n                PROXY_BYTECODE_HASH\n            )\n        ).fromLast20Bytes();\n\n        return\n            keccak256(\n                abi.encodePacked(\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n                    hex\"d6_94\",\n                    proxy,\n                    hex\"01\" // Nonce of the proxy contract (1)\n                )\n            ).fromLast20Bytes();\n    }\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    },
    "solmate/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}