{
  "address": "0xFF5121B9689B16e9558bEC16bca590f5d70E3ad4",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "errorId_",
          "type": "uint256"
        }
      ],
      "name": "FluidConfigError",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "oldBorrowRate",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "newBorrowRate",
          "type": "int256"
        }
      ],
      "name": "LogUpdateBorrowRate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldBorrowRateMagnifier",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newBorrowRateMagnifier",
          "type": "uint256"
        }
      ],
      "name": "LogUpdateBorrowRateMagnifier",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "oldSupplyRate",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "newSupplyRate",
          "type": "int256"
        }
      ],
      "name": "LogUpdateSupplyRate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldSupplyRateMagnifier",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newSupplyRateMagnifier",
          "type": "uint256"
        }
      ],
      "name": "LogUpdateSupplyRateMagnifier",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "TEAM_MULTISIG",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TEAM_MULTISIG2",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartDebtVault_",
          "type": "address"
        }
      ],
      "name": "currentBorrowRate",
      "outputs": [
        {
          "internalType": "int256",
          "name": "borrowRate_",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "normalDebtVault_",
          "type": "address"
        }
      ],
      "name": "currentBorrowRateMagnifier",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartColVault_",
          "type": "address"
        }
      ],
      "name": "currentSupplyRate",
      "outputs": [
        {
          "internalType": "int256",
          "name": "supplyRate_",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "normalColVault_",
          "type": "address"
        }
      ],
      "name": "currentSupplyRateMagnifier",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault_",
          "type": "address"
        }
      ],
      "name": "getVaultType",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isSmartCol_",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "isSmartDebt_",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartDebtVault_",
          "type": "address"
        },
        {
          "internalType": "int256",
          "name": "newBorrowRate_",
          "type": "int256"
        }
      ],
      "name": "updateBorrowRate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "normalDebtVault_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "newMagnifier_",
          "type": "uint256"
        }
      ],
      "name": "updateBorrowRateMagnifier",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartColVault_",
          "type": "address"
        },
        {
          "internalType": "int256",
          "name": "newSupplyRate_",
          "type": "int256"
        }
      ],
      "name": "updateSupplyRate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "normalColVault_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "newMagnifier_",
          "type": "uint256"
        }
      ],
      "name": "updateSupplyRateMagnifier",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xd1038dbd38a3da4271979f230322990ae75dd8022d52cbcd55ece382d534e6e9",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0Ed35B1609Ec45c7079E80d11149a52717e4859A",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "790199",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2d2a9028e6e69781d729a0c4513180ded95fbab1cb4f46b56c0685b711462166",
    "transactionHash": "0xd1038dbd38a3da4271979f230322990ae75dd8022d52cbcd55ece382d534e6e9",
    "logs": [],
    "blockNumber": 1112586,
    "cumulativeGasUsed": "790199",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "98b16aabfb0901b7e1bdfdd419cfac66",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorId_\",\"type\":\"uint256\"}],\"name\":\"FluidConfigError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"oldBorrowRate\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"newBorrowRate\",\"type\":\"int256\"}],\"name\":\"LogUpdateBorrowRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBorrowRateMagnifier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBorrowRateMagnifier\",\"type\":\"uint256\"}],\"name\":\"LogUpdateBorrowRateMagnifier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"oldSupplyRate\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"newSupplyRate\",\"type\":\"int256\"}],\"name\":\"LogUpdateSupplyRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSupplyRateMagnifier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupplyRateMagnifier\",\"type\":\"uint256\"}],\"name\":\"LogUpdateSupplyRateMagnifier\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TEAM_MULTISIG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEAM_MULTISIG2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartDebtVault_\",\"type\":\"address\"}],\"name\":\"currentBorrowRate\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"borrowRate_\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"normalDebtVault_\",\"type\":\"address\"}],\"name\":\"currentBorrowRateMagnifier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartColVault_\",\"type\":\"address\"}],\"name\":\"currentSupplyRate\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"supplyRate_\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"normalColVault_\",\"type\":\"address\"}],\"name\":\"currentSupplyRateMagnifier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"name\":\"getVaultType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isSmartCol_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSmartDebt_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartDebtVault_\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"newBorrowRate_\",\"type\":\"int256\"}],\"name\":\"updateBorrowRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"normalDebtVault_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newMagnifier_\",\"type\":\"uint256\"}],\"name\":\"updateBorrowRateMagnifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartColVault_\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"newSupplyRate_\",\"type\":\"int256\"}],\"name\":\"updateSupplyRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"normalColVault_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newMagnifier_\",\"type\":\"uint256\"}],\"name\":\"updateSupplyRateMagnifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"LogUpdateBorrowRate(address,int256,int256)\":{\"params\":{\"newBorrowRate\":\"The new borrow rate value\",\"oldBorrowRate\":\"The previous borrow rate value\",\"vault\":\"The address of the vault\"}},\"LogUpdateBorrowRateMagnifier(address,uint256,uint256)\":{\"params\":{\"newBorrowRateMagnifier\":\"The new borrow rate magnifier value\",\"oldBorrowRateMagnifier\":\"The previous borrow rate magnifier value\",\"vault\":\"The address of the vault\"}},\"LogUpdateSupplyRate(address,int256,int256)\":{\"params\":{\"newSupplyRate\":\"The new supply rate value\",\"oldSupplyRate\":\"The previous supply rate value\",\"vault\":\"The address of the vault\"}},\"LogUpdateSupplyRateMagnifier(address,uint256,uint256)\":{\"params\":{\"newSupplyRateMagnifier\":\"The new supply rate magnifier value\",\"oldSupplyRateMagnifier\":\"The previous supply rate magnifier value\",\"vault\":\"The address of the vault\"}}},\"kind\":\"dev\",\"methods\":{\"currentBorrowRate(address)\":{\"params\":{\"smartDebtVault_\":\"The address of the SMART DEBT vault to query.\"},\"returns\":{\"borrowRate_\":\"The current borrow rate value.\"}},\"currentBorrowRateMagnifier(address)\":{\"params\":{\"normalDebtVault_\":\"The address of the NORMAL DEBT vault to query.\"},\"returns\":{\"_0\":\"The current borrow rate magnifier value.\"}},\"currentSupplyRate(address)\":{\"params\":{\"smartColVault_\":\"The address of the SMART COL vault to query.\"},\"returns\":{\"supplyRate_\":\"The current supply rate value.\"}},\"currentSupplyRateMagnifier(address)\":{\"params\":{\"normalColVault_\":\"The address of the NORMAL COL vault to query.\"},\"returns\":{\"_0\":\"The current supply rate magnifier value.\"}},\"getVaultType(address)\":{\"params\":{\"vault_\":\"The address of the vault.\"},\"returns\":{\"isSmartCol_\":\"True if the vault is a SMART COL vault, false otherwise.\",\"isSmartDebt_\":\"True if the vault is a SMART DEBT vault, false otherwise.\"}},\"updateBorrowRate(address,int256)\":{\"params\":{\"newBorrowRate_\":\"The new borrow rate to set. Input in 1e2 (1% = 100, 100% = 10_000). If positive then charging else incentives\",\"smartDebtVault_\":\"The address of the SMART DEBT vault to update\"}},\"updateBorrowRateMagnifier(address,uint256)\":{\"params\":{\"newMagnifier_\":\"The new borrow rate magnifier value to set.\",\"normalDebtVault_\":\"The address of the NORMAL DEBT vault to update.\"}},\"updateSupplyRate(address,int256)\":{\"params\":{\"newSupplyRate_\":\"The new supply rate to set. Input in 1e2 (1% = 100, 100% = 10_000). If positive then incentives else charging\",\"smartColVault_\":\"The address of the SMART COL vault to update\"}},\"updateSupplyRateMagnifier(address,uint256)\":{\"params\":{\"newMagnifier_\":\"The new supply rate magnifier value to set.\",\"normalColVault_\":\"The address of the NORMAL COL vault to update.\"}}},\"version\":1},\"userdoc\":{\"events\":{\"LogUpdateBorrowRate(address,int256,int256)\":{\"notice\":\"emitted when borrow rate is updated at a vault\"},\"LogUpdateBorrowRateMagnifier(address,uint256,uint256)\":{\"notice\":\"emitted when borrow rate magnifier is updated at a vault\"},\"LogUpdateSupplyRate(address,int256,int256)\":{\"notice\":\"emitted when supply rate is updated at a vault\"},\"LogUpdateSupplyRateMagnifier(address,uint256,uint256)\":{\"notice\":\"emitted when supply rate magnifier is updated at a vault\"}},\"kind\":\"user\",\"methods\":{\"TEAM_MULTISIG()\":{\"notice\":\"Team multisig allowed to trigger collecting revenue\"},\"currentBorrowRate(address)\":{\"notice\":\"returns the currently configured borrow rate at the `vault_`\"},\"currentBorrowRateMagnifier(address)\":{\"notice\":\"returns the currently configured borrow rate magnifier at the `vault_`\"},\"currentSupplyRate(address)\":{\"notice\":\"returns the currently configured supply rate at the `vault_`\"},\"currentSupplyRateMagnifier(address)\":{\"notice\":\"returns the currently configured supply rate magnifier at the `vault_`\"},\"getVaultType(address)\":{\"notice\":\"Get the type of a vault (assumes valid Fluid vault address is passed in)\"},\"updateBorrowRate(address,int256)\":{\"notice\":\"updates the borrow rate for a given SMART DEBT vault.\"},\"updateBorrowRateMagnifier(address,uint256)\":{\"notice\":\"Sets the borrow rate magnifier for a given NORMAL DEBT vault.\"},\"updateSupplyRate(address,int256)\":{\"notice\":\"updates the supply rate for a given SMART COL vault.\"},\"updateSupplyRateMagnifier(address,uint256)\":{\"notice\":\"Sets the supply rate magnifier for a given NORMAL COL vault.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/config/vaultFeeRewardsAuth/main.sol\":\"FluidVaultFeeRewardsAuth\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"contracts/config/error.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ncontract Error {\\n    error FluidConfigError(uint256 errorId_);\\n}\\n\",\"keccak256\":\"0x7fac063d4cfeb626e3a2720595a2db1d7352353ed6c7df61e95a6c164450c9e6\",\"license\":\"BUSL-1.1\"},\"contracts/config/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary ErrorTypes {\\n    /***********************************|\\n    |    ExpandPercentConfigHandler     | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an input address is zero\\n    uint256 internal constant ExpandPercentConfigHandler__AddressZero = 100001;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant ExpandPercentConfigHandler__Unauthorized = 100002;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant ExpandPercentConfigHandler__InvalidParams = 100003;\\n\\n    /// @notice thrown when no update is currently needed\\n    uint256 internal constant ExpandPercentConfigHandler__NoUpdate = 100004;\\n\\n    /// @notice thrown when slot is not used, e.g. when borrow token is 0 there is no borrow data\\n    uint256 internal constant ExpandPercentConfigHandler__SlotDoesNotExist = 100005;\\n\\n    /***********************************|\\n    |      EthenaRateConfigHandler      | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an input address is zero\\n    uint256 internal constant EthenaRateConfigHandler__AddressZero = 100011;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant EthenaRateConfigHandler__Unauthorized = 100012;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant EthenaRateConfigHandler__InvalidParams = 100013;\\n\\n    /// @notice thrown when no update is currently needed\\n    uint256 internal constant EthenaRateConfigHandler__NoUpdate = 100014;\\n\\n    /***********************************|\\n    |       MaxBorrowConfigHandler      | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an input address is zero\\n    uint256 internal constant MaxBorrowConfigHandler__AddressZero = 100021;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant MaxBorrowConfigHandler__Unauthorized = 100022;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant MaxBorrowConfigHandler__InvalidParams = 100023;\\n\\n    /// @notice thrown when no update is currently needed\\n    uint256 internal constant MaxBorrowConfigHandler__NoUpdate = 100024;\\n\\n    /***********************************|\\n    |       BufferRateConfigHandler     | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an input address is zero\\n    uint256 internal constant BufferRateConfigHandler__AddressZero = 100031;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant BufferRateConfigHandler__Unauthorized = 100032;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant BufferRateConfigHandler__InvalidParams = 100033;\\n\\n    /// @notice thrown when no update is currently needed\\n    uint256 internal constant BufferRateConfigHandler__NoUpdate = 100034;\\n\\n    /// @notice thrown when rate data version is not supported\\n    uint256 internal constant BufferRateConfigHandler__RateVersionUnsupported = 100035;\\n\\n    /***********************************|\\n    |          FluidRatesAuth           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when no update is currently needed\\n    uint256 internal constant RatesAuth__NoUpdate = 100041;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant RatesAuth__Unauthorized = 100042;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant RatesAuth__InvalidParams = 100043;\\n\\n    /// @notice thrown when cooldown is not yet expired\\n    uint256 internal constant RatesAuth__CooldownLeft = 100044;\\n\\n    /// @notice thrown when version is invalid\\n    uint256 internal constant RatesAuth__InvalidVersion = 100045;\\n\\n    /***********************************|\\n    |       LiquidityTokenAuth          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant LiquidityTokenAuth__Unauthorized = 100051;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant LiquidityTokenAuth_AlreadyInitialized = 100052;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant LiquidityTokenAuth__InvalidParams = 100053;\\n\\n    /***********************************|\\n    |       CollectRevenueAuth          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant CollectRevenueAuth__Unauthorized = 100061;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant CollectRevenueAuth__InvalidParams = 100062;\\n\\n    /***********************************|\\n    |       FluidWithdrawLimitAuth      | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant WithdrawLimitAuth__NoUserSupply = 100071;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls a protected method\\n    uint256 internal constant WithdrawLimitAuth__Unauthorized = 100072;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant WithdrawLimitAuth__InvalidParams = 100073;\\n\\n    /// @notice thrown when no more withdrawal limit can be set for the day\\n    uint256 internal constant WithdrawLimitAuth__DailyLimitReached = 100074;\\n\\n    /// @notice thrown when no more withdrawal limit can be set for the hour\\n    uint256 internal constant WithdrawLimitAuth__HourlyLimitReached = 100075;\\n\\n    /// @notice thrown when the withdrawal limit and userSupply difference exceeds 5%\\n    uint256 internal constant WithdrawLimitAuth__ExcessPercentageDifference = 100076;\\n\\n    /***********************************|\\n    |       DexFeeHandler               | \\n    |__________________________________*/\\n\\n    /// @notice thrown when fee update is not required\\n    uint256 internal constant DexFeeHandler__FeeUpdateNotRequired = 100081;\\n\\n    /// @notice thrown when invalid params are passed into a method\\n    uint256 internal constant DexFeeHandler__InvalidParams = 100082;\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls\\n    uint256 internal constant DexFeeHandler__Unauthorized = 100083;\\n\\n    /***********************************|\\n    |           RangeAuthDex            | \\n    |__________________________________*/\\n\\n    uint256 internal constant RangeAuthDex__InvalidParams = 100091;\\n    uint256 internal constant RangeAuthDex__CooldownLeft = 100092;\\n    uint256 internal constant RangeAuthDex__Unauthorized = 100093;\\n    uint256 internal constant RangeAuthDex__ExceedAllowedPercentageChange = 100094;\\n    uint256 internal constant RangeAuthDex__InvalidShiftTime = 100095;\\n\\n    /***********************************|\\n    |           FluidLimitsAuth         | \\n    |__________________________________*/\\n\\n    uint256 internal constant LimitsAuth__InvalidParams = 100101;\\n    uint256 internal constant LimitsAuth__Unauthorized = 100102;\\n    uint256 internal constant LimitsAuth__UserNotDefinedYet = 100103;\\n    uint256 internal constant LimitsAuth__ExceedAllowedPercentageChange = 100104;\\n    uint256 internal constant LimitsAuth__CoolDownPending = 100105;\\n\\n    /***********************************|\\n    |          DexFeeAuth               | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls\\n    uint256 internal constant DexFeeAuth__Unauthorized = 100111;\\n\\n    /***********************************|\\n    |       VaultFeeRewardsAuth         | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an unauthorized `msg.sender` calls\\n    uint256 internal constant VaultFeeRewardsAuth__Unauthorized = 100121;\\n    /// @notice thrown when magnifier or rate is being updated for a non matching vault type\\n    uint256 internal constant VaultFeeRewardsAuth__InvalidVaultType = 100122;\\n}\\n\",\"keccak256\":\"0xe243f2978050b7b4680b69c7a13a56022c0984f70852556db0eacb11523384f4\",\"license\":\"BUSL-1.1\"},\"contracts/config/vaultFeeRewardsAuth/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { FluidVaultT1Admin } from \\\"../../protocols/vault/vaultT1/adminModule/main.sol\\\";\\nimport { FluidVaultT2Admin } from \\\"../../protocols/vault/vaultT2/adminModule/main.sol\\\";\\nimport { FluidVaultT3Admin } from \\\"../../protocols/vault/vaultT3/adminModule/main.sol\\\";\\nimport { IFluidVault } from \\\"../../protocols/vault/interfaces/iVault.sol\\\";\\nimport { FluidProtocolTypes } from \\\"../../libraries/fluidProtocolTypes.sol\\\";\\n\\nimport { Error } from \\\"../error.sol\\\";\\nimport { ErrorTypes } from \\\"../errorTypes.sol\\\";\\n\\nabstract contract Constants {\\n    /// @notice Team multisig allowed to trigger collecting revenue\\n    address public constant TEAM_MULTISIG = 0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\\n    address public constant TEAM_MULTISIG2 = 0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\\n\\n    uint internal constant X15 = 0x7fff;\\n    uint internal constant X16 = 0xffff;\\n}\\n\\nabstract contract Events {\\n    /// @notice emitted when supply rate magnifier is updated at a vault\\n    /// @param vault The address of the vault\\n    /// @param oldSupplyRateMagnifier The previous supply rate magnifier value\\n    /// @param newSupplyRateMagnifier The new supply rate magnifier value\\n    event LogUpdateSupplyRateMagnifier(address vault, uint256 oldSupplyRateMagnifier, uint256 newSupplyRateMagnifier);\\n\\n    /// @notice emitted when borrow rate magnifier is updated at a vault\\n    /// @param vault The address of the vault\\n    /// @param oldBorrowRateMagnifier The previous borrow rate magnifier value\\n    /// @param newBorrowRateMagnifier The new borrow rate magnifier value\\n    event LogUpdateBorrowRateMagnifier(address vault, uint256 oldBorrowRateMagnifier, uint256 newBorrowRateMagnifier);\\n\\n    /// @notice emitted when supply rate is updated at a vault\\n    /// @param vault The address of the vault\\n    /// @param oldSupplyRate The previous supply rate value\\n    /// @param newSupplyRate The new supply rate value\\n    event LogUpdateSupplyRate(address vault, int256 oldSupplyRate, int256 newSupplyRate);\\n\\n    /// @notice emitted when borrow rate is updated at a vault\\n    /// @param vault The address of the vault\\n    /// @param oldBorrowRate The previous borrow rate value\\n    /// @param newBorrowRate The new borrow rate value\\n    event LogUpdateBorrowRate(address vault, int256 oldBorrowRate, int256 newBorrowRate);\\n}\\n\\ncontract FluidVaultFeeRewardsAuth is Constants, Error, Events {\\n    /// @dev Validates that an address is the team multisig\\n    modifier onlyMultisig() {\\n        if (msg.sender != TEAM_MULTISIG && TEAM_MULTISIG2 != msg.sender) {\\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__Unauthorized);\\n        }\\n        _;\\n    }\\n\\n    /// @notice updates the supply rate for a given SMART COL vault.\\n    /// @param smartColVault_ The address of the SMART COL vault to update\\n    /// @param newSupplyRate_ The new supply rate to set. Input in 1e2 (1% = 100, 100% = 10_000). If positive then incentives else charging\\n    function updateSupplyRate(address smartColVault_, int newSupplyRate_) external onlyMultisig {\\n        int256 oldSupplyRate_ = currentSupplyRate(smartColVault_);\\n\\n        FluidVaultT2Admin(address(smartColVault_)).updateSupplyRate(newSupplyRate_);\\n\\n        emit LogUpdateSupplyRate(smartColVault_, oldSupplyRate_, newSupplyRate_);\\n    }\\n\\n    /// @notice updates the borrow rate for a given SMART DEBT vault.\\n    /// @param smartDebtVault_ The address of the SMART DEBT vault to update\\n    /// @param newBorrowRate_ The new borrow rate to set. Input in 1e2 (1% = 100, 100% = 10_000). If positive then charging else incentives\\n    function updateBorrowRate(address smartDebtVault_, int newBorrowRate_) external onlyMultisig {\\n        int256 oldBorrowRate_ = currentBorrowRate(smartDebtVault_);\\n\\n        FluidVaultT3Admin(address(smartDebtVault_)).updateBorrowRate(newBorrowRate_);\\n\\n        emit LogUpdateBorrowRate(smartDebtVault_, oldBorrowRate_, newBorrowRate_);\\n    }\\n\\n    /// @notice Sets the supply rate magnifier for a given NORMAL COL vault.\\n    /// @param normalColVault_ The address of the NORMAL COL vault to update.\\n    /// @param newMagnifier_ The new supply rate magnifier value to set.\\n    function updateSupplyRateMagnifier(address normalColVault_, uint256 newMagnifier_) external onlyMultisig {\\n        uint256 oldMagnifier_ = currentSupplyRateMagnifier(normalColVault_);\\n\\n        FluidVaultT1Admin(address(normalColVault_)).updateSupplyRateMagnifier(newMagnifier_);\\n\\n        emit LogUpdateSupplyRateMagnifier(normalColVault_, oldMagnifier_, newMagnifier_);\\n    }\\n\\n    /// @notice Sets the borrow rate magnifier for a given NORMAL DEBT vault.\\n    /// @param normalDebtVault_ The address of the NORMAL DEBT vault to update.\\n    /// @param newMagnifier_ The new borrow rate magnifier value to set.\\n    function updateBorrowRateMagnifier(address normalDebtVault_, uint256 newMagnifier_) external onlyMultisig {\\n        uint256 oldMagnifier_ = currentBorrowRateMagnifier(normalDebtVault_);\\n\\n        FluidVaultT1Admin(address(normalDebtVault_)).updateBorrowRateMagnifier(newMagnifier_);\\n\\n        emit LogUpdateBorrowRateMagnifier(normalDebtVault_, oldMagnifier_, newMagnifier_);\\n    }\\n\\n    /// @notice Get the type of a vault (assumes valid Fluid vault address is passed in)\\n    /// @param vault_ The address of the vault.\\n    /// @return isSmartCol_ True if the vault is a SMART COL vault, false otherwise.\\n    /// @return isSmartDebt_ True if the vault is a SMART DEBT vault, false otherwise.\\n    function getVaultType(address vault_) public view returns (bool isSmartCol_, bool isSmartDebt_) {\\n        try IFluidVault(vault_).TYPE() returns (uint type_) {\\n            if (type_ == FluidProtocolTypes.VAULT_T1_TYPE) {\\n                return (false, false);\\n            }\\n            if (type_ == FluidProtocolTypes.VAULT_T2_SMART_COL_TYPE) {\\n                return (true, false);\\n            }\\n            if (type_ == FluidProtocolTypes.VAULT_T3_SMART_DEBT_TYPE) {\\n                return (false, true);\\n            }\\n            if (type_ == FluidProtocolTypes.VAULT_T4_SMART_COL_SMART_DEBT_TYPE) {\\n                return (true, true);\\n            }\\n        } catch {\\n            // if TYPE() is not available but address is valid vault id, it must be vault T1\\n            return (false, false);\\n        }\\n    }\\n\\n    /// @notice returns the currently configured supply rate magnifier at the `vault_`\\n    /// @param normalColVault_ The address of the NORMAL COL vault to query.\\n    /// @return The current supply rate magnifier value.\\n    function currentSupplyRateMagnifier(address normalColVault_) public view returns (uint256) {\\n        (bool isSmartCol_, ) = getVaultType(normalColVault_);\\n        if (isSmartCol_) {\\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\\n        }\\n\\n        // read supply rate magnifier from Vault `vaultVariables2` located in storage slot 1, 16 bits from 0-15\\n        return (IFluidVault(normalColVault_).readFromStorage(bytes32(uint256(1)))) & X16;\\n    }\\n\\n    /// @notice returns the currently configured borrow rate magnifier at the `vault_`\\n    /// @param normalDebtVault_ The address of the NORMAL DEBT vault to query.\\n    /// @return The current borrow rate magnifier value.\\n    function currentBorrowRateMagnifier(address normalDebtVault_) public view returns (uint256) {\\n        (, bool isSmartDebt_) = getVaultType(normalDebtVault_);\\n        if (isSmartDebt_) {\\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\\n        }\\n\\n        // read borrow rate magnifier from Vault `vaultVariables2` located in storage slot 1, 16 bits from 16-31\\n        return (IFluidVault(normalDebtVault_).readFromStorage(bytes32(uint256(1))) >> 16) & X16;\\n    }\\n\\n    /// @notice returns the currently configured supply rate at the `vault_`\\n    /// @param smartColVault_ The address of the SMART COL vault to query.\\n    /// @return supplyRate_ The current supply rate value.\\n    function currentSupplyRate(address smartColVault_) public view returns (int256 supplyRate_) {\\n        (bool isSmartCol_, ) = getVaultType(smartColVault_);\\n        if (!isSmartCol_) {\\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\\n        }\\n        uint256 supplyRateMagnifier_ = (IFluidVault(smartColVault_).readFromStorage(bytes32(uint256(1)))) & X16;\\n\\n        // in case of smart collateral supply magnifier bits stores supply interest rate positive or negative\\n        // negative meaning charging users, positive means incentivizing users\\n        supplyRate_ = int256((supplyRateMagnifier_ >> 1) & X15);\\n        // if first bit == 1 then positive else negative\\n        if ((supplyRateMagnifier_ & 1) == 0) {\\n            supplyRate_ = -supplyRate_;\\n        }\\n    }\\n\\n    /// @notice returns the currently configured borrow rate at the `vault_`\\n    /// @param smartDebtVault_ The address of the SMART DEBT vault to query.\\n    /// @return borrowRate_ The current borrow rate value.\\n    function currentBorrowRate(address smartDebtVault_) public view returns (int256 borrowRate_) {\\n        (, bool isSmartDebt_) = getVaultType(smartDebtVault_);\\n        if (!isSmartDebt_) {\\n            revert FluidConfigError(ErrorTypes.VaultFeeRewardsAuth__InvalidVaultType);\\n        }\\n\\n        uint256 borrowRateMagnifier_ = (IFluidVault(smartDebtVault_).readFromStorage(bytes32(uint256(1))) >> 16) & X16;\\n\\n        // in case of smart debt borrow magnifier bits stores borrow interest rate positive or negative\\n        // negative meaning incentivizing users, positive means charging users\\n        borrowRate_ = int256((borrowRateMagnifier_ >> 1) & X15);\\n        // if first bit == 1 then positive else negative\\n        if ((borrowRateMagnifier_ & 1) == 0) {\\n            borrowRate_ = -borrowRate_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x80b8ee5ace35fac660677bfc2cf6ac9c774e057e6e27bf57a68729d10a1cad2f\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/addressCalcs.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\n/// @notice implements calculation of address for contracts deployed through CREATE.\\n/// Accepts contract deployed from which address & nonce\\nlibrary AddressCalcs {\\n\\n    /// @notice                         Computes the address of a contract based\\n    /// @param deployedFrom_            Address from which the contract was deployed\\n    /// @param nonce_                   Nonce at which the contract was deployed\\n    /// @return contract_               Address of deployed contract\\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\\n        // @dev based on https://ethereum.stackexchange.com/a/61413\\n\\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\\n        // hence, nonce of vault deployment starts with 1.\\n        bytes memory data;\\n        if (nonce_ == 0x00) {\\n            return address(0);\\n        } else if (nonce_ <= 0x7f) {\\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\\n        } else if (nonce_ <= 0xff) {\\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\\n        } else if (nonce_ <= 0xffff) {\\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\\n        } else if (nonce_ <= 0xffffff) {\\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\\n        } else {\\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\\n        }\\n\\n        return address(uint160(uint256(keccak256(data))));\\n    }\\n\\n}\",\"keccak256\":\"0xed8e77dcf54703084c26a53b45d8139e5417488bc8f22a988c91b7813d132961\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/bigMathMinified.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\\n/// result in significant gas cost reduction due to storage space reduction.\\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\\nlibrary BigMathMinified {\\n    /// @dev constants to use for `roundUp` input param to increase readability\\n    bool internal constant ROUND_DOWN = false;\\n    bool internal constant ROUND_UP = true;\\n\\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\\n    /// e.g.:\\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\\n    /// exponent =                                            0011,0011     (51)\\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\\n    ///\\n    /// @param normal number which needs to be converted into Big Number\\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\\n    /// @param roundUp signals if result should be rounded down or up\\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\\n    function toBigNumber(\\n        uint256 normal,\\n        uint256 coefficientSize,\\n        uint256 exponentSize,\\n        bool roundUp\\n    ) internal pure returns (uint256 bigNumber) {\\n        assembly {\\n            let lastBit_\\n            let number_ := normal\\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit_ := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit_ := add(lastBit_, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit_ := add(lastBit_, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit_ := add(lastBit_, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit_ := add(lastBit_, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit_ := add(lastBit_, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit_ := add(lastBit_, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit_ := add(lastBit_, 1)\\n            }\\n            if lt(lastBit_, coefficientSize) {\\n                // for throw exception\\n                lastBit_ := coefficientSize\\n            }\\n            let exponent := sub(lastBit_, coefficientSize)\\n            let coefficient := shr(exponent, normal)\\n            if and(roundUp, gt(exponent, 0)) {\\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\\n                coefficient := add(coefficient, 1)\\n                if eq(shl(coefficientSize, 1), coefficient) {\\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\\n                    coefficient := shl(sub(coefficientSize, 1), 1)\\n                    exponent := add(exponent, 1)\\n                }\\n            }\\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\\n                // if exponent is >= exponentSize, the normal number is too big to fit within\\n                // BigNumber with too small sizes for coefficient and exponent\\n                revert(0, 0)\\n            }\\n            bigNumber := shl(exponentSize, coefficient)\\n            bigNumber := add(bigNumber, exponent)\\n        }\\n    }\\n\\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\\n    function fromBigNumber(\\n        uint256 bigNumber,\\n        uint256 exponentSize,\\n        uint256 exponentMask\\n    ) internal pure returns (uint256 normal) {\\n        assembly {\\n            let coefficient := shr(exponentSize, bigNumber)\\n            let exponent := and(bigNumber, exponentMask)\\n            normal := shl(exponent, coefficient)\\n        }\\n    }\\n\\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\\n    /// e.g.\\n    /// 5035703444687813576399584 = 10000101010010110100000011111011110010100110100000000011100101001101001101011100000\\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\\n        assembly {\\n            let number_ := normal\\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x80, number_)\\n                lastBit := 0x80\\n            }\\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\\n                number_ := shr(0x40, number_)\\n                lastBit := add(lastBit, 0x40)\\n            }\\n            if gt(number_, 0xFFFFFFFF) {\\n                number_ := shr(0x20, number_)\\n                lastBit := add(lastBit, 0x20)\\n            }\\n            if gt(number_, 0xFFFF) {\\n                number_ := shr(0x10, number_)\\n                lastBit := add(lastBit, 0x10)\\n            }\\n            if gt(number_, 0xFF) {\\n                number_ := shr(0x8, number_)\\n                lastBit := add(lastBit, 0x8)\\n            }\\n            if gt(number_, 0xF) {\\n                number_ := shr(0x4, number_)\\n                lastBit := add(lastBit, 0x4)\\n            }\\n            if gt(number_, 0x3) {\\n                number_ := shr(0x2, number_)\\n                lastBit := add(lastBit, 0x2)\\n            }\\n            if gt(number_, 0x1) {\\n                lastBit := add(lastBit, 1)\\n            }\\n            if gt(number_, 0) {\\n                lastBit := add(lastBit, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev gets the least significant bit `firstBit` of a `normal` number (position of rightmost 1 in binary format).\\n    /// e.g.\\n    /// 5035703444687813576399584 = 10000101010010110100000011111011110010100110100000000011100101001101001101011100000\\n    /// firstBit =                                                                                               ^-6--^\\n    function leastSignificantBit(uint256 normal) internal pure returns (uint firstBit) {\\n        assembly {\\n            // If number is 0, revert as there is no least significant bit\\n            if iszero(normal) {\\n                revert(0, 0)\\n            }\\n\\n            // Find first set bit using binary search\\n            let number_ := normal\\n            firstBit := 0\\n\\n            // Check if lower 128 bits are all zero\\n            if iszero(and(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) {\\n                number_ := shr(0x80, number_)\\n                firstBit := 0x80\\n            }\\n            // Check if lower 64 bits are all zero\\n            if iszero(and(number_, 0xFFFFFFFFFFFFFFFF)) {\\n                number_ := shr(0x40, number_)\\n                firstBit := add(firstBit, 0x40)\\n            }\\n            // Check if lower 32 bits are all zero\\n            if iszero(and(number_, 0xFFFFFFFF)) {\\n                number_ := shr(0x20, number_)\\n                firstBit := add(firstBit, 0x20)\\n            }\\n            // Check if lower 16 bits are all zero\\n            if iszero(and(number_, 0xFFFF)) {\\n                number_ := shr(0x10, number_)\\n                firstBit := add(firstBit, 0x10)\\n            }\\n            // Check if lower 8 bits are all zero\\n            if iszero(and(number_, 0xFF)) {\\n                number_ := shr(0x8, number_)\\n                firstBit := add(firstBit, 0x8)\\n            }\\n            // Check if lower 4 bits are all zero\\n            if iszero(and(number_, 0xF)) {\\n                number_ := shr(0x4, number_)\\n                firstBit := add(firstBit, 0x4)\\n            }\\n            // Check if lower 2 bits are all zero\\n            if iszero(and(number_, 0x3)) {\\n                number_ := shr(0x2, number_)\\n                firstBit := add(firstBit, 0x2)\\n            }\\n            // Check if lowest bit is zero\\n            if iszero(and(number_, 0x1)) {\\n                firstBit := add(firstBit, 1)\\n            }\\n            // Add 1 to match the 1-based position counting\\n            firstBit := add(firstBit, 1)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa3a52426cd052e70cdfe2e69d40430a26073971b8defaa9a6f31112b4f03600e\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nlibrary LibsErrorTypes {\\n    /***********************************|\\n    |         LiquidityCalcs            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\\n\\n    /// @notice thrown when rate data is set to a version that is not implemented\\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\\n\\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\\n\\n    /***********************************|\\n    |           SafeTransfer            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when safe transfer from for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\\n\\n    /// @notice thrown when safe transfer for an ERC20 fails\\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\\n\\n    /***********************************|\\n    |           SafeApprove             | \\n    |__________________________________*/\\n\\n    /// @notice thrown when safe approve from for an ERC20 fails\\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\\n}\\n\",\"keccak256\":\"0x4ae8d510a4119e20698381f323270ba219e66c03872e23073afff841e9b93a52\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/fluidProtocolTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\ninterface IFluidProtocol {\\n    function TYPE() external view returns (uint256);\\n}\\n\\n/// @notice implements helper methods to filter Fluid protocols by a certain type\\nlibrary FluidProtocolTypes {\\n    uint256 internal constant VAULT_T1_TYPE = 10000; // VaultT1 borrow protocol type vaults\\n    uint256 internal constant VAULT_T2_SMART_COL_TYPE = 20000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T3_SMART_DEBT_TYPE = 30000; // DEX protocol type vault\\n    uint256 internal constant VAULT_T4_SMART_COL_SMART_DEBT_TYPE = 40000; // DEX protocol type vault\\n\\n    /// @dev filters input `addresses_` by protocol `type_`. Input addresses must be actual Fluid protocols, otherwise\\n    ///      they would be wrongly assumed to be VaultT1 even if they are not Fluid VaultT1 smart contracts.\\n    ///      `type_` must be a listed constant type of this library.\\n    ///      Example usage is to filter all vault addresses at the Vault factory by a certain type, e.g. to not include\\n    ///      DEX protocol type vaults.\\n    function filterBy(address[] memory addresses_, uint256 type_) internal view returns (address[] memory filtered_) {\\n        uint256 curType_;\\n        uint256 filteredProtocols_ = addresses_.length;\\n        for (uint256 i; i < addresses_.length; ) {\\n            try IFluidProtocol(addresses_[i]).TYPE() returns (uint256 protocolType_) {\\n                curType_ = protocolType_;\\n            } catch {\\n                curType_ = VAULT_T1_TYPE;\\n            }\\n\\n            if (curType_ != type_) {\\n                addresses_[i] = address(0);\\n                --filteredProtocols_;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        filtered_ = new address[](filteredProtocols_);\\n        uint256 index_;\\n        unchecked {\\n            for (uint256 i; i < addresses_.length; ) {\\n                if (addresses_[i] != address(0)) {\\n                    filtered_[index_] = addresses_[i];\\n                    ++index_;\\n                }\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x771ae903f5dfd64e396466de61fb860369eeb70c7e0bc5edd2791a2d87522b02\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/safeTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.8.21 <=0.8.29;\\n\\nimport { LibsErrorTypes as ErrorTypes } from \\\"./errorTypes.sol\\\";\\n\\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\\nlibrary SafeTransfer {\\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\\n\\n    error FluidSafeTransferError(uint256 errorId_);\\n\\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from_\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to_\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \\\"amount_\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success_ := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\\n        }\\n    }\\n\\n    /// @dev Transfer `amount_` of `token_` to `to_`.\\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to_\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \\\"amount_\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success_ := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\\n        }\\n    }\\n\\n    /// @dev Transfer `amount_` of ` native token to `to_`.\\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\\n    function safeTransferNative(address to_, uint256 amount_) internal {\\n        bool success_;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\\n        }\\n\\n        if (!success_) {\\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd90c1f318d09b4d897c53e0c667bd297a55dd5317e6763499c93d20c1adf7c6d\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/libraries/tickMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.21 <=0.8.29;\\n\\n/// @title library that calculates number \\\"tick\\\" and \\\"ratioX96\\\" from this: ratioX96 = (1.0015^tick) * 2^96\\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\\n/// @dev \\\"tick\\\" supports between -32767 and 32767. \\\"ratioX96\\\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\\nlibrary TickMath {\\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\\n    int24 internal constant MIN_TICK = -32767;\\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\\n    int24 internal constant MAX_TICK = 32767;\\n\\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762 \\n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e;   // 2^128/1.0015**4096 = 733725103481409245883800626999235102\\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77;     // 2^128/1.0015**8192 = 1582075887005588088019997442108535\\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10;         // 2^128/1.0015**16384 = 7355550435635883087458926352\\n\\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\\n    uint256 internal constant MIN_RATIOX96 = 37075072;\\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\\n    uint256 internal constant MAX_RATIOX96 = 169307877264527972847801929085841449095838922544595;\\n\\n    uint256 internal constant ZERO_TICK_SCALED_RATIO = 0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\\n    uint256 internal constant _1E26 = 1e26;\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\\n        assembly {\\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\\n\\n            if gt(absTick_, MAX_TICK) {\\n                revert(0, 0)\\n            }\\n            let factor_ := FACTOR00\\n            if and(absTick_, 0x1) {\\n                factor_ := FACTOR01\\n            }\\n            if and(absTick_, 0x2) {\\n                factor_ := shr(128, mul(factor_, FACTOR02))\\n            }\\n            if and(absTick_, 0x4) {\\n                factor_ := shr(128, mul(factor_, FACTOR03))\\n            }\\n            if and(absTick_, 0x8) {\\n                factor_ := shr(128, mul(factor_, FACTOR04))\\n            }\\n            if and(absTick_, 0x10) {\\n                factor_ := shr(128, mul(factor_, FACTOR05))\\n            }\\n            if and(absTick_, 0x20) {\\n                factor_ := shr(128, mul(factor_, FACTOR06))\\n            }\\n            if and(absTick_, 0x40) {\\n                factor_ := shr(128, mul(factor_, FACTOR07))\\n            }\\n            if and(absTick_, 0x80) {\\n                factor_ := shr(128, mul(factor_, FACTOR08))\\n            }\\n            if and(absTick_, 0x100) {\\n                factor_ := shr(128, mul(factor_, FACTOR09))\\n            }\\n            if and(absTick_, 0x200) {\\n                factor_ := shr(128, mul(factor_, FACTOR10))\\n            }\\n            if and(absTick_, 0x400) {\\n                factor_ := shr(128, mul(factor_, FACTOR11))\\n            }\\n            if and(absTick_, 0x800) {\\n                factor_ := shr(128, mul(factor_, FACTOR12))\\n            }\\n            if and(absTick_, 0x1000) {\\n                factor_ := shr(128, mul(factor_, FACTOR13))\\n            }\\n            if and(absTick_, 0x2000) {\\n                factor_ := shr(128, mul(factor_, FACTOR14))\\n            }\\n            if and(absTick_, 0x4000) {\\n                factor_ := shr(128, mul(factor_, FACTOR15))\\n            }\\n\\n            let precision_ := 0\\n            if iszero(and(tick, 0x8000000000000000000000000000000000000000000000000000000000000000)) {\\n                factor_ := div(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, factor_)\\n                // we round up in the division so getTickAtRatio of the output price is always consistent\\n                if mod(factor_, 0x100000000) {\\n                    precision_ := 1\\n                }\\n            }\\n            ratioX96 := add(shr(32, factor_), precision_)\\n        }\\n    }\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\\n    /// @return perfectRatioX96 perfect ratio for the above tick\\n    function getTickAtRatio(uint256 ratioX96) internal pure returns (int tick, uint perfectRatioX96) {\\n        assembly {\\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\\n                revert(0, 0)\\n            }\\n\\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\\n            let factor_\\n\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\\n            }\\n\\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\\n\\n            // for tick = 16384\\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\\n            // 4626198540796508716348404308345255985.06131964639489434655721\\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\\n                tick := or(tick, 0x4000)\\n                factor_ := div(mul(factor_, _1E26), 4626198540796508716348404308345255985)\\n            }\\n            // for tick = 8192\\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\\n            // 21508599537851153911767490449162.3037648642153898377655505172\\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\\n                tick := or(tick, 0x2000)\\n                factor_ := div(mul(factor_, _1E26), 21508599537851153911767490449162)\\n            }\\n            // for tick = 4096\\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\\n            // 46377364670549310883002866648.9777607649742626173648716941385\\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\\n                tick := or(tick, 0x1000)\\n                factor_ := div(mul(factor_, _1E26), 46377364670549310883002866649)\\n            }\\n            // for tick = 2048\\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\\n            // 2153540449365864845468344760.06357108484096046743300420319322\\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\\n                tick := or(tick, 0x800)\\n                factor_ := div(mul(factor_, _1E26), 2153540449365864845468344760)\\n            }\\n            // for tick = 1024\\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\\n            // 464062544207767844008185024.950588990554136265212906454481127\\n            if iszero(lt(factor_, 464062544207767844008185025)) {\\n                tick := or(tick, 0x400)\\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\\n            }\\n            // for tick = 512\\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\\n            // 215421109505955298802281577.031879604792139232258508172947569\\n            if iszero(lt(factor_, 215421109505955298802281577)) {\\n                tick := or(tick, 0x200)\\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\\n            }\\n            // for tick = 256\\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\\n            // 146772309890508740607270614.667650899656438875541505058062410\\n            if iszero(lt(factor_, 146772309890508740607270615)) {\\n                tick := or(tick, 0x100)\\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\\n            }\\n            // for tick = 128\\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\\n            // 121149622323187099817270416.157248837742741760456796835775887\\n            if iszero(lt(factor_, 121149622323187099817270416)) {\\n                tick := or(tick, 0x80)\\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\\n            }\\n            // for tick = 64\\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\\n            // 110067989135437147685980801.568068573422377364214113968609839\\n            if iszero(lt(factor_, 110067989135437147685980801)) {\\n                tick := or(tick, 0x40)\\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\\n            }\\n            // for tick = 32\\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\\n            // 104913292358707887270979599.831816586773651266562785765558183\\n            if iszero(lt(factor_, 104913292358707887270979600)) {\\n                tick := or(tick, 0x20)\\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\\n            }\\n            // for tick = 16\\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\\n            // 102427189924701091191840927.762844039579442328381455567932128\\n            if iszero(lt(factor_, 102427189924701091191840928)) {\\n                tick := or(tick, 0x10)\\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\\n            }\\n            // for tick = 8\\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\\n            // 101206318935480056907421312.890625\\n            if iszero(lt(factor_, 101206318935480056907421313)) {\\n                tick := or(tick, 0x8)\\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\\n            }\\n            // for tick = 4\\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\\n            // 100601351350506250000000000\\n            if iszero(lt(factor_, 100601351350506250000000000)) {\\n                tick := or(tick, 0x4)\\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\\n            }\\n            // for tick = 2\\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\\n            // 100300225000000000000000000\\n            if iszero(lt(factor_, 100300225000000000000000000)) {\\n                tick := or(tick, 0x2)\\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\\n            }\\n            // for tick = 1\\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\\n            // 100150000000000000000000000\\n            if iszero(lt(factor_, 100150000000000000000000000)) {\\n                tick := or(tick, 0x1)\\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\\n            }\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                tick := not(tick)\\n                perfectRatioX96 := div(mul(ratioX96, factor_), 100150000000000000000000000)\\n            }\\n            // perfect ratio should always be <= ratioX96\\n            // not sure if it can ever be bigger but better to have extra checks\\n            if gt(perfectRatioX96, ratioX96) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ec1c1ecb5c506f2264675fa56dbb28481c2df15e4064d545d78e387f7c95b69\",\"license\":\"BUSL-1.1\"},\"contracts/oracle/error.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ncontract Error {\\n    error FluidOracleError(uint256 errorId_);\\n}\\n\",\"keccak256\":\"0xc7b7e945238168d216c480e9dd4fbaaf8780645d58c47f9abdaa4f29910568fe\",\"license\":\"BUSL-1.1\"},\"contracts/oracle/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary ErrorTypes {\\n    /***********************************|\\n    |           FluidOracleL2           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when sequencer on a L2 has an outage and grace period has not yet passed.\\n    uint256 internal constant FluidOracleL2__SequencerOutage = 60000;\\n\\n    /***********************************|\\n    |     UniV3CheckCLRSOracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the delta between main price source and check rate source is exceeding the allowed delta\\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidPrice = 60001;\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant UniV3CheckCLRSOracle__InvalidParams = 60002;\\n\\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\\n    uint256 internal constant UniV3CheckCLRSOracle__ExchangeRateZero = 60003;\\n\\n    /***********************************|\\n    |           FluidOracle             | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid info name is passed into a fluid oracle (e.g. not set or too long)\\n    uint256 internal constant FluidOracle__InvalidInfoName = 60010;\\n\\n    /***********************************|\\n    |            sUSDe Oracle           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant SUSDeOracle__InvalidParams = 60102;\\n\\n    /***********************************|\\n    |           Pendle Oracle           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant PendleOracle__InvalidParams = 60201;\\n\\n    /// @notice thrown when the Pendle market Oracle has not been initialized yet\\n    uint256 internal constant PendleOracle__MarketNotInitialized = 60202;\\n\\n    /// @notice thrown when the Pendle market does not have 18 decimals\\n    uint256 internal constant PendleOracle__MarketInvalidDecimals = 60203;\\n\\n    /// @notice thrown when the Pendle market returns an unexpected price\\n    uint256 internal constant PendleOracle__InvalidPrice = 60204;\\n\\n    /***********************************|\\n    |    CLRS2UniV3CheckCLRSOracleL2    | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\\n    uint256 internal constant CLRS2UniV3CheckCLRSOracleL2__ExchangeRateZero = 60301;\\n\\n    /***********************************|\\n    |    Ratio2xFallbackCLRSOracleL2    | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\\n    uint256 internal constant Ratio2xFallbackCLRSOracleL2__ExchangeRateZero = 60311;\\n\\n    /***********************************|\\n    |            WeETHsOracle           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant WeETHsOracle__InvalidParams = 60321;\\n\\n    /***********************************|\\n    |        DexSmartColOracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant DexSmartColOracle__InvalidParams = 60331;\\n\\n    /// @notice thrown when smart col is not enabled\\n    uint256 internal constant DexSmartColOracle__SmartColNotEnabled = 60332;\\n\\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\\n    uint256 internal constant DexSmartColOracle__ExchangeRateZero = 60333;\\n\\n    /***********************************|\\n    |        DexSmartDebtOracle         | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant DexSmartDebtOracle__InvalidParams = 60341;\\n\\n    /// @notice thrown when smart debt is not enabled\\n    uint256 internal constant DexSmartDebtOracle__SmartDebtNotEnabled = 60342;\\n\\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\\n    uint256 internal constant DexSmartDebtOracle__ExchangeRateZero = 60343;\\n\\n    /***********************************|\\n    |            CappedRate           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant CappedRate__InvalidParams = 60351;\\n\\n    /// @notice thrown when caller is not authorized\\n    uint256 internal constant CappedRate__Unauthorized = 60352;\\n\\n    /// @notice thrown when minimum diff for triggering update on the stared rate is not reached\\n    uint256 internal constant CappedRate__MinUpdateDiffNotReached = 60353;\\n\\n    /// @notice thrown when the external rate source returns 0 for the new rate\\n    uint256 internal constant CappedRate__NewRateZero = 60354;\\n\\n    /// @notice thrown when the new rate source does not fit in 192 bit storage uint, should never happen.\\n    uint256 internal constant CappedRate__StorageOverflow = 60355;\\n\\n    /***********************************|\\n    |            sUSDs Oracle           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant SUSDsOracle__InvalidParams = 60361;\\n\\n    /***********************************|\\n    |            Peg Oracle             | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant PegOracle__InvalidParams = 60371;\\n\\n    /***********************************|\\n    |              DexOracle            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant DexOracle__InvalidParams = 60381;\\n\\n    /// @notice thrown when the exchange rate is zero, even after all possible fallbacks depending on config\\n    uint256 internal constant DexOracle__ExchangeRateZero = 60382;\\n\\n    /***********************************|\\n    |           GenericOracle           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant GenericOracle__InvalidParams = 60401;\\n\\n    /// @notice thrown when reaching an unexepcted config state\\n    uint256 internal constant GenericOracle__UnexpectedConfig = 60402;\\n\\n    /// @notice thrown when the exchange rate is zero\\n    uint256 internal constant GenericOracle__RateZero = 60403;\\n\\n    /***********************************|\\n    |             CenterPrice           | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant CenterPrice__InvalidParams = 60421;\\n\\n    /***********************************|\\n    |          Chainlink Oracle         | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant ChainlinkOracle__InvalidParams = 61001;\\n\\n    /***********************************|\\n    |          UniswapV3 Oracle         | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant UniV3Oracle__InvalidParams = 62001;\\n\\n    /// @notice thrown when constructor is called with invalid ordered seconds agos values\\n    uint256 internal constant UniV3Oracle__InvalidSecondsAgos = 62002;\\n\\n    /// @notice thrown when constructor is called with invalid delta values > 100%\\n    uint256 internal constant UniV3Oracle__InvalidDeltas = 62003;\\n\\n    /***********************************|\\n    |            WstETh Oracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant WstETHOracle__InvalidParams = 63001;\\n\\n    /***********************************|\\n    |           Redstone Oracle         | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant RedstoneOracle__InvalidParams = 64001;\\n\\n    /***********************************|\\n    |          Fallback Oracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant FallbackOracle__InvalidParams = 65001;\\n\\n    /***********************************|\\n    |       FallbackCLRSOracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\\n    uint256 internal constant FallbackCLRSOracle__ExchangeRateZero = 66001;\\n\\n    /***********************************|\\n    |         WstETHCLRSOracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even for the fallback oracle source (if enabled)\\n    uint256 internal constant WstETHCLRSOracle__ExchangeRateZero = 67001;\\n\\n    /***********************************|\\n    |        CLFallbackUniV3Oracle      | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\\n    uint256 internal constant CLFallbackUniV3Oracle__ExchangeRateZero = 68001;\\n\\n    /***********************************|\\n    |  WstETHCLRS2UniV3CheckCLRSOracle  | \\n    |__________________________________*/\\n\\n    /// @notice thrown when the exchange rate is zero, even for the uniV3 rate\\n    uint256 internal constant WstETHCLRS2UniV3CheckCLRSOracle__ExchangeRateZero = 69001;\\n\\n    /***********************************|\\n    |             WeETh Oracle          | \\n    |__________________________________*/\\n\\n    /// @notice thrown when an invalid parameter is passed to a method\\n    uint256 internal constant WeETHOracle__InvalidParams = 70001;\\n}\\n\",\"keccak256\":\"0x378bf695c75ebc27abc25805a5df0d869cace4dabdea356b85e4e2b066196211\",\"license\":\"BUSL-1.1\"},\"contracts/oracle/fluidOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IFluidOracle } from \\\"./interfaces/iFluidOracle.sol\\\";\\nimport { ErrorTypes } from \\\"./errorTypes.sol\\\";\\nimport { Error as OracleError } from \\\"./error.sol\\\";\\n\\n/// @title   FluidOracle\\n/// @notice  Base contract that any Fluid Oracle must implement\\nabstract contract FluidOracle is IFluidOracle, OracleError {\\n    /// @dev short helper string to easily identify the oracle. E.g. token symbols\\n    //\\n    // using a bytes32 because string can not be immutable.\\n    bytes32 private immutable _infoName;\\n\\n    /// @dev target decimals of the oracle when scaling to 1e27. E.g. for ETH / USDC it would be 15\\n    /// because diff of ETH decimals to 1e27 is 9, and USDC has 6 decimals, so 6+9 = 15, e.g. 2029,047772120364926\\n    /// For USDC / ETH: 21 + 18 = 39, e.g. 0,000492842018675092636829357843847601646\\n    uint8 private immutable _targetDecimals;\\n\\n    constructor(string memory infoName_, uint8 targetDecimals_) {\\n        if (bytes(infoName_).length > 32 || bytes(infoName_).length == 0) {\\n            revert FluidOracleError(ErrorTypes.FluidOracle__InvalidInfoName);\\n        }\\n\\n        if (targetDecimals_ < 15 || targetDecimals_ > 39) {\\n            revert FluidOracleError(ErrorTypes.GenericOracle__InvalidParams);\\n        }\\n        _targetDecimals = targetDecimals_;\\n\\n        // convert string to bytes32\\n        bytes32 infoNameBytes32_;\\n        assembly {\\n            infoNameBytes32_ := mload(add(infoName_, 32))\\n        }\\n        _infoName = infoNameBytes32_;\\n    }\\n\\n    /// @inheritdoc IFluidOracle\\n    function targetDecimals() external view returns (uint8) {\\n        return _targetDecimals;\\n    }\\n\\n    /// @inheritdoc IFluidOracle\\n    function infoName() external view returns (string memory) {\\n        // convert bytes32 to string\\n        uint256 length_;\\n        while (length_ < 32 && _infoName[length_] != 0) {\\n            length_++;\\n        }\\n        bytes memory infoNameBytes_ = new bytes(length_);\\n        for (uint256 i; i < length_; i++) {\\n            infoNameBytes_[i] = _infoName[i];\\n        }\\n        return string(infoNameBytes_);\\n    }\\n\\n    /// @inheritdoc IFluidOracle\\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\\n\\n    /// @inheritdoc IFluidOracle\\n    function getExchangeRateOperate() external view virtual returns (uint256 exchangeRate_);\\n\\n    /// @inheritdoc IFluidOracle\\n    function getExchangeRateLiquidate() external view virtual returns (uint256 exchangeRate_);\\n}\\n\",\"keccak256\":\"0xd37e225d45e688664c382b193f37342eebc6d28486f4a15f2687f0728f16d469\",\"license\":\"BUSL-1.1\"},\"contracts/oracle/interfaces/iFluidOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidOracle {\\n    /// @dev Deprecated. Use `getExchangeRateOperate()` and `getExchangeRateLiquidate()` instead. Only implemented for\\n    ///      backwards compatibility.\\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\\n\\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for operates\\n    function getExchangeRateOperate() external view returns (uint256 exchangeRate_);\\n\\n    /// @notice Get the `exchangeRate_` between the underlying asset and the peg asset in 1e27 for liquidations\\n    function getExchangeRateLiquidate() external view returns (uint256 exchangeRate_);\\n\\n    /// @notice helper string to easily identify the oracle. E.g. token symbols\\n    function infoName() external view returns (string memory);\\n\\n    /// @notice target decimals of the returned oracle rate when scaling to 1e27. E.g. for ETH / USDC it would be 15\\n    /// because diff of ETH decimals to 1e27 is 9, and USDC has 6 decimals, so 6+9 = 15, e.g. 2029,047772120364926\\n    /// For USDC / ETH: 21 + 18 = 39, e.g. 0,000492842018675092636829357843847601646\\n    function targetDecimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x5a3e03e09a8341bbd9c05de490fe49bcfba960865bd8dd818d38b198559d539f\",\"license\":\"MIT\"},\"contracts/protocols/vault/error.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Error {\\n    error FluidVaultError(uint256 errorId_);\\n\\n    /// @notice used to simulate liquidation to find the maximum liquidatable amounts\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n}\\n\",\"keccak256\":\"0x3109fe35234c0428642d43e70b56bcdbbfeef1d9e5ca29f4c8b8a181d7b8d83c\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/errorTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nlibrary ErrorTypes {\\n    /***********************************|\\n    |           Vault Factory           | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultFactory__InvalidOperation = 30001;\\n    uint256 internal constant VaultFactory__Unauthorized = 30002;\\n    uint256 internal constant VaultFactory__SameTokenNotAllowed = 30003;\\n    uint256 internal constant VaultFactory__InvalidParams = 30004;\\n    uint256 internal constant VaultFactory__InvalidVault = 30005;\\n    uint256 internal constant VaultFactory__InvalidVaultAddress = 30006;\\n    uint256 internal constant VaultFactory__OnlyDelegateCallAllowed = 30007;\\n\\n    /***********************************|\\n    |            Vault                  | \\n    |__________________________________*/\\n\\n    /// @notice thrown at reentrancy\\n    uint256 internal constant Vault__AlreadyEntered = 31001;\\n\\n    /// @notice thrown when user sends deposit & borrow amount as 0\\n    uint256 internal constant Vault__InvalidOperateAmount = 31002;\\n\\n    /// @notice thrown when msg.value is not in sync with native token deposit or payback\\n    uint256 internal constant Vault__InvalidMsgValueOperate = 31003;\\n\\n    /// @notice thrown when msg.sender is not the owner of the vault\\n    uint256 internal constant Vault__NotAnOwner = 31004;\\n\\n    /// @notice thrown when user's position does not exist. Sending the wrong index from the frontend\\n    uint256 internal constant Vault__TickIsEmpty = 31005;\\n\\n    /// @notice thrown when the user's position is above CF and the user tries to make it more risky by trying to withdraw or borrow\\n    uint256 internal constant Vault__PositionAboveCF = 31006;\\n\\n    /// @notice thrown when the top tick is not initialized. Happens if the vault is totally new or all the user's left\\n    uint256 internal constant Vault__TopTickDoesNotExist = 31007;\\n\\n    /// @notice thrown when msg.value in liquidate is not in sync payback\\n    uint256 internal constant Vault__InvalidMsgValueLiquidate = 31008;\\n\\n    /// @notice thrown when slippage is more on liquidation than what the liquidator sent\\n    uint256 internal constant Vault__ExcessSlippageLiquidation = 31009;\\n\\n    /// @notice thrown when msg.sender is not the rebalancer/reserve contract\\n    uint256 internal constant Vault__NotRebalancer = 31010;\\n\\n    /// @notice thrown when NFT of one vault interacts with the NFT of other vault\\n    uint256 internal constant Vault__NftNotOfThisVault = 31011;\\n\\n    /// @notice thrown when the token is not initialized on the liquidity contract\\n    uint256 internal constant Vault__TokenNotInitialized = 31012;\\n\\n    /// @notice thrown when admin updates fallback if a non-auth calls vault\\n    uint256 internal constant Vault__NotAnAuth = 31013;\\n\\n    /// @notice thrown in operate when user tries to witdhraw more collateral than deposited\\n    uint256 internal constant Vault__ExcessCollateralWithdrawal = 31014;\\n\\n    /// @notice thrown in operate when user tries to payback more debt than borrowed\\n    uint256 internal constant Vault__ExcessDebtPayback = 31015;\\n\\n    /// @notice thrown when user try to withdrawal more than operate's withdrawal limit\\n    uint256 internal constant Vault__WithdrawMoreThanOperateLimit = 31016;\\n\\n    /// @notice thrown when caller of liquidityCallback is not Liquidity\\n    uint256 internal constant Vault__InvalidLiquidityCallbackAddress = 31017;\\n\\n    /// @notice thrown when reentrancy is not already on\\n    uint256 internal constant Vault__NotEntered = 31018;\\n\\n    /// @notice thrown when someone directly calls operate or secondary implementation contract\\n    uint256 internal constant Vault__OnlyDelegateCallAllowed = 31019;\\n\\n    /// @notice thrown when the safeTransferFrom for a token amount failed\\n    uint256 internal constant Vault__TransferFromFailed = 31020;\\n\\n    /// @notice thrown when exchange price overflows while updating on storage\\n    uint256 internal constant Vault__ExchangePriceOverFlow = 31021;\\n\\n    /// @notice thrown when debt to liquidate amt is sent wrong\\n    uint256 internal constant Vault__InvalidLiquidationAmt = 31022;\\n\\n    /// @notice thrown when user debt or collateral goes above 2**128 or below -2**128\\n    uint256 internal constant Vault__UserCollateralDebtExceed = 31023;\\n\\n    /// @notice thrown if on liquidation branch debt becomes lower than 100\\n    uint256 internal constant Vault__BranchDebtTooLow = 31024;\\n\\n    /// @notice thrown when tick's debt is less than 10000\\n    uint256 internal constant Vault__TickDebtTooLow = 31025;\\n\\n    /// @notice thrown when the received new liquidity exchange price is of unexpected value (< than the old one)\\n    uint256 internal constant Vault__LiquidityExchangePriceUnexpected = 31026;\\n\\n    /// @notice thrown when user's debt is less than 10000\\n    uint256 internal constant Vault__UserDebtTooLow = 31027;\\n\\n    /// @notice thrown when on only payback and only deposit the ratio of position increases\\n    uint256 internal constant Vault__InvalidPaybackOrDeposit = 31028;\\n\\n    /// @notice thrown when liquidation just happens of a single partial or when there's nothing to liquidate\\n    uint256 internal constant Vault__InvalidLiquidation = 31029;\\n\\n    /// @notice thrown when msg.value is sent wrong in rebalance\\n    uint256 internal constant Vault__InvalidMsgValueInRebalance = 31030;\\n\\n    /// @notice thrown when nothing rebalanced\\n    uint256 internal constant Vault__NothingToRebalance = 31031;\\n\\n    /// @notice thrown on unforseen liquidation scenarios. Might never come in use.\\n    uint256 internal constant Vault__LiquidationReverts = 31032;\\n\\n    /// @notice thrown when oracle price is > 1e54\\n    uint256 internal constant Vault__InvalidOraclePrice = 31033;\\n\\n    /// @notice thrown when constants are not set properly via contructor\\n    uint256 internal constant Vault__ImproperConstantsSetup = 31034;\\n\\n    /// @notice thrown when externally calling fetchLatestPosition function\\n    uint256 internal constant Vault__FetchLatestPositionFailed = 31035;\\n\\n    /// @notice thrown when dex callback is not from dex\\n    uint256 internal constant Vault__InvalidDexCallbackAddress = 31036;\\n\\n    /// @notice thrown when dex callback is already set\\n    uint256 internal constant Vault__DexFromAddressAlreadySet = 31037;\\n\\n    /// @notice thrown when an invalid min / max amounts config is passed to rebalance()\\n    uint256 internal constant Vault__InvalidMinMaxInRebalance = 31038;\\n\\n    /***********************************|\\n    |              ERC721               | \\n    |__________________________________*/\\n\\n    uint256 internal constant ERC721__InvalidParams = 32001;\\n    uint256 internal constant ERC721__Unauthorized = 32002;\\n    uint256 internal constant ERC721__InvalidOperation = 32003;\\n    uint256 internal constant ERC721__UnsafeRecipient = 32004;\\n    uint256 internal constant ERC721__OutOfBoundsIndex = 32005;\\n\\n    /***********************************|\\n    |            Vault Admin            | \\n    |__________________________________*/\\n\\n    /// @notice thrown when admin tries to setup invalid value which are crossing limits\\n    uint256 internal constant VaultAdmin__ValueAboveLimit = 33001;\\n\\n    /// @notice when someone directly calls admin implementation contract\\n    uint256 internal constant VaultAdmin__OnlyDelegateCallAllowed = 33002;\\n\\n    /// @notice thrown when auth sends NFT ID as 0 while collecting dust debt\\n    uint256 internal constant VaultAdmin__NftIdShouldBeNonZero = 33003;\\n\\n    /// @notice thrown when trying to collect dust debt of NFT which is not of this vault\\n    uint256 internal constant VaultAdmin__NftNotOfThisVault = 33004;\\n\\n    /// @notice thrown when dust debt of NFT is 0, meaning nothing to collect\\n    uint256 internal constant VaultAdmin__DustDebtIsZero = 33005;\\n\\n    /// @notice thrown when final debt after liquidation is not 0, meaning position 100% liquidated\\n    uint256 internal constant VaultAdmin__FinalDebtShouldBeZero = 33006;\\n\\n    /// @notice thrown when NFT is not liquidated state\\n    uint256 internal constant VaultAdmin__NftNotLiquidated = 33007;\\n\\n    /// @notice thrown when total absorbed dust debt is 0\\n    uint256 internal constant VaultAdmin__AbsorbedDustDebtIsZero = 33008;\\n\\n    /// @notice thrown when address is set as 0\\n    uint256 internal constant VaultAdmin__AddressZeroNotAllowed = 33009;\\n\\n    /***********************************|\\n    |            Vault Rewards          | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultRewards__Unauthorized = 34001;\\n    uint256 internal constant VaultRewards__AddressZero = 34002;\\n    uint256 internal constant VaultRewards__InvalidParams = 34003;\\n    uint256 internal constant VaultRewards__NewMagnifierSameAsOldMagnifier = 34004;\\n    uint256 internal constant VaultRewards__NotTheInitiator = 34005;\\n    uint256 internal constant VaultRewards__NotTheGovernance = 34006;\\n    uint256 internal constant VaultRewards__AlreadyStarted = 34007;\\n    uint256 internal constant VaultRewards__RewardsNotStartedOrEnded = 34008;\\n    uint256 internal constant VaultRewards__InvalidStartTime = 34009;\\n    uint256 internal constant VaultRewards__AlreadyEnded = 34010;\\n\\n    /***********************************|\\n    |          Vault DEX Types          | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultDex__InvalidOperateAmount = 35001;\\n    uint256 internal constant VaultDex__DebtSharesPaidMoreThanAvailableLiquidation = 35002;\\n\\n    /***********************************|\\n    |        Vault Borrow Rewards       | \\n    |__________________________________*/\\n\\n    uint256 internal constant VaultBorrowRewards__Unauthorized = 36001;\\n    uint256 internal constant VaultBorrowRewards__AddressZero = 36002;\\n    uint256 internal constant VaultBorrowRewards__InvalidParams = 36003;\\n    uint256 internal constant VaultBorrowRewards__NewMagnifierSameAsOldMagnifier = 36004;\\n    uint256 internal constant VaultBorrowRewards__NotTheInitiator = 36005;\\n    uint256 internal constant VaultBorrowRewards__NotTheGovernance = 36006;\\n    uint256 internal constant VaultBorrowRewards__AlreadyStarted = 36007;\\n    uint256 internal constant VaultBorrowRewards__RewardsNotStartedOrEnded = 36008;\\n    uint256 internal constant VaultBorrowRewards__InvalidStartTime = 36009;\\n    uint256 internal constant VaultBorrowRewards__AlreadyEnded = 36010;\\n}\\n\",\"keccak256\":\"0x60266494213793e62a94cf7989487939e4e88aeb052150c4dc17dbfb1648693d\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/interfaces/iVault.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/// @notice common Fluid vaults interface, some methods only available for vaults > T1 (type, simulateLiquidate, rebalance is different)\\ninterface IFluidVault {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice returns the vault id\\n    function TYPE() external view returns (uint256);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct Tokens {\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address operateImplementation;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address deployer; // address which deploys oracle\\n        address supply; // either liquidity layer or DEX protocol\\n        address borrow; // either liquidity layer or DEX protocol\\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\\n        uint256 vaultId;\\n        uint256 vaultType;\\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n\\n    function rebalance(\\n        int colToken0MinMax_,\\n        int colToken1MinMax_,\\n        int debtToken0MinMax_,\\n        int debtToken1MinMax_\\n    ) external payable returns (int supplyAmt_, int borrowAmt_);\\n\\n    /// @notice reverts with FluidLiquidateResult\\n    function simulateLiquidate(uint debtAmt_, bool absorb_) external;\\n}\\n\",\"keccak256\":\"0xdd764652f8451a71d2f2006b2572fccd9c21f1d64196869bfc291d10f151f0c6\",\"license\":\"MIT\"},\"contracts/protocols/vault/interfaces/iVaultT1.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IFluidVaultT1 {\\n    /// @notice returns the vault id\\n    function VAULT_ID() external view returns (uint256);\\n\\n    /// @notice returns the vault factory address\\n    function VAULT_FACTORY() external view returns (address);\\n\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\\n\\n    struct ConstantViews {\\n        address liquidity;\\n        address factory;\\n        address adminImplementation;\\n        address secondaryImplementation;\\n        address supplyToken;\\n        address borrowToken;\\n        uint8 supplyDecimals;\\n        uint8 borrowDecimals;\\n        uint vaultId;\\n        bytes32 liquiditySupplyExchangePriceSlot;\\n        bytes32 liquidityBorrowExchangePriceSlot;\\n        bytes32 liquidityUserSupplySlot;\\n        bytes32 liquidityUserBorrowSlot;\\n    }\\n\\n    /// @notice returns all Vault constants\\n    function constantsView() external view returns (ConstantViews memory constantsView_);\\n\\n    /// @notice fetches the latest user position after a liquidation\\n    function fetchLatestPosition(\\n        int256 positionTick_,\\n        uint256 positionTickId_,\\n        uint256 positionRawDebt_,\\n        uint256 tickData_\\n    )\\n        external\\n        view\\n        returns (\\n            int256, // tick\\n            uint256, // raw debt\\n            uint256, // raw collateral\\n            uint256, // branchID_\\n            uint256 // branchData_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice calculates the updated vault exchange prices and writes them to storage\\n    function updateExchangePricesOnStorage()\\n        external\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    /// @notice returns the liquidity contract address\\n    function LIQUIDITY() external view returns (address);\\n\\n    function operate(\\n        uint256 nftId_, // if 0 then new position\\n        int256 newCol_, // if negative then withdraw\\n        int256 newDebt_, // if negative then payback\\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256, // nftId_\\n            int256, // final supply amount. if - then withdraw\\n            int256 // final borrow amount. if - then payback\\n        );\\n\\n    function liquidate(\\n        uint256 debtAmt_,\\n        uint256 colPerUnitDebt_, // min collateral needed per unit of debt in 1e18\\n        address to_,\\n        bool absorb_\\n    ) external payable returns (uint actualDebtAmt_, uint actualColAmt_);\\n\\n    function absorb() payable external;\\n\\n    function rebalance() external payable returns (int supplyAmt_, int borrowAmt_);\\n\\n    error FluidLiquidateResult(uint256 colLiquidated, uint256 debtLiquidated);\\n}\\n\",\"keccak256\":\"0x1d81c36ec35f5929975a91401a3ee00d08f2a7b3d5cf3adc2a3ac1ea02facfd3\",\"license\":\"MIT\"},\"contracts/protocols/vault/vaultT1/adminModule/events.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ncontract Events {\\n    /// @notice emitted when the supply rate magnifier config is updated\\n    event LogUpdateSupplyRateMagnifier(uint supplyRateMagnifier_);\\n\\n    /// @notice emitted when the borrow rate magnifier config is updated\\n    event LogUpdateBorrowRateMagnifier(uint borrowRateMagnifier_);\\n\\n    /// @notice emitted when the collateral factor config is updated\\n    event LogUpdateCollateralFactor(uint collateralFactor_);\\n\\n    /// @notice emitted when the liquidation threshold config is updated\\n    event LogUpdateLiquidationThreshold(uint liquidationThreshold_);\\n\\n    /// @notice emitted when the liquidation max limit config is updated\\n    event LogUpdateLiquidationMaxLimit(uint liquidationMaxLimit_);\\n\\n    /// @notice emitted when the withdrawal gap config is updated\\n    event LogUpdateWithdrawGap(uint withdrawGap_);\\n\\n    /// @notice emitted when the liquidation penalty config is updated\\n    event LogUpdateLiquidationPenalty(uint liquidationPenalty_);\\n\\n    /// @notice emitted when the borrow fee config is updated\\n    event LogUpdateBorrowFee(uint borrowFee_);\\n\\n    /// @notice emitted when the core setting configs are updated\\n    event LogUpdateCoreSettings(\\n        uint supplyRateMagnifier_,\\n        uint borrowRateMagnifier_,\\n        uint collateralFactor_,\\n        uint liquidationThreshold_,\\n        uint liquidationMaxLimit_,\\n        uint withdrawGap_,\\n        uint liquidationPenalty_,\\n        uint borrowFee_\\n    );\\n\\n    /// @notice emitted when the oracle is updated\\n    event LogUpdateOracle(address indexed newOracle_);\\n\\n    /// @notice emitted when the allowed rebalancer is updated\\n    event LogUpdateRebalancer(address indexed newRebalancer_);\\n\\n    /// @notice emitted when funds are rescued\\n    event LogRescueFunds(address indexed token_);\\n\\n    /// @notice emitted when dust debt is absorbed for `nftIds_`\\n    event LogAbsorbDustDebt(uint256[] nftIds_, uint256 absorbedDustDebt_);\\n}\\n\",\"keccak256\":\"0x9e9171a80cc4fcaeb36d92794e0bd4fb3665e58f7e6e2a157e7dada107a47d41\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultT1/adminModule/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport { Variables } from \\\"../common/variables.sol\\\";\\nimport { Events } from \\\"./events.sol\\\";\\nimport { ErrorTypes } from \\\"../../errorTypes.sol\\\";\\nimport { Error } from \\\"../../error.sol\\\";\\nimport { IFluidVaultT1 } from \\\"../../interfaces/iVaultT1.sol\\\";\\nimport { BigMathMinified } from \\\"../../../../libraries/bigMathMinified.sol\\\";\\nimport { TickMath } from \\\"../../../../libraries/tickMath.sol\\\";\\nimport { SafeTransfer } from \\\"../../../../libraries/safeTransfer.sol\\\";\\n\\n/// @notice Fluid Vault protocol Admin Module contract.\\n///         Implements admin related methods to set configs such as liquidation params, rates\\n///         oracle address etc.\\n///         Methods are limited to be called via delegateCall only. Vault CoreModule (\\\"VaultT1\\\" contract)\\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\\n///         All methods update the exchange prices in storage before changing configs.\\ncontract FluidVaultT1Admin is Variables, Events, Error {\\n    uint private constant X8 = 0xff;\\n    uint private constant X10 = 0x3ff;\\n    uint private constant X16 = 0xffff;\\n    uint private constant X19 = 0x7ffff;\\n    uint private constant X24 = 0xffffff;\\n    uint internal constant X64 = 0xffffffffffffffff;\\n    uint private constant X96 = 0xffffffffffffffffffffffff;\\n    address private constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    address private immutable addressThis;\\n\\n    constructor() {\\n        addressThis = address(this);\\n    }\\n\\n    modifier _verifyCaller() {\\n        if (address(this) == addressThis) {\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__OnlyDelegateCallAllowed);\\n        }\\n        _;\\n    }\\n\\n    /// @dev updates exchange price on storage, called on all admin methods in combination with _verifyCaller modifier so\\n    /// only called by authorized delegatecall\\n    modifier _updateExchangePrice() {\\n        IFluidVaultT1(address(this)).updateExchangePricesOnStorage();\\n        _;\\n    }\\n\\n    function _checkLiquidationMaxLimitAndPenalty(uint liquidationMaxLimit_, uint liquidationPenalty_) private pure {\\n        // liquidation max limit with penalty should not go above 99.7%\\n        // As liquidation with penalty can happen from liquidation Threshold to max limit\\n        // If it goes above 100% than that means liquidator is getting more collateral than user's available\\n        if ((liquidationMaxLimit_ + liquidationPenalty_) > 9970) {\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n        }\\n    }\\n\\n    /// @notice updates the supply rate magnifier to `supplyRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateSupplyRateMagnifier(uint supplyRateMagnifier_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateSupplyRateMagnifier(supplyRateMagnifier_);\\n\\n        if (supplyRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\\n            supplyRateMagnifier_;\\n    }\\n\\n    /// @notice updates the borrow rate magnifier to `borrowRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateBorrowRateMagnifier(uint borrowRateMagnifier_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateBorrowRateMagnifier(borrowRateMagnifier_);\\n\\n        if (borrowRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\\n            (borrowRateMagnifier_ << 16);\\n    }\\n\\n    /// @notice updates the collateral factor to `collateralFactor_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateCollateralFactor(uint collateralFactor_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateCollateralFactor(collateralFactor_);\\n\\n        uint vaultVariables2_ = vaultVariables2;\\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\\n\\n        collateralFactor_ = collateralFactor_ / 10;\\n\\n        if (collateralFactor_ >= liquidationThreshold_) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffc00ffffffff) |\\n            (collateralFactor_ << 32);\\n    }\\n\\n    /// @notice updates the liquidation threshold to `liquidationThreshold_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateLiquidationThreshold(uint liquidationThreshold_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateLiquidationThreshold(liquidationThreshold_);\\n\\n        uint vaultVariables2_ = vaultVariables2;\\n        uint collateralFactor_ = ((vaultVariables2_ >> 32) & X10);\\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\\n\\n        liquidationThreshold_ = liquidationThreshold_ / 10;\\n\\n        if ((collateralFactor_ >= liquidationThreshold_) || (liquidationThreshold_ >= liquidationMaxLimit_))\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffff003ffffffffff) |\\n            (liquidationThreshold_ << 42);\\n    }\\n\\n    /// @notice updates the liquidation max limit to `liquidationMaxLimit_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateLiquidationMaxLimit(uint liquidationMaxLimit_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateLiquidationMaxLimit(liquidationMaxLimit_);\\n\\n        uint vaultVariables2_ = vaultVariables2;\\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\\n        uint liquidationPenalty_ = ((vaultVariables2_ >> 72) & X10);\\n\\n        // both are in 1e2 decimals (1e2 = 1%)\\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\\n\\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\\n\\n        if (liquidationThreshold_ >= liquidationMaxLimit_)\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffc00fffffffffffff) |\\n            (liquidationMaxLimit_ << 52);\\n    }\\n\\n    /// @notice updates the withdrawal gap to `withdrawGap_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateWithdrawGap(uint withdrawGap_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateWithdrawGap(withdrawGap_);\\n\\n        withdrawGap_ = withdrawGap_ / 10;\\n\\n        // withdrawGap must not be > 100%\\n        if (withdrawGap_ > 1000) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffff003fffffffffffffff) |\\n            (withdrawGap_ << 62);\\n    }\\n\\n    /// @notice updates the liquidation penalty to `liquidationPenalty_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateLiquidationPenalty(uint liquidationPenalty_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateLiquidationPenalty(liquidationPenalty_);\\n\\n        uint vaultVariables2_ = vaultVariables2;\\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\\n\\n        // Converting liquidationMaxLimit_ in 1e2 decimals (1e2 = 1%)\\n        _checkLiquidationMaxLimitAndPenalty((liquidationMaxLimit_ * 10), liquidationPenalty_);\\n\\n        if (liquidationPenalty_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00ffffffffffffffffff) |\\n            (liquidationPenalty_ << 72);\\n    }\\n\\n    /// @notice updates the borrow fee to `borrowFee_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateBorrowFee(uint borrowFee_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateBorrowFee(borrowFee_);\\n\\n        if (borrowFee_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff003ffffffffffffffffffff) |\\n            (borrowFee_ << 82);\\n    }\\n\\n    /// @notice updates the all Vault core settings according to input params.\\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\\n    function updateCoreSettings(\\n        uint256 supplyRateMagnifier_,\\n        uint256 borrowRateMagnifier_,\\n        uint256 collateralFactor_,\\n        uint256 liquidationThreshold_,\\n        uint256 liquidationMaxLimit_,\\n        uint256 withdrawGap_,\\n        uint256 liquidationPenalty_,\\n        uint256 borrowFee_\\n    ) public _updateExchangePrice _verifyCaller {\\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\\n        emit LogUpdateCoreSettings(\\n            supplyRateMagnifier_,\\n            borrowRateMagnifier_,\\n            collateralFactor_,\\n            liquidationThreshold_,\\n            liquidationMaxLimit_,\\n            withdrawGap_,\\n            liquidationPenalty_,\\n            borrowFee_\\n        );\\n\\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\\n\\n        collateralFactor_ = collateralFactor_ / 10;\\n        liquidationThreshold_ = liquidationThreshold_ / 10;\\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\\n        withdrawGap_ = withdrawGap_ / 10;\\n\\n        if (\\n            (supplyRateMagnifier_ > X16) ||\\n            (borrowRateMagnifier_ > X16) ||\\n            (collateralFactor_ >= liquidationThreshold_) ||\\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\\n            (withdrawGap_ > X10) ||\\n            (liquidationPenalty_ > X10) ||\\n            (borrowFee_ > X10)\\n        ) {\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n        }\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\\n            supplyRateMagnifier_ |\\n            (borrowRateMagnifier_ << 16) |\\n            (collateralFactor_ << 32) |\\n            (liquidationThreshold_ << 42) |\\n            (liquidationMaxLimit_ << 52) |\\n            (withdrawGap_ << 62) |\\n            (liquidationPenalty_ << 72) |\\n            (borrowFee_ << 82);\\n    }\\n\\n    /// @notice updates the Vault oracle to `newOracle_`. Must implement the FluidOracle interface.\\n    function updateOracle(address newOracle_) public _updateExchangePrice _verifyCaller {\\n        if (newOracle_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\\n\\n        // Removing current oracle by masking only first 96 bits then inserting new oracle as bits\\n        vaultVariables2 = (vaultVariables2 & X96) | (uint256(uint160(newOracle_)) << 96);\\n\\n        emit LogUpdateOracle(newOracle_);\\n    }\\n\\n    /// @notice updates the allowed rebalancer to `newRebalancer_`.\\n    function updateRebalancer(address newRebalancer_) public _updateExchangePrice _verifyCaller {\\n        if (newRebalancer_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\\n\\n        rebalancer = newRebalancer_;\\n\\n        emit LogUpdateRebalancer(newRebalancer_);\\n    }\\n\\n    /// @notice sends any potentially stuck funds to Liquidity contract.\\n    /// @dev this contract never holds any funds as all operations send / receive funds from user <-> Liquidity.\\n    function rescueFunds(address token_) external _verifyCaller {\\n        if (token_ == NATIVE_TOKEN) {\\n            SafeTransfer.safeTransferNative(IFluidVaultT1(address(this)).LIQUIDITY(), address(this).balance);\\n        } else {\\n            SafeTransfer.safeTransfer(\\n                token_,\\n                IFluidVaultT1(address(this)).LIQUIDITY(),\\n                IERC20(token_).balanceOf(address(this))\\n            );\\n        }\\n\\n        emit LogRescueFunds(token_);\\n    }\\n\\n    /// @notice absorbs accumulated dust debt\\n    /// @dev in decades if a lot of positions are 100% liquidated (aka absorbed) then dust debt can mount up\\n    /// which is basically sort of an extra revenue for the protocol.\\n    //\\n    // this function might never come in use that's why adding it in admin module\\n    function absorbDustDebt(uint[] memory nftIds_) public _verifyCaller {\\n        uint256 vaultVariables_ = vaultVariables;\\n        // re-entrancy check\\n        if (vaultVariables_ & 1 == 0) {\\n            // Updating on storage\\n            vaultVariables = vaultVariables_ | 1;\\n        } else {\\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\\n        }\\n\\n        uint nftId_;\\n        uint posData_;\\n        int posTick_;\\n        uint tickId_;\\n        uint posCol_;\\n        uint posDebt_;\\n        uint posDustDebt_;\\n        uint tickData_;\\n\\n        uint absorbedDustDebt_ = absorbedDustDebt;\\n\\n        for (uint i = 0; i < nftIds_.length; ) {\\n            nftId_ = nftIds_[i];\\n            if (nftId_ == 0) {\\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftIdShouldBeNonZero);\\n            }\\n\\n            // user's position data\\n            posData_ = positionData[nftId_];\\n\\n            if (posData_ == 0) {\\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotOfThisVault);\\n            }\\n\\n            posCol_ = (posData_ >> 45) & X64;\\n            // Converting big number into normal number\\n            posCol_ = (posCol_ >> 8) << (posCol_ & X8);\\n\\n            posDustDebt_ = (posData_ >> 109) & X64;\\n            // Converting big number into normal number\\n            posDustDebt_ = (posDustDebt_ >> 8) << (posDustDebt_ & X8);\\n\\n            if (posDustDebt_ == 0) {\\n                revert FluidVaultError(ErrorTypes.VaultAdmin__DustDebtIsZero);\\n            }\\n\\n            // borrow position (has collateral & debt)\\n            posTick_ = posData_ & 2 == 2 ? int((posData_ >> 2) & X19) : -int((posData_ >> 2) & X19);\\n            tickId_ = (posData_ >> 21) & X24;\\n\\n            posDebt_ = (TickMath.getRatioAtTick(int24(posTick_)) * posCol_) >> 96;\\n\\n            // Tick data from user's tick\\n            tickData_ = tickData[posTick_];\\n\\n            // Checking if tick is liquidated OR if the total IDs of tick is greater than user's tick ID\\n            if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > tickId_)) {\\n                // User got liquidated\\n                (, posDebt_, , , ) = IFluidVaultT1(address(this)).fetchLatestPosition(\\n                    posTick_,\\n                    tickId_,\\n                    posDebt_,\\n                    tickData_\\n                );\\n                if (posDebt_ > 0) {\\n                    revert FluidVaultError(ErrorTypes.VaultAdmin__FinalDebtShouldBeZero);\\n                }\\n                // absorbing user's debt as it's 100% or almost 100% liquidated\\n                absorbedDustDebt_ = absorbedDustDebt_ + posDustDebt_;\\n                // making position as supply only\\n                positionData[nftId_] = 1;\\n            } else {\\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotLiquidated);\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        if (absorbedDustDebt_ == 0) {\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__AbsorbedDustDebtIsZero);\\n        }\\n\\n        uint totalBorrow_ = (vaultVariables_ >> 146) & X64;\\n        // Converting big number into normal number\\n        totalBorrow_ = (totalBorrow_ >> 8) << (totalBorrow_ & X8);\\n        // note: by default dust debt is not added into total borrow but on 100% liquidation (aka absorb) dust debt equivalent\\n        // is removed from total borrow so adding it back again here\\n        totalBorrow_ = totalBorrow_ + absorbedDustDebt_;\\n        totalBorrow_ = BigMathMinified.toBigNumber(totalBorrow_, 56, 8, BigMathMinified.ROUND_UP);\\n\\n        // adding absorbed dust debt to total borrow so it will get included in the next rebalancing.\\n        // there is some fuzziness here as when the position got fully liquidated (aka absorbed) the exchange price was different\\n        // than what it'll be now. The fuzziness which will be extremely small so we can ignore it\\n        // updating on storage\\n        vaultVariables =\\n            (vaultVariables_ & 0xfffffffffffc0000000000000003ffffffffffffffffffffffffffffffffffff) |\\n            (totalBorrow_ << 146);\\n\\n        // updating on storage\\n        absorbedDustDebt = 0;\\n\\n        emit LogAbsorbDustDebt(nftIds_, absorbedDustDebt_);\\n    }\\n}\\n\",\"keccak256\":\"0x39f6abd927ccf479402d0c035f73b78bcb1d9c1a7d0bd9bf8ba384f110207196\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultT1/common/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\ncontract Variables {\\n    /***********************************|\\n    |         Storage Variables         |\\n    |__________________________________*/\\n\\n    /// note: in all variables. For tick >= 0 are represented with bit as 1, tick < 0 are represented with bit as 0\\n    /// note: read all the variables through storageRead.sol\\n\\n    /// note: vaultVariables contains vault variables which need regular updates through transactions\\n    /// First 1 bit => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\\n    /// Next 1 bit => 1 => Is the current active branch liquidated? If true then check the branch's minima tick before creating a new position\\n    /// If the new tick is greater than minima tick then initialize a new branch, make that as current branch & do proper linking\\n    /// Next 1 bit => 2 => sign of topmost tick (0 -> negative; 1 -> positive)\\n    /// Next 19 bits => 3-21 => absolute value of topmost tick\\n    /// Next 30 bits => 22-51 => current branch ID\\n    /// Next 30 bits => 52-81 => total branch ID\\n    /// Next 64 bits => 82-145 => Total supply\\n    /// Next 64 bits => 146-209 => Total borrow\\n    /// Next 32 bits => 210-241 => Total positions\\n    uint256 internal vaultVariables;\\n\\n    /// note: vaultVariables2 contains variables which do not update on every transaction. So mainly admin/auth set amount\\n    /// First 16 bits => 0-15 => supply rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\\n    /// Next 16 bits => 16-31 => borrow rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\\n    /// Next 10 bits => 32-41 => collateral factor. 800 = 0.8 = 80% (max precision of 0.1%)\\n    /// Next 10 bits => 42-51 => liquidation Threshold. 900 = 0.9 = 90% (max precision of 0.1%)\\n    /// Next 10 bits => 52-61 => liquidation Max Limit. 950 = 0.95 = 95% (max precision of 0.1%) (above this 100% liquidation can happen)\\n    /// Next 10 bits => 62-71 => withdraw gap. 100 = 0.1 = 10%. (max precision of 0.1%) (max 7 bits can also suffice for the requirement here of 0.1% to 10%). Needed to save some limits on withdrawals so liquidate can work seamlessly.\\n    /// Next 10 bits => 72-81 => liquidation penalty. 100 = 0.01 = 1%. (max precision of 0.01%) (max liquidation penantly can be 10.23%). Applies when tick is in between liquidation Threshold & liquidation Max Limit.\\n    /// Next 10 bits => 82-91 => borrow fee. 100 = 0.01 = 1%. (max precision of 0.01%) (max borrow fee can be 10.23%). Fees on borrow.\\n    /// Next 4  bits => 92-95 => empty\\n    /// Next 160 bits => 96-255 => Oracle address\\n    uint256 internal vaultVariables2;\\n\\n    /// note: stores absorbed liquidity\\n    /// First 128 bits raw debt amount\\n    /// last 128 bits raw col amount\\n    uint256 internal absorbedLiquidity;\\n\\n    /// position index => position data uint\\n    /// if the entire variable is 0 (meaning not initialized) at the start that means no position at all\\n    /// First 1 bit => 0 => position type (0 => borrow position; 1 => supply position)\\n    /// Next 1 bit => 1 => sign of user's tick (0 => negative; 1 => positive)\\n    /// Next 19 bits => 2-20 => absolute value of user's tick\\n    /// Next 24 bits => 21-44 => user's tick's id\\n    /// Below we are storing user's collateral & not debt, because the position can also be only collateral with no tick but it can never be only debt\\n    /// Next 64 bits => 45-108 => user's supply amount. Debt will be calculated through supply & ratio.\\n    /// Next 64 bits => 109-172 => user's dust debt amount. User's net debt = total debt - dust amount. Total debt is calculated through supply & ratio\\n    /// User won't pay any extra interest on dust debt & hence we will not show it as a debt on UI. For user's there's no dust.\\n    mapping(uint256 => uint256) internal positionData;\\n\\n    /// Tick has debt only keeps data of non liquidated positions. liquidated tick's data stays in branch itself\\n    /// tick parent => uint (represents bool for 256 children)\\n    /// parent of (i)th tick:-\\n    /// if (i>=0) (i / 256);\\n    /// else ((i + 1) / 256) - 1\\n    /// first bit of the variable is the smallest tick & last bit is the biggest tick of that slot\\n    mapping(int256 => uint256) internal tickHasDebt;\\n\\n    /// mapping tickId => tickData\\n    /// Tick related data. Total debt & other things\\n    /// First bit => 0 => If 1 then liquidated else not liquidated\\n    /// Next 24 bits => 1-24 => Total IDs. ID should start from 1.\\n    /// If not liquidated:\\n    /// Next 64 bits => 25-88 => raw debt\\n    /// If liquidated\\n    /// The below 3 things are of last ID. This is to be updated when user creates a new position\\n    /// Next 1 bit => 25 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated (100% liquidated)\\n    /// Next 30 bits => 26-55 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 56-105 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    mapping(int256 => uint256) internal tickData;\\n\\n    /// tick id => previous tick id liquidation data. ID starts from 1\\n    /// One tick ID contains 3 IDs of 80 bits in it, holding liquidation data of previously active but liquidated ticks\\n    /// 81 bits data below\\n    /// #### First 85 bits ####\\n    /// 1st bit => 0 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\\n    /// Next 30 bits => 1-30 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 31-80 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    /// #### Second 85 bits ####\\n    /// 85th bit => 85 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\\n    /// Next 30 bits => 86-115 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 116-165 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    /// #### Third 85 bits ####\\n    /// 170th bit => 170 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\\n    /// Next 30 bits => 171-200 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 201-250 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    mapping(int256 => mapping(uint256 => uint256)) internal tickId;\\n\\n    /// mapping branchId => branchData\\n    /// First 2 bits => 0-1 => if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\\n    /// merged means the branch is merged into it's base branch\\n    /// closed means all the users are 100% liquidated\\n    /// Next 1 bit => 2 => minima tick sign of this branch. Will only be there if any liquidation happened.\\n    /// Next 19 bits => 3-21 => minima tick of this branch. Will only be there if any liquidation happened.\\n    /// Next 30 bits => 22-51 => Partials of minima tick of branch this is connected to. 0 if master branch.\\n    /// Next 64 bits => 52-115 Debt liquidity at this branch. Similar to last's top tick data. Remaining debt will move here from tickData after first liquidation\\n    /// If not merged\\n    /// Next 50 bits => 116-165 => Debt factor or of this branch. (35 bits coefficient | 15 bits expansion)\\n    /// If merged\\n    /// Next 50 bits => 116-165 => Connection/adjustment debt factor of this branch with the next branch.\\n    /// If closed\\n    /// Next 50 bits => 116-165 => Debt factor as 0. As all the user's positions are now fully gone\\n    /// following values are present always again (merged / not merged / closed)\\n    /// Next 30 bits => 166-195 => Branch's ID with which this branch is connected. If 0 then that means this is the master branch\\n    /// Next 1 bit => 196 => sign of minima tick of branch this is connected to. 0 if master branch.\\n    /// Next 19 bits => 197-215 => minima tick of branch this is connected to. 0 if master branch.\\n    mapping(uint256 => uint256) internal branchData;\\n\\n    /// Exchange prices are in 1e12\\n    /// First 64 bits => 0-63 => Liquidity's collateral token supply exchange price\\n    /// First 64 bits => 64-127 => Liquidity's debt token borrow exchange price\\n    /// First 64 bits => 128-191 => Vault's collateral token supply exchange price\\n    /// First 64 bits => 192-255 => Vault's debt token borrow exchange price\\n    uint256 internal rates;\\n\\n    /// address of rebalancer\\n    address internal rebalancer;\\n\\n    uint256 internal absorbedDustDebt;\\n}\\n\",\"keccak256\":\"0x446a2d8d47d53d1584a1a1dd9aed247320ba04582e8bbcd7be60c979f908c52e\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultT2/adminModule/events.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract VaultT2Events {\\n    /// @notice emitted when the supply rate config is updated\\n    event LogUpdateSupplyRate(int supplyRate_);\\n\\n    /// @notice emitted when the borrow rate magnifier config is updated\\n    event LogUpdateBorrowRateMagnifier(uint borrowRateMagnifier_);\\n\\n    /// @notice emitted when the core setting configs are updated\\n    event LogUpdateCoreSettings(\\n        int supplyRate_,\\n        uint borrowRateMagnifier_,\\n        uint collateralFactor_,\\n        uint liquidationThreshold_,\\n        uint liquidationMaxLimit_,\\n        uint withdrawGap_,\\n        uint liquidationPenalty_,\\n        uint borrowFee_\\n    );\\n}\\n\",\"keccak256\":\"0x675d6778c7e5c604fb540b47849f90423015b2fe1868c0bb7b5cb859993946f2\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultT2/adminModule/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { FluidVaultAdmin } from \\\"../../vaultTypesCommon/adminModule/main.sol\\\";\\nimport { ErrorTypes } from \\\"../../errorTypes.sol\\\";\\nimport { VaultT2Events } from \\\"./events.sol\\\";\\n\\n/// @notice Fluid Vault protocol Admin Module contract.\\n///         Implements admin related methods to set configs such as liquidation params, rates\\n///         oracle address etc.\\n///         Methods are limited to be called via delegateCall only. Vault CoreModule is expected\\n///         to call the methods implemented here after checking the msg.sender is authorized.\\n///         All methods update the exchange prices in storage before changing configs.\\ncontract FluidVaultT2Admin is FluidVaultAdmin, VaultT2Events {\\n    /// @notice updates the supply rate. Input in 1e2 (1% = 100, 100% = 10_000). If positive then incentives else charging\\n    function updateSupplyRate(int supplyRate_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateSupplyRate(supplyRate_);\\n\\n        if ((supplyRate_ > int(X15)) || (-supplyRate_ > int(X15))) {\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n        }\\n\\n        uint supplyRateToInsert_ = supplyRate_ < 0 ? (uint(-supplyRate_) << 1) : (uint(1) | (uint(supplyRate_) << 1));\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\\n            supplyRateToInsert_;\\n    }\\n\\n    /// @notice updates the borrow rate magnifier to `borrowRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateBorrowRateMagnifier(uint borrowRateMagnifier_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateBorrowRateMagnifier(borrowRateMagnifier_);\\n\\n        if (borrowRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\\n            (borrowRateMagnifier_ << 16);\\n    }\\n\\n    /// @notice updates the all Vault core settings according to input params.\\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\\n    function updateCoreSettings(\\n        int256 supplyRate_,\\n        uint256 borrowRateMagnifier_,\\n        uint256 collateralFactor_,\\n        uint256 liquidationThreshold_,\\n        uint256 liquidationMaxLimit_,\\n        uint256 withdrawGap_,\\n        uint256 liquidationPenalty_,\\n        uint256 borrowFee_\\n    ) public _updateExchangePrice _verifyCaller {\\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\\n        emit LogUpdateCoreSettings(\\n            supplyRate_,\\n            borrowRateMagnifier_,\\n            collateralFactor_,\\n            liquidationThreshold_,\\n            liquidationMaxLimit_,\\n            withdrawGap_,\\n            liquidationPenalty_,\\n            borrowFee_\\n        );\\n\\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\\n\\n        collateralFactor_ = collateralFactor_ / 10;\\n        liquidationThreshold_ = liquidationThreshold_ / 10;\\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\\n        withdrawGap_ = withdrawGap_ / 10;\\n\\n        if (\\n            (supplyRate_ > int(X15)) ||\\n            (-supplyRate_ > int(X15)) ||\\n            (borrowRateMagnifier_ > X16) ||\\n            (collateralFactor_ >= liquidationThreshold_) ||\\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\\n            (withdrawGap_ > X10) ||\\n            (liquidationPenalty_ > X10) ||\\n            (borrowFee_ > X10)\\n        ) {\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n        }\\n\\n        uint supplyRateToInsert_ = supplyRate_ < 0 ? (uint(-supplyRate_) << 1) : (uint(1) | (uint(supplyRate_) << 1));\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\\n            supplyRateToInsert_ |\\n            (borrowRateMagnifier_ << 16) |\\n            (collateralFactor_ << 32) |\\n            (liquidationThreshold_ << 42) |\\n            (liquidationMaxLimit_ << 52) |\\n            (withdrawGap_ << 62) |\\n            (liquidationPenalty_ << 72) |\\n            (borrowFee_ << 82);\\n    }\\n}\\n\",\"keccak256\":\"0xef96b050fa2555785002d35a16c750b09020d087db61a0ef770420b7eee5d5aa\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultT3/adminModule/events.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract VaultT3Events {\\n    /// @notice emitted when the supply rate magnifier config is updated\\n    event LogUpdateSupplyRateMagnifier(uint supplyRateMagnifier_);\\n\\n    /// @notice emitted when the borrow rate config is updated\\n    event LogUpdateBorrowRate(int borrowRate_);\\n\\n    /// @notice emitted when the core setting configs are updated\\n    event LogUpdateCoreSettings(\\n        uint supplyRateMagnifier_,\\n        int borrowRate_,\\n        uint collateralFactor_,\\n        uint liquidationThreshold_,\\n        uint liquidationMaxLimit_,\\n        uint withdrawGap_,\\n        uint liquidationPenalty_,\\n        uint borrowFee_\\n    );\\n}\\n\",\"keccak256\":\"0x28336e556ea53d40d1b490f91c372c31a9301f5b9cc8ddddffca92c9a12ce312\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultT3/adminModule/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { FluidVaultAdmin } from \\\"../../vaultTypesCommon/adminModule/main.sol\\\";\\nimport { ErrorTypes } from \\\"../../errorTypes.sol\\\";\\nimport { VaultT3Events } from \\\"./events.sol\\\";\\n\\n/// @notice Fluid Vault protocol Admin Module contract.\\n///         Implements admin related methods to set configs such as liquidation params, rates\\n///         oracle address etc.\\n///         Methods are limited to be called via delegateCall only. Vault CoreModule is expected\\n///         to call the methods implemented here after checking the msg.sender is authorized.\\n///         All methods update the exchange prices in storage before changing configs.\\ncontract FluidVaultT3Admin is FluidVaultAdmin, VaultT3Events {\\n    /// @notice updates the supply rate magnifier to `supplyRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateSupplyRateMagnifier(uint supplyRateMagnifier_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateSupplyRateMagnifier(supplyRateMagnifier_);\\n\\n        if (supplyRateMagnifier_ > X16) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000) |\\n            supplyRateMagnifier_;\\n    }\\n\\n    /// @notice updates the borrow rate. Input in 1e2 (1% = 100, 100% = 10_000). If positive then charging else incentives\\n    function updateBorrowRate(int borrowRate_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateBorrowRate(borrowRate_);\\n\\n        if ((borrowRate_ > int(X15)) || (-borrowRate_ > int(X15))) {\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n        }\\n\\n        uint borrowRateToInsert_ = borrowRate_ < 0 ? ((uint(-borrowRate_) << 1)) : (uint(1) | (uint(borrowRate_) << 1));\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffff) |\\n            (borrowRateToInsert_ << 16);\\n    }\\n\\n    /// @notice updates the all Vault core settings according to input params.\\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\\n    function updateCoreSettings(\\n        uint256 supplyRateMagnifier_,\\n        int256 borrowRate_,\\n        uint256 collateralFactor_,\\n        uint256 liquidationThreshold_,\\n        uint256 liquidationMaxLimit_,\\n        uint256 withdrawGap_,\\n        uint256 liquidationPenalty_,\\n        uint256 borrowFee_\\n    ) public _updateExchangePrice _verifyCaller {\\n        // emitting the event at the start as then we are updating numbers to store in a more optimized way\\n        emit LogUpdateCoreSettings(\\n            supplyRateMagnifier_,\\n            borrowRate_,\\n            collateralFactor_,\\n            liquidationThreshold_,\\n            liquidationMaxLimit_,\\n            withdrawGap_,\\n            liquidationPenalty_,\\n            borrowFee_\\n        );\\n\\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\\n\\n        collateralFactor_ = collateralFactor_ / 10;\\n        liquidationThreshold_ = liquidationThreshold_ / 10;\\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\\n        withdrawGap_ = withdrawGap_ / 10;\\n\\n        if (\\n            (supplyRateMagnifier_ > X16) ||\\n            (borrowRate_ > int(X15)) ||\\n            (-borrowRate_ > int(X15)) ||\\n            (collateralFactor_ >= liquidationThreshold_) ||\\n            (liquidationThreshold_ >= liquidationMaxLimit_) ||\\n            (withdrawGap_ > X10) ||\\n            (liquidationPenalty_ > X10) ||\\n            (borrowFee_ > X10)\\n        ) {\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n        }\\n\\n        uint borrowRateToInsert_ = borrowRate_ < 0 ? ((uint(-borrowRate_) << 1)) : (uint(1) | (uint(borrowRate_) << 1));\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff00000000000000000000000) |\\n            supplyRateMagnifier_ |\\n            (borrowRateToInsert_ << 16) |\\n            (collateralFactor_ << 32) |\\n            (liquidationThreshold_ << 42) |\\n            (liquidationMaxLimit_ << 52) |\\n            (withdrawGap_ << 62) |\\n            (liquidationPenalty_ << 72) |\\n            (borrowFee_ << 82);\\n    }\\n}\\n\",\"keccak256\":\"0x40d8687ee9bed2a8d5e6ae8b26bf099d8b6c7357b88c2f9fe1e628ecb812d3d2\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultTypesCommon/adminModule/events.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Events {\\n    /// @notice emitted when the collateral factor config is updated\\n    event LogUpdateCollateralFactor(uint collateralFactor_);\\n\\n    /// @notice emitted when the liquidation threshold config is updated\\n    event LogUpdateLiquidationThreshold(uint liquidationThreshold_);\\n\\n    /// @notice emitted when the liquidation max limit config is updated\\n    event LogUpdateLiquidationMaxLimit(uint liquidationMaxLimit_);\\n\\n    /// @notice emitted when the withdrawal gap config is updated\\n    event LogUpdateWithdrawGap(uint withdrawGap_);\\n\\n    /// @notice emitted when the liquidation penalty config is updated\\n    event LogUpdateLiquidationPenalty(uint liquidationPenalty_);\\n\\n    /// @notice emitted when the borrow fee config is updated\\n    event LogUpdateBorrowFee(uint borrowFee_);\\n\\n    /// @notice emitted when the oracle is updated\\n    event LogUpdateOracle(uint indexed deploymentNonce_, address indexed newOracle_);\\n\\n    /// @notice emitted when the allowed rebalancer is updated\\n    event LogUpdateRebalancer(address indexed newRebalancer_);\\n\\n    /// @notice emitted when funds are rescued\\n    event LogRescueFunds(address indexed token_);\\n\\n    /// @notice emitted when dust debt is absorbed for `nftIds_`\\n    event LogAbsorbDustDebt(uint256[] nftIds_, uint256 absorbedDustDebt_);\\n}\\n\",\"keccak256\":\"0x2a032d575b841b16dc812813a7f6d63ef983e653633b1c4916dcd9b97d693be1\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultTypesCommon/adminModule/main.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport { IFluidOracle } from \\\"../../../../oracle/fluidOracle.sol\\\";\\n\\nimport { Variables } from \\\"../common/variables.sol\\\";\\nimport { Events } from \\\"./events.sol\\\";\\nimport { ErrorTypes } from \\\"../../errorTypes.sol\\\";\\nimport { Error } from \\\"../../error.sol\\\";\\nimport { IFluidVault } from \\\"../../interfaces/iVault.sol\\\";\\nimport { BigMathMinified } from \\\"../../../../libraries/bigMathMinified.sol\\\";\\nimport { TickMath } from \\\"../../../../libraries/tickMath.sol\\\";\\nimport { AddressCalcs } from \\\"../../../../libraries/addressCalcs.sol\\\";\\nimport { SafeTransfer } from \\\"../../../../libraries/safeTransfer.sol\\\";\\n\\n/// @notice Fluid Vault protocol Admin Module contract.\\n///         Implements admin related methods to set configs such as liquidation params, rates\\n///         oracle address etc.\\n///         Methods are limited to be called via delegateCall only. Vault CoreModule (\\\"VaultT1\\\" contract)\\n///         is expected to call the methods implemented here after checking the msg.sender is authorized.\\n///         All methods update the exchange prices in storage before changing configs.\\nabstract contract FluidVaultAdmin is Variables, Events, Error {\\n    uint internal constant X8 = 0xff;\\n    uint internal constant X10 = 0x3ff;\\n    uint internal constant X15 = 0x7fff;\\n    uint internal constant X16 = 0xffff;\\n    uint internal constant X19 = 0x7ffff;\\n    uint internal constant X24 = 0xffffff;\\n    uint internal constant X30 = 0x3fffffff;\\n    uint internal constant X64 = 0xffffffffffffffff;\\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    address internal immutable addressThis;\\n\\n    constructor() {\\n        addressThis = address(this);\\n    }\\n\\n    modifier _verifyCaller() {\\n        if (address(this) == addressThis) {\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__OnlyDelegateCallAllowed);\\n        }\\n        _;\\n    }\\n\\n    /// @dev updates exchange price on storage, called on all admin methods in combination with _verifyCaller modifier so\\n    /// only called by authorized delegatecall\\n    modifier _updateExchangePrice() {\\n        IFluidVault(address(this)).updateExchangePricesOnStorage();\\n        _;\\n    }\\n\\n    function _checkLiquidationMaxLimitAndPenalty(uint liquidationMaxLimit_, uint liquidationPenalty_) internal pure {\\n        // liquidation max limit with penalty should not go above 99.7%\\n        // As liquidation with penalty can happen from liquidation Threshold to max limit\\n        // If it goes above 100% than that means liquidator is getting more collateral than user's available\\n        if ((liquidationMaxLimit_ + liquidationPenalty_) > 9970) {\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n        }\\n    }\\n\\n    /// @notice updates the collateral factor to `collateralFactor_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateCollateralFactor(uint collateralFactor_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateCollateralFactor(collateralFactor_);\\n\\n        uint vaultVariables2_ = vaultVariables2;\\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\\n\\n        collateralFactor_ = collateralFactor_ / 10;\\n\\n        if (collateralFactor_ >= liquidationThreshold_) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffc00ffffffff) |\\n            (collateralFactor_ << 32);\\n    }\\n\\n    /// @notice updates the liquidation threshold to `liquidationThreshold_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateLiquidationThreshold(uint liquidationThreshold_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateLiquidationThreshold(liquidationThreshold_);\\n\\n        uint vaultVariables2_ = vaultVariables2;\\n        uint collateralFactor_ = ((vaultVariables2_ >> 32) & X10);\\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\\n\\n        liquidationThreshold_ = liquidationThreshold_ / 10;\\n\\n        if ((collateralFactor_ >= liquidationThreshold_) || (liquidationThreshold_ >= liquidationMaxLimit_))\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffffffffff003ffffffffff) |\\n            (liquidationThreshold_ << 42);\\n    }\\n\\n    /// @notice updates the liquidation max limit to `liquidationMaxLimit_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateLiquidationMaxLimit(uint liquidationMaxLimit_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateLiquidationMaxLimit(liquidationMaxLimit_);\\n\\n        uint vaultVariables2_ = vaultVariables2;\\n        uint liquidationThreshold_ = ((vaultVariables2_ >> 42) & X10);\\n        uint liquidationPenalty_ = ((vaultVariables2_ >> 72) & X10);\\n\\n        // both are in 1e2 decimals (1e2 = 1%)\\n        _checkLiquidationMaxLimitAndPenalty(liquidationMaxLimit_, liquidationPenalty_);\\n\\n        liquidationMaxLimit_ = liquidationMaxLimit_ / 10;\\n\\n        if (liquidationThreshold_ >= liquidationMaxLimit_)\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2_ & 0xffffffffffffffffffffffffffffffffffffffffffffffffc00fffffffffffff) |\\n            (liquidationMaxLimit_ << 52);\\n    }\\n\\n    /// @notice updates the withdrawal gap to `withdrawGap_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateWithdrawGap(uint withdrawGap_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateWithdrawGap(withdrawGap_);\\n\\n        withdrawGap_ = withdrawGap_ / 10;\\n\\n        // withdrawGap must not be > 100%\\n        if (withdrawGap_ > 1000) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xffffffffffffffffffffffffffffffffffffffffffffff003fffffffffffffff) |\\n            (withdrawGap_ << 62);\\n    }\\n\\n    /// @notice updates the liquidation penalty to `liquidationPenalty_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateLiquidationPenalty(uint liquidationPenalty_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateLiquidationPenalty(liquidationPenalty_);\\n\\n        uint vaultVariables2_ = vaultVariables2;\\n        uint liquidationMaxLimit_ = ((vaultVariables2_ >> 52) & X10);\\n\\n        // Converting liquidationMaxLimit_ in 1e2 decimals (1e2 = 1%)\\n        _checkLiquidationMaxLimitAndPenalty((liquidationMaxLimit_ * 10), liquidationPenalty_);\\n\\n        if (liquidationPenalty_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2_ & 0xfffffffffffffffffffffffffffffffffffffffffffc00ffffffffffffffffff) |\\n            (liquidationPenalty_ << 72);\\n    }\\n\\n    /// @notice updates the borrow fee to `borrowFee_`. Input in 1e2 (1% = 100, 100% = 10_000).\\n    function updateBorrowFee(uint borrowFee_) public _updateExchangePrice _verifyCaller {\\n        emit LogUpdateBorrowFee(borrowFee_);\\n\\n        if (borrowFee_ > X10) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffffffffff003ffffffffffffffffffff) |\\n            (borrowFee_ << 82);\\n    }\\n\\n    /// @notice updates the Vault oracle to `newOracleNonce_`. Must implement the FluidOracle interface.\\n    function updateOracle(uint newOracleNonce_) public _updateExchangePrice _verifyCaller {\\n        if (newOracleNonce_ > X30) revert FluidVaultError(ErrorTypes.VaultAdmin__ValueAboveLimit);\\n\\n        // masking to remove old oracle and keep all the other values intact\\n        vaultVariables2 =\\n            (vaultVariables2 & 0xfffffffffffffffffffffffffffffffffc0000000fffffffffffffffffffffff) |\\n            (newOracleNonce_ << 92);\\n\\n        IFluidVault.ConstantViews memory c_ = IFluidVault(address(this)).constantsView();\\n\\n        address oracle_ = AddressCalcs.addressCalc(c_.deployer, newOracleNonce_);\\n\\n        // checking if oracle address follows the standard\\n        IFluidOracle(oracle_).getExchangeRateOperate();\\n        IFluidOracle(oracle_).getExchangeRateLiquidate();\\n\\n        emit LogUpdateOracle(newOracleNonce_, oracle_);\\n    }\\n\\n    /// @notice updates the allowed rebalancer to `newRebalancer_`.\\n    function updateRebalancer(address newRebalancer_) public _updateExchangePrice _verifyCaller {\\n        if (newRebalancer_ == address(0)) revert FluidVaultError(ErrorTypes.VaultAdmin__AddressZeroNotAllowed);\\n\\n        rebalancer = newRebalancer_;\\n\\n        emit LogUpdateRebalancer(newRebalancer_);\\n    }\\n\\n    /// @notice sends any potentially stuck funds to Liquidity contract.\\n    /// @dev this contract never holds any funds as all operations send / receive funds from user <-> Liquidity.\\n    function rescueFunds(address token_) external _verifyCaller {\\n        if (token_ == NATIVE_TOKEN) {\\n            SafeTransfer.safeTransferNative(IFluidVault(address(this)).LIQUIDITY(), address(this).balance);\\n        } else {\\n            SafeTransfer.safeTransfer(\\n                token_,\\n                IFluidVault(address(this)).LIQUIDITY(),\\n                IERC20(token_).balanceOf(address(this))\\n            );\\n        }\\n\\n        emit LogRescueFunds(token_);\\n    }\\n\\n    /// @notice absorbs accumulated dust debt\\n    /// @dev in decades if a lot of positions are 100% liquidated (aka absorbed) then dust debt can mount up\\n    /// which is basically sort of an extra revenue for the protocol.\\n    //\\n    // this function might never come in use that's why adding it in admin module\\n    function absorbDustDebt(uint[] memory nftIds_) public _verifyCaller {\\n        uint256 vaultVariables_ = vaultVariables;\\n        // re-entrancy check\\n        if (vaultVariables_ & 1 == 0) {\\n            // Updating on storage\\n            vaultVariables = vaultVariables_ | 1;\\n        } else {\\n            revert FluidVaultError(ErrorTypes.Vault__AlreadyEntered);\\n        }\\n\\n        uint nftId_;\\n        uint posData_;\\n        int posTick_;\\n        uint tickId_;\\n        uint posCol_;\\n        uint posDebt_;\\n        uint posDustDebt_;\\n        uint tickData_;\\n\\n        uint absorbedDustDebt_ = absorbedDustDebt;\\n\\n        for (uint i = 0; i < nftIds_.length; ) {\\n            nftId_ = nftIds_[i];\\n            if (nftId_ == 0) {\\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftIdShouldBeNonZero);\\n            }\\n\\n            // user's position data\\n            posData_ = positionData[nftId_];\\n\\n            if (posData_ == 0) {\\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotOfThisVault);\\n            }\\n\\n            posCol_ = (posData_ >> 45) & X64;\\n            // Converting big number into normal number\\n            posCol_ = (posCol_ >> 8) << (posCol_ & X8);\\n\\n            posDustDebt_ = (posData_ >> 109) & X64;\\n            // Converting big number into normal number\\n            posDustDebt_ = (posDustDebt_ >> 8) << (posDustDebt_ & X8);\\n\\n            if (posDustDebt_ == 0) {\\n                revert FluidVaultError(ErrorTypes.VaultAdmin__DustDebtIsZero);\\n            }\\n\\n            // borrow position (has collateral & debt)\\n            posTick_ = posData_ & 2 == 2 ? int((posData_ >> 2) & X19) : -int((posData_ >> 2) & X19);\\n            tickId_ = (posData_ >> 21) & X24;\\n\\n            posDebt_ = (TickMath.getRatioAtTick(int24(posTick_)) * posCol_) >> 96;\\n\\n            // Tick data from user's tick\\n            tickData_ = tickData[posTick_];\\n\\n            // Checking if tick is liquidated OR if the total IDs of tick is greater than user's tick ID\\n            if (((tickData_ & 1) == 1) || (((tickData_ >> 1) & X24) > tickId_)) {\\n                // User got liquidated\\n                (, posDebt_, , , ) = IFluidVault(address(this)).fetchLatestPosition(\\n                    posTick_,\\n                    tickId_,\\n                    posDebt_,\\n                    tickData_\\n                );\\n                if (posDebt_ > 0) {\\n                    revert FluidVaultError(ErrorTypes.VaultAdmin__FinalDebtShouldBeZero);\\n                }\\n                // absorbing user's debt as it's 100% or almost 100% liquidated\\n                absorbedDustDebt_ = absorbedDustDebt_ + posDustDebt_;\\n                // making position as supply only\\n                positionData[nftId_] = 1;\\n            } else {\\n                revert FluidVaultError(ErrorTypes.VaultAdmin__NftNotLiquidated);\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        if (absorbedDustDebt_ == 0) {\\n            revert FluidVaultError(ErrorTypes.VaultAdmin__AbsorbedDustDebtIsZero);\\n        }\\n\\n        uint totalBorrow_ = (vaultVariables_ >> 146) & X64;\\n        // Converting big number into normal number\\n        totalBorrow_ = (totalBorrow_ >> 8) << (totalBorrow_ & X8);\\n        // note: by default dust debt is not added into total borrow but on 100% liquidation (aka absorb) dust debt equivalent\\n        // is removed from total borrow so adding it back again here\\n        totalBorrow_ = totalBorrow_ + absorbedDustDebt_;\\n        totalBorrow_ = BigMathMinified.toBigNumber(totalBorrow_, 56, 8, BigMathMinified.ROUND_UP);\\n\\n        // adding absorbed dust debt to total borrow so it will get included in the next rebalancing.\\n        // there is some fuzziness here as when the position got fully liquidated (aka absorbed) the exchange price was different\\n        // than what it'll be now. The fuzziness which will be extremely small so we can ignore it\\n        // updating on storage\\n        vaultVariables =\\n            (vaultVariables_ & 0xfffffffffffc0000000000000003ffffffffffffffffffffffffffffffffffff) |\\n            (totalBorrow_ << 146);\\n\\n        // updating on storage\\n        absorbedDustDebt = 0;\\n\\n        emit LogAbsorbDustDebt(nftIds_, absorbedDustDebt_);\\n    }\\n}\\n\",\"keccak256\":\"0x33f6707b3e549636e5579970872f79392ab3fa53d94766d2125919d77dd4ea99\",\"license\":\"BUSL-1.1\"},\"contracts/protocols/vault/vaultTypesCommon/common/variables.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.21;\\n\\nabstract contract Variables {\\n    /***********************************|\\n    |         Storage Variables         |\\n    |__________________________________*/\\n\\n    /// note: in all variables. For tick >= 0 are represented with bit as 1, tick < 0 are represented with bit as 0\\n    /// note: read all the variables through storageRead.sol\\n\\n    /// note: vaultVariables contains vault variables which need regular updates through transactions\\n    /// First 1 bit => 0 => re-entrancy. If 0 then allow transaction to go, else throw.\\n    /// Next 1 bit => 1 => Is the current active branch liquidated? If true then check the branch's minima tick before creating a new position\\n    /// If the new tick is greater than minima tick then initialize a new branch, make that as current branch & do proper linking\\n    /// Next 1 bit => 2 => sign of topmost tick (0 -> negative; 1 -> positive)\\n    /// Next 19 bits => 3-21 => absolute value of topmost tick\\n    /// Next 30 bits => 22-51 => current branch ID\\n    /// Next 30 bits => 52-81 => total branch ID\\n    /// Next 64 bits => 82-145 => Total supply\\n    /// Next 64 bits => 146-209 => Total borrow\\n    /// Next 32 bits => 210-241 => Total positions\\n    uint256 internal vaultVariables;\\n\\n    /// note: vaultVariables2 contains variables which do not update on every transaction. So mainly admin/auth set amount\\n    /// First 16 bits => 0-15 => supply rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\\n    /// Next 16 bits => 16-31 => borrow rate magnifier; 10000 = 1x (Here 16 bits should be more than enough)\\n    /// Next 10 bits => 32-41 => collateral factor. 800 = 0.8 = 80% (max precision of 0.1%)\\n    /// Next 10 bits => 42-51 => liquidation Threshold. 900 = 0.9 = 90% (max precision of 0.1%)\\n    /// Next 10 bits => 52-61 => liquidation Max Limit. 950 = 0.95 = 95% (max precision of 0.1%) (above this 100% liquidation can happen)\\n    /// Next 10 bits => 62-71 => withdraw gap. 100 = 0.1 = 10%. (max precision of 0.1%) (max 7 bits can also suffice for the requirement here of 0.1% to 10%). Needed to save some limits on withdrawals so liquidate can work seamlessly.\\n    /// Next 10 bits => 72-81 => liquidation penalty. 100 = 0.01 = 1%. (max precision of 0.01%) (max liquidation penantly can be 10.23%). Applies when tick is in between liquidation Threshold & liquidation Max Limit.\\n    /// Next 10 bits => 82-91 => borrow fee. 100 = 0.01 = 1%. (max precision of 0.01%) (max borrow fee can be 10.23%). Fees on borrow.\\n    /// Next 30 bits => 92-121 => bits to calculate address of oracle\\n    /// Next 33 bits => 122-154 => last update timestamp\\n    uint256 internal vaultVariables2;\\n\\n    /// note: stores absorbed liquidity\\n    /// First 128 bits raw debt amount\\n    /// last 128 bits raw col amount\\n    uint256 internal absorbedLiquidity;\\n\\n    /// position index => position data uint\\n    /// if the entire variable is 0 (meaning not initialized) at the start that means no position at all\\n    /// First 1 bit => 0 => position type (0 => borrow position; 1 => supply position)\\n    /// Next 1 bit => 1 => sign of user's tick (0 => negative; 1 => positive)\\n    /// Next 19 bits => 2-20 => absolute value of user's tick\\n    /// Next 24 bits => 21-44 => user's tick's id\\n    /// Below we are storing user's collateral & not debt, because the position can also be only collateral with no tick but it can never be only debt\\n    /// Next 64 bits => 45-108 => user's supply amount. Debt will be calculated through supply & ratio.\\n    /// Next 64 bits => 109-172 => user's dust debt amount. User's net debt = total debt - dust amount. Total debt is calculated through supply & ratio\\n    /// User won't pay any extra interest on dust debt & hence we will not show it as a debt on UI. For user's there's no dust.\\n    mapping(uint256 => uint256) internal positionData;\\n\\n    /// Tick has debt only keeps data of non liquidated positions. liquidated tick's data stays in branch itself\\n    /// tick parent => uint (represents bool for 256 children)\\n    /// parent of (i)th tick:-\\n    /// if (i>=0) (i / 256);\\n    /// else ((i + 1) / 256) - 1\\n    /// first bit of the variable is the smallest tick & last bit is the biggest tick of that slot\\n    mapping(int256 => uint256) internal tickHasDebt;\\n\\n    /// mapping tickId => tickData\\n    /// Tick related data. Total debt & other things\\n    /// First bit => 0 => If 1 then liquidated else not liquidated\\n    /// Next 24 bits => 1-24 => Total IDs. ID should start from 1.\\n    /// If not liquidated:\\n    /// Next 64 bits => 25-88 => raw debt\\n    /// If liquidated\\n    /// The below 3 things are of last ID. This is to be updated when user creates a new position\\n    /// Next 1 bit => 25 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated (100% liquidated)\\n    /// Next 30 bits => 26-55 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 56-105 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    mapping(int256 => uint256) internal tickData;\\n\\n    /// tick id => previous tick id liquidation data. ID starts from 1\\n    /// One tick ID contains 3 IDs of 80 bits in it, holding liquidation data of previously active but liquidated ticks\\n    /// 81 bits data below\\n    /// #### First 85 bits ####\\n    /// 1st bit => 0 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\\n    /// Next 30 bits => 1-30 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 31-80 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    /// #### Second 85 bits ####\\n    /// 85th bit => 85 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\\n    /// Next 30 bits => 86-115 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 116-165 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    /// #### Third 85 bits ####\\n    /// 170th bit => 170 => Is 100% liquidated? If this is 1 meaning it was above max tick when it got liquidated\\n    /// Next 30 bits => 171-200 => branch ID where this tick got liquidated\\n    /// Next 50 bits => 201-250 => debt factor 50 bits (35 bits coefficient | 15 bits expansion)\\n    mapping(int256 => mapping(uint256 => uint256)) internal tickId;\\n\\n    /// mapping branchId => branchData\\n    /// First 2 bits => 0-1 => if 0 then not liquidated, if 1 then liquidated, if 2 then merged, if 3 then closed\\n    /// merged means the branch is merged into it's base branch\\n    /// closed means all the users are 100% liquidated\\n    /// Next 1 bit => 2 => minima tick sign of this branch. Will only be there if any liquidation happened.\\n    /// Next 19 bits => 3-21 => minima tick of this branch. Will only be there if any liquidation happened.\\n    /// Next 30 bits => 22-51 => Partials of minima tick of branch this is connected to. 0 if master branch.\\n    /// Next 64 bits => 52-115 Debt liquidity at this branch. Similar to last's top tick data. Remaining debt will move here from tickData after first liquidation\\n    /// If not merged\\n    /// Next 50 bits => 116-165 => Debt factor or of this branch. (35 bits coefficient | 15 bits expansion)\\n    /// If merged\\n    /// Next 50 bits => 116-165 => Connection/adjustment debt factor of this branch with the next branch.\\n    /// If closed\\n    /// Next 50 bits => 116-165 => Debt factor as 0. As all the user's positions are now fully gone\\n    /// following values are present always again (merged / not merged / closed)\\n    /// Next 30 bits => 166-195 => Branch's ID with which this branch is connected. If 0 then that means this is the master branch\\n    /// Next 1 bit => 196 => sign of minima tick of branch this is connected to. 0 if master branch.\\n    /// Next 19 bits => 197-215 => minima tick of branch this is connected to. 0 if master branch.\\n    mapping(uint256 => uint256) internal branchData;\\n\\n    /// Exchange prices are in 1e12\\n    /// First 64 bits => 0-63 => Liquidity's collateral token supply exchange price\\n    /// First 64 bits => 64-127 => Liquidity's debt token borrow exchange price\\n    /// First 64 bits => 128-191 => Vault's collateral token supply exchange price\\n    /// First 64 bits => 192-255 => Vault's debt token borrow exchange price\\n    uint256 internal rates;\\n\\n    /// address of rebalancer\\n    address internal rebalancer;\\n\\n    uint256 internal absorbedDustDebt;\\n\\n    address internal dexFromAddress;\\n}\\n\",\"keccak256\":\"0x9570e35a881e0d48efe60f486744c4818f9ae87ae350b4aeab2bfbf499fef586\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610d68806100206000396000f3fe608060405234801561001057600080fd5b50600436106100c95760003560e01c806373d6c15a11610081578063b788f3a11161005b578063b788f3a1146101bf578063c419112d146101da578063ff29c37c146101ed57600080fd5b806373d6c15a146101595780638e2d939e1461016c57806395ae47e11461017f57600080fd5b80634cb1327d116100b25780634cb1327d1461011e5780636418fc6514610131578063695ac04a1461014657600080fd5b80631f51fd93146100ce5780633a216003146100fd575b600080fd5b6100e16100dc366004610c6e565b610200565b6040805192151583529015156020830152015b60405180910390f35b61011061010b366004610c6e565b6102f3565b6040519081526020016100f4565b61011061012c366004610c6e565b610405565b61014461013f366004610c90565b61050d565b005b610110610154366004610c6e565b61066d565b610144610167366004610c90565b610754565b61011061017a366004610c6e565b6108ab565b61019a731e2e1aed876f67fe4fd54090fd7b8f57ce23421981565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f4565b61019a734f6f977acdd1177dcd81ab83074855ecb9c2d49e81565b6101446101e8366004610c90565b610997565b6101446101fb366004610c90565b610aee565b6000808273ffffffffffffffffffffffffffffffffffffffff1663bb24fe8a6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015610288575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261028591810190610cba565b60015b61029757506000928392509050565b61271081036102ac5750600093849350915050565b614e2081036102c2575060019360009350915050565b61753081036102d8575060009360019350915050565b619c4081036102ed5750600193849350915050565b50915091565b6000806102ff83610200565b50905080610343576040517fd002e25a0000000000000000000000000000000000000000000000000000000081526201871a60048201526024015b60405180910390fd5b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009061ffff9073ffffffffffffffffffffffffffffffffffffffff86169063b5c736e490602401602060405180830381865afa1580156103b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d99190610cba565b169050617fff600182901c169250806001166000036103fe576103fb83610cd3565b92505b5050919050565b60008061041183610200565b91505080610450576040517fd002e25a0000000000000000000000000000000000000000000000000000000081526201871a600482015260240161033a565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009061ffff9060109073ffffffffffffffffffffffffffffffffffffffff87169063b5c736e490602401602060405180830381865afa1580156104c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104e99190610cba565b901c169050617fff600182901c169250806001166000036103fe576103fb83610cd3565b33734f6f977acdd1177dcd81ab83074855ecb9c2d49e148015906105455750731e2e1aed876f67fe4fd54090fd7b8f57ce2342193314155b15610581576040517fd002e25a00000000000000000000000000000000000000000000000000000000815262018719600482015260240161033a565b600061058c836108ab565b6040517ff7a0a7e00000000000000000000000000000000000000000000000000000000081526004810184905290915073ffffffffffffffffffffffffffffffffffffffff84169063f7a0a7e090602401600060405180830381600087803b1580156105f757600080fd5b505af115801561060b573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff87168152602081018590529081018590527fbbf9128b9ed96934bebc07311a806952804d4093b46bdb8e303206a8f12d9691925060600190505b60405180910390a1505050565b60008061067983610200565b50905080156106b9576040517fd002e25a0000000000000000000000000000000000000000000000000000000081526201871a600482015260240161033a565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015261ffff9073ffffffffffffffffffffffffffffffffffffffff85169063b5c736e490602401602060405180830381865afa158015610728573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074c9190610cba565b169392505050565b33734f6f977acdd1177dcd81ab83074855ecb9c2d49e1480159061078c5750731e2e1aed876f67fe4fd54090fd7b8f57ce2342193314155b156107c8576040517fd002e25a00000000000000000000000000000000000000000000000000000000815262018719600482015260240161033a565b60006107d38361066d565b6040517f4a138a710000000000000000000000000000000000000000000000000000000081526004810184905290915073ffffffffffffffffffffffffffffffffffffffff841690634a138a7190602401600060405180830381600087803b15801561083e57600080fd5b505af1158015610852573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff87168152602081018590529081018590527f4c9e86e08ce9d8f60b216cf0ed98f7b86ee64a87bcc36bf1c1c2b9a51928708992506060019050610660565b6000806108b783610200565b91505080156108f7576040517fd002e25a0000000000000000000000000000000000000000000000000000000081526201871a600482015260240161033a565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015261ffff9060109073ffffffffffffffffffffffffffffffffffffffff86169063b5c736e490602401602060405180830381865afa158015610969573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061098d9190610cba565b901c169392505050565b33734f6f977acdd1177dcd81ab83074855ecb9c2d49e148015906109cf5750731e2e1aed876f67fe4fd54090fd7b8f57ce2342193314155b15610a0b576040517fd002e25a00000000000000000000000000000000000000000000000000000000815262018719600482015260240161033a565b6000610a1683610405565b6040517fa269e7840000000000000000000000000000000000000000000000000000000081526004810184905290915073ffffffffffffffffffffffffffffffffffffffff84169063a269e78490602401600060405180830381600087803b158015610a8157600080fd5b505af1158015610a95573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff87168152602081018590529081018590527f56b582f7f6ada35b9644bbf7e6e7842b7706db0a24fd2e3ebb023d9c9a22ae7f92506060019050610660565b33734f6f977acdd1177dcd81ab83074855ecb9c2d49e14801590610b265750731e2e1aed876f67fe4fd54090fd7b8f57ce2342193314155b15610b62576040517fd002e25a00000000000000000000000000000000000000000000000000000000815262018719600482015260240161033a565b6000610b6d836102f3565b6040517fd90ed3550000000000000000000000000000000000000000000000000000000081526004810184905290915073ffffffffffffffffffffffffffffffffffffffff84169063d90ed35590602401600060405180830381600087803b158015610bd857600080fd5b505af1158015610bec573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff87168152602081018590529081018590527ff3a7a0e51e8107785482b598d1b3ec873e3134970a24a859f4ada9738e25908492506060019050610660565b803573ffffffffffffffffffffffffffffffffffffffff81168114610c6957600080fd5b919050565b600060208284031215610c8057600080fd5b610c8982610c45565b9392505050565b60008060408385031215610ca357600080fd5b610cac83610c45565b946020939093013593505050565b600060208284031215610ccc57600080fd5b5051919050565b60007f80000000000000000000000000000000000000000000000000000000000000008203610d2b577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b506000039056fea2646970667358221220b605199658f503db16318dc6818f27d223de81468cfd487ee7d22eeb24f673d764736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100c95760003560e01c806373d6c15a11610081578063b788f3a11161005b578063b788f3a1146101bf578063c419112d146101da578063ff29c37c146101ed57600080fd5b806373d6c15a146101595780638e2d939e1461016c57806395ae47e11461017f57600080fd5b80634cb1327d116100b25780634cb1327d1461011e5780636418fc6514610131578063695ac04a1461014657600080fd5b80631f51fd93146100ce5780633a216003146100fd575b600080fd5b6100e16100dc366004610c6e565b610200565b6040805192151583529015156020830152015b60405180910390f35b61011061010b366004610c6e565b6102f3565b6040519081526020016100f4565b61011061012c366004610c6e565b610405565b61014461013f366004610c90565b61050d565b005b610110610154366004610c6e565b61066d565b610144610167366004610c90565b610754565b61011061017a366004610c6e565b6108ab565b61019a731e2e1aed876f67fe4fd54090fd7b8f57ce23421981565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f4565b61019a734f6f977acdd1177dcd81ab83074855ecb9c2d49e81565b6101446101e8366004610c90565b610997565b6101446101fb366004610c90565b610aee565b6000808273ffffffffffffffffffffffffffffffffffffffff1663bb24fe8a6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015610288575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261028591810190610cba565b60015b61029757506000928392509050565b61271081036102ac5750600093849350915050565b614e2081036102c2575060019360009350915050565b61753081036102d8575060009360019350915050565b619c4081036102ed5750600193849350915050565b50915091565b6000806102ff83610200565b50905080610343576040517fd002e25a0000000000000000000000000000000000000000000000000000000081526201871a60048201526024015b60405180910390fd5b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009061ffff9073ffffffffffffffffffffffffffffffffffffffff86169063b5c736e490602401602060405180830381865afa1580156103b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d99190610cba565b169050617fff600182901c169250806001166000036103fe576103fb83610cd3565b92505b5050919050565b60008061041183610200565b91505080610450576040517fd002e25a0000000000000000000000000000000000000000000000000000000081526201871a600482015260240161033a565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015260009061ffff9060109073ffffffffffffffffffffffffffffffffffffffff87169063b5c736e490602401602060405180830381865afa1580156104c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104e99190610cba565b901c169050617fff600182901c169250806001166000036103fe576103fb83610cd3565b33734f6f977acdd1177dcd81ab83074855ecb9c2d49e148015906105455750731e2e1aed876f67fe4fd54090fd7b8f57ce2342193314155b15610581576040517fd002e25a00000000000000000000000000000000000000000000000000000000815262018719600482015260240161033a565b600061058c836108ab565b6040517ff7a0a7e00000000000000000000000000000000000000000000000000000000081526004810184905290915073ffffffffffffffffffffffffffffffffffffffff84169063f7a0a7e090602401600060405180830381600087803b1580156105f757600080fd5b505af115801561060b573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff87168152602081018590529081018590527fbbf9128b9ed96934bebc07311a806952804d4093b46bdb8e303206a8f12d9691925060600190505b60405180910390a1505050565b60008061067983610200565b50905080156106b9576040517fd002e25a0000000000000000000000000000000000000000000000000000000081526201871a600482015260240161033a565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015261ffff9073ffffffffffffffffffffffffffffffffffffffff85169063b5c736e490602401602060405180830381865afa158015610728573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074c9190610cba565b169392505050565b33734f6f977acdd1177dcd81ab83074855ecb9c2d49e1480159061078c5750731e2e1aed876f67fe4fd54090fd7b8f57ce2342193314155b156107c8576040517fd002e25a00000000000000000000000000000000000000000000000000000000815262018719600482015260240161033a565b60006107d38361066d565b6040517f4a138a710000000000000000000000000000000000000000000000000000000081526004810184905290915073ffffffffffffffffffffffffffffffffffffffff841690634a138a7190602401600060405180830381600087803b15801561083e57600080fd5b505af1158015610852573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff87168152602081018590529081018590527f4c9e86e08ce9d8f60b216cf0ed98f7b86ee64a87bcc36bf1c1c2b9a51928708992506060019050610660565b6000806108b783610200565b91505080156108f7576040517fd002e25a0000000000000000000000000000000000000000000000000000000081526201871a600482015260240161033a565b6040517fb5c736e40000000000000000000000000000000000000000000000000000000081526001600482015261ffff9060109073ffffffffffffffffffffffffffffffffffffffff86169063b5c736e490602401602060405180830381865afa158015610969573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061098d9190610cba565b901c169392505050565b33734f6f977acdd1177dcd81ab83074855ecb9c2d49e148015906109cf5750731e2e1aed876f67fe4fd54090fd7b8f57ce2342193314155b15610a0b576040517fd002e25a00000000000000000000000000000000000000000000000000000000815262018719600482015260240161033a565b6000610a1683610405565b6040517fa269e7840000000000000000000000000000000000000000000000000000000081526004810184905290915073ffffffffffffffffffffffffffffffffffffffff84169063a269e78490602401600060405180830381600087803b158015610a8157600080fd5b505af1158015610a95573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff87168152602081018590529081018590527f56b582f7f6ada35b9644bbf7e6e7842b7706db0a24fd2e3ebb023d9c9a22ae7f92506060019050610660565b33734f6f977acdd1177dcd81ab83074855ecb9c2d49e14801590610b265750731e2e1aed876f67fe4fd54090fd7b8f57ce2342193314155b15610b62576040517fd002e25a00000000000000000000000000000000000000000000000000000000815262018719600482015260240161033a565b6000610b6d836102f3565b6040517fd90ed3550000000000000000000000000000000000000000000000000000000081526004810184905290915073ffffffffffffffffffffffffffffffffffffffff84169063d90ed35590602401600060405180830381600087803b158015610bd857600080fd5b505af1158015610bec573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff87168152602081018590529081018590527ff3a7a0e51e8107785482b598d1b3ec873e3134970a24a859f4ada9738e25908492506060019050610660565b803573ffffffffffffffffffffffffffffffffffffffff81168114610c6957600080fd5b919050565b600060208284031215610c8057600080fd5b610c8982610c45565b9392505050565b60008060408385031215610ca357600080fd5b610cac83610c45565b946020939093013593505050565b600060208284031215610ccc57600080fd5b5051919050565b60007f80000000000000000000000000000000000000000000000000000000000000008203610d2b577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b506000039056fea2646970667358221220b605199658f503db16318dc6818f27d223de81468cfd487ee7d22eeb24f673d764736f6c63430008150033",
  "devdoc": {
    "events": {
      "LogUpdateBorrowRate(address,int256,int256)": {
        "params": {
          "newBorrowRate": "The new borrow rate value",
          "oldBorrowRate": "The previous borrow rate value",
          "vault": "The address of the vault"
        }
      },
      "LogUpdateBorrowRateMagnifier(address,uint256,uint256)": {
        "params": {
          "newBorrowRateMagnifier": "The new borrow rate magnifier value",
          "oldBorrowRateMagnifier": "The previous borrow rate magnifier value",
          "vault": "The address of the vault"
        }
      },
      "LogUpdateSupplyRate(address,int256,int256)": {
        "params": {
          "newSupplyRate": "The new supply rate value",
          "oldSupplyRate": "The previous supply rate value",
          "vault": "The address of the vault"
        }
      },
      "LogUpdateSupplyRateMagnifier(address,uint256,uint256)": {
        "params": {
          "newSupplyRateMagnifier": "The new supply rate magnifier value",
          "oldSupplyRateMagnifier": "The previous supply rate magnifier value",
          "vault": "The address of the vault"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "currentBorrowRate(address)": {
        "params": {
          "smartDebtVault_": "The address of the SMART DEBT vault to query."
        },
        "returns": {
          "borrowRate_": "The current borrow rate value."
        }
      },
      "currentBorrowRateMagnifier(address)": {
        "params": {
          "normalDebtVault_": "The address of the NORMAL DEBT vault to query."
        },
        "returns": {
          "_0": "The current borrow rate magnifier value."
        }
      },
      "currentSupplyRate(address)": {
        "params": {
          "smartColVault_": "The address of the SMART COL vault to query."
        },
        "returns": {
          "supplyRate_": "The current supply rate value."
        }
      },
      "currentSupplyRateMagnifier(address)": {
        "params": {
          "normalColVault_": "The address of the NORMAL COL vault to query."
        },
        "returns": {
          "_0": "The current supply rate magnifier value."
        }
      },
      "getVaultType(address)": {
        "params": {
          "vault_": "The address of the vault."
        },
        "returns": {
          "isSmartCol_": "True if the vault is a SMART COL vault, false otherwise.",
          "isSmartDebt_": "True if the vault is a SMART DEBT vault, false otherwise."
        }
      },
      "updateBorrowRate(address,int256)": {
        "params": {
          "newBorrowRate_": "The new borrow rate to set. Input in 1e2 (1% = 100, 100% = 10_000). If positive then charging else incentives",
          "smartDebtVault_": "The address of the SMART DEBT vault to update"
        }
      },
      "updateBorrowRateMagnifier(address,uint256)": {
        "params": {
          "newMagnifier_": "The new borrow rate magnifier value to set.",
          "normalDebtVault_": "The address of the NORMAL DEBT vault to update."
        }
      },
      "updateSupplyRate(address,int256)": {
        "params": {
          "newSupplyRate_": "The new supply rate to set. Input in 1e2 (1% = 100, 100% = 10_000). If positive then incentives else charging",
          "smartColVault_": "The address of the SMART COL vault to update"
        }
      },
      "updateSupplyRateMagnifier(address,uint256)": {
        "params": {
          "newMagnifier_": "The new supply rate magnifier value to set.",
          "normalColVault_": "The address of the NORMAL COL vault to update."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "LogUpdateBorrowRate(address,int256,int256)": {
        "notice": "emitted when borrow rate is updated at a vault"
      },
      "LogUpdateBorrowRateMagnifier(address,uint256,uint256)": {
        "notice": "emitted when borrow rate magnifier is updated at a vault"
      },
      "LogUpdateSupplyRate(address,int256,int256)": {
        "notice": "emitted when supply rate is updated at a vault"
      },
      "LogUpdateSupplyRateMagnifier(address,uint256,uint256)": {
        "notice": "emitted when supply rate magnifier is updated at a vault"
      }
    },
    "kind": "user",
    "methods": {
      "TEAM_MULTISIG()": {
        "notice": "Team multisig allowed to trigger collecting revenue"
      },
      "currentBorrowRate(address)": {
        "notice": "returns the currently configured borrow rate at the `vault_`"
      },
      "currentBorrowRateMagnifier(address)": {
        "notice": "returns the currently configured borrow rate magnifier at the `vault_`"
      },
      "currentSupplyRate(address)": {
        "notice": "returns the currently configured supply rate at the `vault_`"
      },
      "currentSupplyRateMagnifier(address)": {
        "notice": "returns the currently configured supply rate magnifier at the `vault_`"
      },
      "getVaultType(address)": {
        "notice": "Get the type of a vault (assumes valid Fluid vault address is passed in)"
      },
      "updateBorrowRate(address,int256)": {
        "notice": "updates the borrow rate for a given SMART DEBT vault."
      },
      "updateBorrowRateMagnifier(address,uint256)": {
        "notice": "Sets the borrow rate magnifier for a given NORMAL DEBT vault."
      },
      "updateSupplyRate(address,int256)": {
        "notice": "updates the supply rate for a given SMART COL vault."
      },
      "updateSupplyRateMagnifier(address,uint256)": {
        "notice": "Sets the supply rate magnifier for a given NORMAL COL vault."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}