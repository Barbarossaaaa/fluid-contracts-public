{
  "language": "Solidity",
  "sources": {
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/dexLiteSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex Lite.\nlibrary DexLiteSlotsLink {\n    /// @dev storage slot for is auth mapping\n    uint256 internal constant DEX_LITE_IS_AUTH_SLOT = 0;\n    /// @dev storage slot for dexes list\n    uint256 internal constant DEX_LITE_DEXES_LIST_SLOT = 1;\n    /// @dev storage slot for is dex variables\n    uint256 internal constant DEX_LITE_DEX_VARIABLES_SLOT = 2;\n    /// @dev storage slot for center price shift\n    uint256 internal constant DEX_LITE_CENTER_PRICE_SHIFT_SLOT = 3;\n    /// @dev storage slot for range shift\n    uint256 internal constant DEX_LITE_RANGE_SHIFT_SLOT = 4;\n    /// @dev storage slot for threshold shift\n    uint256 internal constant DEX_LITE_THRESHOLD_SHIFT_SLOT = 5;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // DexVariables\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_FEE = 0;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT = 13;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS = 20;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE = 22;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE = 23;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS = 63;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE = 82;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT = 83;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT = 97;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE = 111;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT = 112;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT = 119;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS = 126;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS = 131;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED = 136;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED = 196;\n\n    // CenterPriceShift\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP = 0;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME = 33;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE = 57;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE = 85;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT = 113;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT = 133;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP = 153;\n\n    // RangeShift\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT = 0;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT = 14;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT = 28;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP = 48;\n\n    // ThresholdShift\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT = 0;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT = 7;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT = 14;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP = 34;\n\n    // --------------------------------\n    // @dev stacked uint256 swapData for LogSwap event\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_DEX_ID = 0;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_SWAP_0_TO_1 = 64;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN = 65;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT = 125;\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, bytes32 key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/periphery/resolvers/dexLite/constantVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./interfaces.sol\";\n\nabstract contract ConstantVariables {\n    /*//////////////////////////////////////////////////////////////\n                                CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// bytes32(uint256(keccak256(\"FLUID_DEX_LITE_EXTRA_DATA\")) - 1)\n    bytes32 internal constant EXTRA_DATA_SLOT = 0x7e8134afb5ed35d36cb65e24b9a4712a52bb77d952806c1acf50970d2107797f;\n\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1\n    /// The exact slot which stored the admin address in infinite proxy of liquidity contracts\n    bytes32 internal constant LIQUIDITY_GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    bool internal constant SWAP_SINGLE = true;\n    bool internal constant SWAP_HOP = false;\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal constant NATIVE_TOKEN_DECIMALS = 18;\n    uint256 internal constant TOKENS_DECIMALS_PRECISION = 9;\n\n    uint8 internal constant MIN_TOKEN_DECIMALS = 6;\n    uint8 internal constant MAX_TOKEN_DECIMALS = 18;\n\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 20;\n    uint256 internal constant BIG_COEFFICIENT_SIZE = 32;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant X1 = 0x1;\n    uint256 internal constant X2 = 0x3;\n    uint256 internal constant X5 = 0x1f;\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X13 = 0x1fff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X19 = 0x7ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X56 = 0xffffffffffffff;\n    uint256 internal constant X60 = 0xfffffffffffffff;\n    uint256 internal constant X73 = 0x1ffffffffffffffffff;\n    uint256 internal constant X120 = 0xffffffffffffffffffffffffffffff;\n    uint256 internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n   \n    uint256 internal constant TWO_DECIMALS = 1e2;\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant SIX_DECIMALS = 1e6;\n\n    uint256 internal constant PRICE_PRECISION = 1e27;\n\n    /// after swap token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_SWAP\n    /// after swap token1 reserves should not be less than token0InToken1 / MINIMUM_LIQUIDITY_SWAP\n    uint256 internal constant MINIMUM_LIQUIDITY_SWAP = 1e4;\n\n    bytes32 internal constant ESTIMATE_SWAP = keccak256(bytes(\"ESTIMATE_SWAP\"));\n}\n"
    },
    "contracts/periphery/resolvers/dexLite/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./immutableVariables.sol\";\nimport { DexLiteSlotsLink as DSL } from \"../../../libraries/dexLiteSlotsLink.sol\";\nimport { AddressCalcs as AC } from \"../../../libraries/addressCalcs.sol\";\nimport { FixedPointMathLib as FPM } from \"solmate/src/utils/FixedPointMathLib.sol\";\n\nabstract contract Helpers is ImmutableVariables {\n    function _readDexKeyAtIndex(uint256 index) internal view returns (DexKey memory) {\n        bytes32 baseSlot = keccak256(abi.encode(DSL.DEX_LITE_DEXES_LIST_SLOT));\n\n        // Each DexKey takes 3 storage slots (token0, token1, salt)\n        address token0 = address(uint160(uint256(DEX_LITE.readFromStorage(bytes32(uint256(baseSlot) + index * 3)))));\n        address token1 = address(\n            uint160(uint256(DEX_LITE.readFromStorage(bytes32(uint256(baseSlot) + index * 3 + 1))))\n        );\n        bytes32 salt = DEX_LITE.readFromStorage(bytes32(uint256(baseSlot) + index * 3 + 2));\n\n        return DexKey(token0, token1, salt);\n    }\n\n    function _calculateDexId(DexKey memory dexKey_) internal pure returns (bytes8) {\n        return bytes8(keccak256(abi.encode(dexKey_)));\n    }\n\n    function _calculatePoolStateSlot(bytes8 dexId, uint256 baseSlot) internal pure returns (bytes32) {\n        return keccak256(abi.encode(bytes32(dexId), baseSlot));\n    }\n\n    function _readPoolState(\n        bytes8 dexId_\n    )\n        internal\n        view\n        returns (uint256 dexVariables_, uint256 centerPriceShift_, uint256 rangeShift_, uint256 thresholdShift_)\n    {\n        dexVariables_ = uint256(\n            DEX_LITE.readFromStorage(_calculatePoolStateSlot(dexId_, DSL.DEX_LITE_DEX_VARIABLES_SLOT))\n        );\n        centerPriceShift_ = uint256(\n            DEX_LITE.readFromStorage(_calculatePoolStateSlot(dexId_, DSL.DEX_LITE_CENTER_PRICE_SHIFT_SLOT))\n        );\n        rangeShift_ = uint256(DEX_LITE.readFromStorage(_calculatePoolStateSlot(dexId_, DSL.DEX_LITE_RANGE_SHIFT_SLOT)));\n        thresholdShift_ = uint256(\n            DEX_LITE.readFromStorage(_calculatePoolStateSlot(dexId_, DSL.DEX_LITE_THRESHOLD_SHIFT_SLOT))\n        );\n    }\n\n    function _unpackDexVariables(uint256 dexVariables_) internal view returns (DexVariables memory) {\n        bool isCenterPriceShiftActive_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE) &\n            X1 ==\n            1;\n\n        uint256 centerPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n\n        address centerPriceContractAddress_ = AC.addressCalc(\n            DEPLOYER_CONTRACT,\n            (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) & X19\n        );\n        bool isRangePercentShiftActive_ = (dexVariables_ >>\n            DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) &\n            X1 ==\n            1;\n        bool isThresholdPercentShiftActive_ = (dexVariables_ >>\n            DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) &\n            X1 ==\n            1;\n\n        return\n            DexVariables(\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) & X13,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) & X7,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) & X2,\n                isCenterPriceShiftActive_,\n                centerPrice_,\n                centerPriceContractAddress_,\n                isRangePercentShiftActive_,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14,\n                isThresholdPercentShiftActive_,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) & X7,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) & X7,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60,\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60\n            );\n    }\n\n    function _unpackCenterPriceShift(uint256 centerPriceShift_) internal pure returns (CenterPriceShift memory) {\n        uint256 maxCenterPrice_ = (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) & X28;\n        maxCenterPrice_ = (maxCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (maxCenterPrice_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 minCenterPrice_ = (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE) & X28;\n        minCenterPrice_ = (minCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (minCenterPrice_ & DEFAULT_EXPONENT_MASK);\n\n        return\n            CenterPriceShift(\n                (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33,\n                (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24,\n                maxCenterPrice_,\n                minCenterPrice_,\n                (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT) & X20,\n                (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT) & X20,\n                (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP) & X33\n            );\n    }\n\n    function _unpackRangeShift(uint256 rangeShift_) internal pure returns (RangeShift memory) {\n        return\n            RangeShift(\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT) & X14,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT) & X14,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT) & X20,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP) & X33\n            );\n    }\n\n    function _unpackThresholdShift(uint256 thresholdShift_) internal pure returns (ThresholdShift memory) {\n        return\n            ThresholdShift(\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT) & X7,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT) & X7,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT) & X20,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP) & X33\n            );\n    }\n\n    /// @dev getting reserves outside range.\n    /// @param gp_ is geometric mean pricing of upper percent & lower percent\n    /// @param pa_ price of upper range or lower range\n    /// @param rx_ real reserves of token0 or token1\n    /// @param ry_ whatever is rx_ the other will be ry_\n    function _calculateReservesOutsideRange(\n        uint256 gp_,\n        uint256 pa_,\n        uint256 rx_,\n        uint256 ry_\n    ) internal pure returns (uint256 xa_, uint256 yb_) {\n        // equations we have:\n        // 1. x*y = k\n        // 2. xa*ya = k\n        // 3. xb*yb = k\n        // 4. Pa = ya / xa = upperRange_ (known)\n        // 5. Pb = yb / xb = lowerRange_ (known)\n        // 6. x - xa = rx = real reserve of x (known)\n        // 7. y - yb = ry = real reserve of y (known)\n        // With solving we get:\n        // ((Pa*Pb)^(1/2) - Pa)*xa^2 + (rx * (Pa*Pb)^(1/2) + ry)*xa + rx*ry = 0\n        // yb = yb = xa * (Pa * Pb)^(1/2)\n\n        // xa = (GP⋅rx + ry + (-rx⋅ry⋅4⋅(GP - Pa) + (GP⋅rx + ry)^2)^0.5) / (2Pa - 2GP)\n        // multiply entire equation by 1e27 to remove the price decimals precision of 1e27\n        // xa = (GP⋅rx + ry⋅1e27 + (rx⋅ry⋅4⋅(Pa - GP)⋅1e27 + (GP⋅rx + ry⋅1e27)^2)^0.5) / 2*(Pa - GP)\n        // dividing the equation with 2*(Pa - GP). Pa is always > GP so answer will be positive.\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅4⋅(Pa - GP)⋅1e27) / 4*(Pa - GP)^2) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅1e27) / (Pa - GP)) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n\n        // dividing in 3 parts for simplification:\n        // part1 = (Pa - GP)\n        // part2 = (GP⋅rx + ry⋅1e27) / (2*part1)\n        // part3 = rx⋅ry\n        // note: part1 will almost always be < 1e28 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e29\n        unchecked {\n            uint256 p1_ = pa_ - gp_;\n            uint256 p2_ = ((gp_ * rx_) + (ry_ * PRICE_PRECISION)) / (2 * p1_);\n\n            // removed <1e50 check becuase rx_ * ry_ will never be greater than 1e50\n            // Directly used p3_ below instead of using a variable for it\n            // uint256 p3_ = (rx_ * ry_ * PRICE_PRECISION) / p1_;\n\n            // xa = part2 + (part3 + (part2 * part2))^(1/2)\n            // yb = xa_ * gp_\n            xa_ = p2_ + FPM.sqrt((((rx_ * ry_ * PRICE_PRECISION) / p1_) + (p2_ * p2_)));\n            yb_ = (xa_ * gp_) / PRICE_PRECISION;\n        }\n    }\n\n    function _calcShiftingDone(\n        uint256 current_,\n        uint256 old_,\n        uint256 timePassed_,\n        uint256 shiftDuration_\n    ) internal pure returns (uint256) {\n        unchecked {\n            if (current_ > old_) {\n                return (old_ + (((current_ - old_) * timePassed_) / shiftDuration_));\n            } else {\n                return (old_ - (((old_ - current_) * timePassed_) / shiftDuration_));\n            }\n        }\n    }\n\n    function _calcRangeShifting(\n        uint256 upperRange_,\n        uint256 lowerRange_,\n        uint256 rangeShift_\n    ) internal returns (uint256, uint256) {\n        // rangeShift_ = _rangeShift[dexId_];\n        uint256 shiftDuration_ = (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT) & X20;\n        uint256 startTimeStamp_ = (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP) & X33;\n\n        uint256 timePassed_;\n        unchecked {\n            if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n                // shifting fully done\n                // delete _rangeShift[dexId_];\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables only updates from this function and _calcThresholdShifting.\n                // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE);\n                return (upperRange_, lowerRange_);\n            }\n            timePassed_ = block.timestamp - startTimeStamp_;\n        }\n        return (\n            _calcShiftingDone(\n                upperRange_,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT) & X14,\n                timePassed_,\n                shiftDuration_\n            ),\n            _calcShiftingDone(\n                lowerRange_,\n                (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT) & X14,\n                timePassed_,\n                shiftDuration_\n            )\n        );\n    }\n\n    function _calcThresholdShifting(\n        uint256 upperThreshold_,\n        uint256 lowerThreshold_,\n        uint256 thresholdShift_\n    ) internal returns (uint256, uint256) {\n        // uint256 thresholdShift_ = _thresholdShift[dexId_];\n        uint256 shiftDuration_ = (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT) & X20;\n        uint256 startTimeStamp_ = (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP) & X33;\n\n        uint256 timePassed_;\n        unchecked {\n            if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n                // shifting fully done\n                // delete _thresholdShift[dexId_];\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcRangeShifting.\n                // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE);\n                return (upperThreshold_, lowerThreshold_);\n            }\n            timePassed_ = block.timestamp - startTimeStamp_;\n        }\n        return (\n            _calcShiftingDone(\n                upperThreshold_,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT) & X7,\n                timePassed_,\n                shiftDuration_\n            ),\n            _calcShiftingDone(\n                lowerThreshold_,\n                (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT) & X7,\n                timePassed_,\n                shiftDuration_\n            )\n        );\n    }\n\n    function _calcCenterPrice(\n        DexKey memory dexKey_,\n        uint256 dexVariables_,\n        uint256 centerPriceShift_\n    ) internal returns (uint256 newCenterPrice_) {\n        uint256 oldCenterPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n        oldCenterPrice_ = (oldCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (oldCenterPrice_ & DEFAULT_EXPONENT_MASK);\n        // uint256 centerPriceShift_ = _centerPriceShift[dexId_];\n        uint256 startTimeStamp_ = (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP) & X33;\n\n        uint256 fromTimeStamp_ = (centerPriceShift_ >>\n            DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33;\n        fromTimeStamp_ = fromTimeStamp_ > startTimeStamp_ ? fromTimeStamp_ : startTimeStamp_;\n\n        newCenterPrice_ = ICenterPrice(\n            AC.addressCalc(\n                DEPLOYER_CONTRACT,\n                ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) & X19)\n            )\n        ).centerPrice(dexKey_.token0, dexKey_.token1);\n\n        unchecked {\n            uint256 priceShift_ = (oldCenterPrice_ *\n                ((centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT) & X20) *\n                (block.timestamp - fromTimeStamp_)) /\n                (((centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT) & X20) * SIX_DECIMALS);\n\n            if (newCenterPrice_ > oldCenterPrice_) {\n                // shift on positive side\n                oldCenterPrice_ += priceShift_;\n                if (newCenterPrice_ > oldCenterPrice_) {\n                    newCenterPrice_ = oldCenterPrice_;\n                } else {\n                    // shifting fully done\n                    // _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n                    // making active shift as 0 because shift is over\n                    // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                    // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n                }\n            } else {\n                oldCenterPrice_ = oldCenterPrice_ > priceShift_ ? oldCenterPrice_ - priceShift_ : 0;\n                // In case of oldCenterPrice_ ending up 0, which could happen when a lot of time has passed (pool has no swaps for many days or weeks)\n                // then below we get into the else logic which will fully conclude shifting and return newCenterPrice_\n                // as it was fetched from the external center price source.\n                // not ideal that this would ever happen unless the pool is not in use and all/most users have left leaving not enough liquidity to trade on\n                if (newCenterPrice_ < oldCenterPrice_) {\n                    newCenterPrice_ = oldCenterPrice_;\n                } else {\n                    // shifting fully done\n                    // _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n                    // making active shift as 0 because shift is over\n                    // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                    // _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates and returns the current prices and exchange prices for the pool\n    /// @param dexVariables_ The first set of DEX variables containing various pool parameters\n    function _getPricesAndReserves(\n        DexKey memory dexKey_,\n        uint256 dexVariables_,\n        uint256 centerPriceShift_,\n        uint256 rangeShift_,\n        uint256 thresholdShift_,\n        uint256 token0Supply_,\n        uint256 token1Supply_\n    ) internal returns (Prices memory prices_, Reserves memory reserves_) {\n        // Fetch center price\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE) & X1) == 0) {\n            // prices_.centerPrice => center price nonce\n            prices_.centerPrice =\n                (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) &\n                X19;\n            if (prices_.centerPrice == 0) {\n                prices_.centerPrice = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n                prices_.centerPrice =\n                    (prices_.centerPrice >> DEFAULT_EXPONENT_SIZE) <<\n                    (prices_.centerPrice & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n                prices_.centerPrice = ICenterPrice(AC.addressCalc(DEPLOYER_CONTRACT, prices_.centerPrice))\n                    .centerPrice(dexKey_.token0, dexKey_.token1);\n            }\n        } else {\n            // an active prices_.centerPrice shift is going on\n            prices_.centerPrice = _calcCenterPrice(dexKey_, dexVariables_, centerPriceShift_);\n        }\n\n        uint256 upperRangePercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14;\n        uint256 lowerRangePercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14;\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) & X1) == 1) {\n            // an active range shift is going on\n            (upperRangePercent_, lowerRangePercent_) = _calcRangeShifting(\n                upperRangePercent_,\n                lowerRangePercent_,\n                rangeShift_\n            );\n        }\n\n        unchecked {\n            // 1% = 1e2, 100% = 1e4\n            prices_.upperRangePrice = (prices_.centerPrice * FOUR_DECIMALS) / (FOUR_DECIMALS - upperRangePercent_);\n            // 1% = 1e2, 100% = 1e4\n            prices_.lowerRangePrice = (prices_.centerPrice * (FOUR_DECIMALS - lowerRangePercent_)) / FOUR_DECIMALS;\n        }\n\n        // Rebalance center price if rebalancing is on\n        // temp_ => rebalancingStatus_\n        uint256 temp_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) & X2;\n        uint256 temp2_;\n        if (temp_ > 1) {\n            unchecked {\n                // temp2_ => centerPriceShift_\n                if (temp_ == 2) {\n                    temp2_ = centerPriceShift_;\n                    uint256 shiftingTime_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24;\n                    uint256 timeElapsed_ = block.timestamp -\n                        ((temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33);\n                    // price shifting towards upper range\n                    if (timeElapsed_ < shiftingTime_) {\n                        prices_.centerPrice =\n                            prices_.centerPrice +\n                            (((prices_.upperRangePrice - prices_.centerPrice) * timeElapsed_) / shiftingTime_);\n                    } else {\n                        // 100% price shifted\n                        prices_.centerPrice = prices_.upperRangePrice;\n                    }\n                } else if (temp_ == 3) {\n                    temp2_ = centerPriceShift_;\n                    uint256 shiftingTime_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24;\n                    uint256 timeElapsed_ = block.timestamp -\n                        ((temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33);\n                    // price shifting towards lower range\n                    if (timeElapsed_ < shiftingTime_) {\n                        prices_.centerPrice =\n                            prices_.centerPrice -\n                            (((prices_.centerPrice - prices_.lowerRangePrice) * timeElapsed_) / shiftingTime_);\n                    } else {\n                        // 100% price shifted\n                        prices_.centerPrice = prices_.lowerRangePrice;\n                    }\n                }\n\n                // If rebalancing actually happened then make sure price is within min and max bounds, and update range prices\n                if (temp2_ > 0) {\n                    // Make sure center price is within min and max bounds\n                    // temp_ => max center price\n                    temp_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) & X28;\n                    temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n                    if (prices_.centerPrice > temp_) {\n                        // if center price is greater than max center price\n                        prices_.centerPrice = temp_;\n                    } else {\n                        // check if center price is less than min center price\n                        // temp_ => min center price\n                        temp_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE) & X28;\n                        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n                        if (prices_.centerPrice < temp_) prices_.centerPrice = temp_;\n                    }\n\n                    // Update range prices as center price moved\n                    prices_.upperRangePrice =\n                        (prices_.centerPrice * FOUR_DECIMALS) /\n                        (FOUR_DECIMALS - upperRangePercent_);\n                    prices_.lowerRangePrice =\n                        (prices_.centerPrice * (FOUR_DECIMALS - lowerRangePercent_)) /\n                        FOUR_DECIMALS;\n                }\n            }\n        }\n\n        // Calculate threshold prices\n        uint256 upperThresholdPercent_ = (dexVariables_ >>\n            DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) & X7;\n        uint256 lowerThresholdPercent_ = (dexVariables_ >>\n            DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) & X7;\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) & X1) == 1) {\n            // if active shift is going on for threshold then calculate threshold real time\n            (upperThresholdPercent_, lowerThresholdPercent_) = _calcThresholdShifting(\n                upperThresholdPercent_,\n                lowerThresholdPercent_,\n                thresholdShift_\n            );\n        }\n\n        unchecked {\n            prices_.upperThresholdPrice = (prices_.centerPrice +\n                ((prices_.upperRangePrice - prices_.centerPrice) * (TWO_DECIMALS - upperThresholdPercent_)) /\n                TWO_DECIMALS);\n            prices_.lowerThresholdPrice = (prices_.centerPrice -\n                ((prices_.centerPrice - prices_.lowerRangePrice) * (TWO_DECIMALS - lowerThresholdPercent_)) /\n                TWO_DECIMALS);\n        }\n\n        // temp_ => geometricMeanPrice_\n        unchecked {\n            if (prices_.upperRangePrice < 1e38) {\n                // 1e38 * 1e38 = 1e76 which is less than max uint limit\n                temp_ = FPM.sqrt(prices_.upperRangePrice * prices_.lowerRangePrice);\n            } else {\n                // upperRange_ price is pretty large hence lowerRange_ will also be pretty large\n                temp_ =\n                    FPM.sqrt((prices_.upperRangePrice / 1e18) * (prices_.lowerRangePrice / 1e18)) *\n                    1e18;\n            }\n        }\n\n        if (temp_ < 1e27) {\n            (reserves_.token0ImaginaryReserves, reserves_.token1ImaginaryReserves) = _calculateReservesOutsideRange(\n                temp_,\n                prices_.upperRangePrice,\n                token0Supply_,\n                token1Supply_\n            );\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            unchecked {\n                (reserves_.token1ImaginaryReserves, reserves_.token0ImaginaryReserves) = _calculateReservesOutsideRange(\n                    (1e54 / temp_),\n                    (1e54 / prices_.lowerRangePrice),\n                    token1Supply_,\n                    token0Supply_\n                );\n            }\n        }\n\n        unchecked {\n            reserves_.token0ImaginaryReserves += token0Supply_;\n            reserves_.token1ImaginaryReserves += token1Supply_;\n            reserves_.token0RealReserves = token0Supply_;\n            reserves_.token1RealReserves = token1Supply_;\n        }\n\n        prices_.poolPrice = (reserves_.token1ImaginaryReserves * PRICE_PRECISION) / reserves_.token0ImaginaryReserves;\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexLite/immutableVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./constantVariables.sol\";\n\nabstract contract ImmutableVariables is ConstantVariables {\n    // IMMUTABLE VARIABLES\n    IDexLite internal immutable DEX_LITE;\n    address internal immutable LIQUIDITY;\n    address internal immutable DEPLOYER_CONTRACT;\n}"
    },
    "contracts/periphery/resolvers/dexLite/interfaces.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./structs.sol\";\nimport { ICenterPrice } from \"../../../protocols/dexLite/other/interfaces.sol\";\n\ninterface IDexLite {\n    function swapSingle(\n        DexKey calldata dexKey_, \n        bool swap0To1_, \n        int256 amountSpecified_,\n        uint256 amountLimit_,\n        address to_,\n        bool isCallback_,\n        bytes calldata callbackData_,\n        bytes calldata extraData_\n    ) external payable returns (uint256 amountUnspecified_);\n\n    function swapHop(\n        address[] calldata path_,\n        DexKey[] calldata dexKeys_,\n        int256 amountSpecified_,\n        uint256[] calldata amountLimits_,\n        TransferParams calldata transferParams_\n    ) external payable returns (uint256 amountUnspecified_);\n\n    function readFromStorage(bytes32 slot) external view returns (bytes32);\n}"
    },
    "contracts/periphery/resolvers/dexLite/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./helpers.sol\";\n\ncontract FluidDexLiteResolver is Helpers {\n    constructor(address dexLite_, address liquidity_, address deployerContract_) {\n        DEX_LITE = IDexLite(dexLite_);\n        LIQUIDITY = liquidity_;\n        DEPLOYER_CONTRACT = deployerContract_;\n    }\n\n    function getAllDexes() public view returns (DexKey[] memory) {\n        uint256 totalDexes = uint256(DEX_LITE.readFromStorage(bytes32(DSL.DEX_LITE_DEXES_LIST_SLOT)));\n        DexKey[] memory dexes = new DexKey[](totalDexes);\n        for (uint256 i = 0; i < totalDexes; i++) {\n            dexes[i] = _readDexKeyAtIndex(i);\n        }\n        return dexes;\n    }\n\n    function getDexState(DexKey memory dexKey) public view returns (DexState memory) {\n        bytes8 dexId_ = _calculateDexId(dexKey);\n        (\n            uint256 dexVariables_,\n            uint256 centerPriceShift_,\n            uint256 rangeShift_,\n            uint256 thresholdShift_\n        ) = _readPoolState(dexId_);\n\n        return\n            DexState(\n                _unpackDexVariables(dexVariables_),\n                _unpackCenterPriceShift(centerPriceShift_),\n                _unpackRangeShift(rangeShift_),\n                _unpackThresholdShift(thresholdShift_)\n            );\n    }\n\n    function getPricesAndReserves(\n        DexKey memory dexKey\n    ) public returns (Prices memory prices_, Reserves memory reserves_) {\n        bytes8 dexId_ = _calculateDexId(dexKey);\n        (\n            uint256 dexVariables_,\n            uint256 centerPriceShift_,\n            uint256 rangeShift_,\n            uint256 thresholdShift_\n        ) = _readPoolState(dexId_);\n\n        uint256 token0Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5;\n        uint256 token1Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5;\n\n        uint256 token0Supply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60;\n        uint256 token1Supply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60;\n\n        return\n            _getPricesAndReserves(\n                dexKey,\n                dexVariables_,\n                centerPriceShift_,\n                rangeShift_,\n                thresholdShift_,\n                token0Supply_,\n                token1Supply_\n            );\n    }\n\n    function getDexEntireData(DexKey memory dexKey_) public returns (DexEntireData memory entireData_) {\n        entireData_.dexKey = dexKey_;\n        entireData_.constantViews = ConstantViews(\n            LIQUIDITY,\n            DEPLOYER_CONTRACT\n        );\n        entireData_.dexId = _calculateDexId(dexKey_);\n        entireData_.dexState = getDexState(dexKey_);\n        (entireData_.prices, entireData_.reserves) = getPricesAndReserves(dexKey_);\n    }\n\n    function getAllDexesEntireData() public returns (DexEntireData[] memory allDexesEntireData_) {\n        DexKey[] memory dexes_ = getAllDexes();\n        allDexesEntireData_ = new DexEntireData[](dexes_.length);\n        for (uint256 i = 0; i < dexes_.length; i++) {\n            allDexesEntireData_[i] = getDexEntireData(dexes_[i]);\n        }\n        return allDexesEntireData_;\n    }\n\n    function estimateSwapSingle(\n        DexKey calldata dexKey_,\n        bool swap0To1_,\n        int256 amountSpecified_\n    ) public returns (uint256 amountUnspecified_) {\n        try\n            DEX_LITE.swapSingle(\n                dexKey_,\n                swap0To1_,\n                amountSpecified_,\n                amountSpecified_ > 0 ? 0 : type(uint256).max,\n                address(0),\n                false,\n                \"\",\n                abi.encode(ESTIMATE_SWAP)\n            )\n        {\n            // Should not reach here\n            revert(\"Estimation Failed\");\n        } catch (bytes memory reason) {\n            // Check if this is the EstimateSwap error\n            if (reason.length >= 36) {\n                bytes4 errorSelector = bytes4(reason);\n                // EstimateSwap error selector should match\n                if (errorSelector == bytes4(keccak256(\"EstimateSwap(uint256)\"))) {\n                    // Skip the 4-byte selector and decode the uint256 parameter\n                    assembly {\n                        amountUnspecified_ := mload(add(reason, 36))\n                    }\n                } else {\n                    revert(\"Estimation Failed - Wrong Error\");\n                }\n            } else {\n                revert(\"Estimation Failed - Invalid Reason\");\n            }\n        }\n    }\n\n    function estimateSwapHop(\n        address[] calldata path_,\n        DexKey[] calldata dexKeys_,\n        int256 amountSpecified_\n    ) public returns (uint256 amountUnspecified_) {\n        uint256[] memory amountLimits_ = new uint256[](dexKeys_.length);\n        if (amountSpecified_ < 0) {\n            for (uint256 i = 0; i < dexKeys_.length; i++) {\n                amountLimits_[i] = type(uint256).max;\n            }\n        }\n\n        try\n            DEX_LITE.swapHop(\n                path_,\n                dexKeys_,\n                amountSpecified_,\n                amountLimits_,\n                TransferParams(address(0), false, \"\", abi.encode(ESTIMATE_SWAP))\n            )\n        {\n            // Should not reach here\n            revert(\"Estimation Failed\");\n        } catch (bytes memory reason) {\n            // Check if this is the EstimateSwap error\n            if (reason.length >= 36) {\n                bytes4 errorSelector = bytes4(reason);\n                // EstimateSwap error selector should match\n                if (errorSelector == bytes4(keccak256(\"EstimateSwap(uint256)\"))) {\n                    // Skip the 4-byte selector and decode the uint256 parameter\n                    assembly {\n                        amountUnspecified_ := mload(add(reason, 36))\n                    }\n                } else {\n                    revert(\"Estimation Failed - Wrong Error\");\n                }\n            } else {\n                revert(\"Estimation Failed - Invalid Reason\");\n            }\n        }\n    }\n}\n"
    },
    "contracts/periphery/resolvers/dexLite/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport { DexKey, TransferParams } from \"../../../protocols/dexLite/other/structs.sol\";\n\nstruct ConstantViews {\n    address liquidity;\n    address deployer;\n}\n\nstruct Prices {\n    uint256 poolPrice;\n    uint256 centerPrice;\n    uint256 upperRangePrice;\n    uint256 lowerRangePrice;\n    uint256 upperThresholdPrice;\n    uint256 lowerThresholdPrice;\n}\n\nstruct Reserves {\n    uint256 token0RealReserves;\n    uint256 token1RealReserves;\n    uint256 token0ImaginaryReserves;\n    uint256 token1ImaginaryReserves;\n}\n\nstruct DexVariables {\n    uint256 fee;\n    uint256 revenueCut;\n    uint256 rebalancingStatus;\n    bool isCenterPriceShiftActive;\n    uint256 centerPrice;\n    address centerPriceAddress;\n    bool isRangePercentShiftActive;\n    uint256 upperRangePercent;\n    uint256 lowerRangePercent;\n    bool isThresholdPercentShiftActive;\n    uint256 upperShiftThresholdPercent;\n    uint256 lowerShiftThresholdPercent;\n    uint256 token0Decimals;\n    uint256 token1Decimals;\n    uint256 totalToken0AdjustedAmount;\n    uint256 totalToken1AdjustedAmount;\n}\n\nstruct CenterPriceShift {\n    uint256 lastInteractionTimestamp;\n    // REBALANCING RELATED THINGS\n    uint256 rebalancingShiftingTime;\n    uint256 maxCenterPrice;\n    uint256 minCenterPrice;\n    // CENTER PRICE SHIFT RELATED THINGS\n    uint256 shiftPercentage;\n    uint256 centerPriceShiftingTime;\n    uint256 startTimestamp;\n}\n\nstruct RangeShift {\n    uint256 oldUpperRangePercent;\n    uint256 oldLowerRangePercent;\n    uint256 shiftingTime;\n    uint256 startTimestamp;\n}\n\nstruct ThresholdShift {\n    uint256 oldUpperThresholdPercent;\n    uint256 oldLowerThresholdPercent;\n    uint256 shiftingTime;\n    uint256 startTimestamp;\n}\n\nstruct DexState {\n    DexVariables dexVariables;\n    CenterPriceShift centerPriceShift;\n    RangeShift rangeShift;\n    ThresholdShift thresholdShift;\n}\n\nstruct DexEntireData {\n    bytes8 dexId;\n    DexKey dexKey;\n    ConstantViews constantViews;\n    Prices prices;\n    Reserves reserves;\n    DexState dexState;\n}"
    },
    "contracts/protocols/dexLite/other/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./interfaces.sol\";\n\nevent LogSwap(uint256 swapData, uint256 dexVariables);\n// swapData\n// First 64 bits => 0   - 63  => dexId\n// Next  1  bit  => 64        => swap 0 to 1 (1 => true, 0 => false)\n// Next  60 bits => 65  - 124 => amount in adjusted\n// Next  60 bits => 125 - 184 => amount out adjusted\n\n// dexVariables\n// Same as variables.sol"
    },
    "contracts/protocols/dexLite/other/interfaces.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport \"./structs.sol\";\n\ninterface IERC20WithDecimals is IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ninterface IDexLiteCallback {\n    function dexCallback(address token_, uint256 amount_, bytes calldata data_) external;\n}\n\ninterface ICenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price The current price of token0 in terms of token1, expressed with 27 decimal places\n    function centerPrice(address token0_, address token1_) external returns (uint256);\n}"
    },
    "contracts/protocols/dexLite/other/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./events.sol\";\n\nstruct DexKey {\n    address token0;\n    address token1;\n    bytes32 salt;\n}\n\nstruct TransferParams {\n    address to;\n    bool isCallback;\n    bytes callbackData;\n    bytes extraData;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}