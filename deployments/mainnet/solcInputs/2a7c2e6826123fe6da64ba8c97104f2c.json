{
  "language": "Solidity",
  "sources": {
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399584 = 10000101010010110100000011111011110010100110100000000011100101001101001101011100000\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n\n    /// @dev gets the least significant bit `firstBit` of a `normal` number (position of rightmost 1 in binary format).\n    /// e.g.\n    /// 5035703444687813576399584 = 10000101010010110100000011111011110010100110100000000011100101001101001101011100000\n    /// firstBit =                                                                                               ^-6--^\n    function leastSignificantBit(uint256 normal) internal pure returns (uint firstBit) {\n        assembly {\n            // If number is 0, revert as there is no least significant bit\n            if iszero(normal) {\n                revert(0, 0)\n            }\n\n            // Find first set bit using binary search\n            let number_ := normal\n            firstBit := 0\n\n            // Check if lower 128 bits are all zero\n            if iszero(and(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) {\n                number_ := shr(0x80, number_)\n                firstBit := 0x80\n            }\n            // Check if lower 64 bits are all zero\n            if iszero(and(number_, 0xFFFFFFFFFFFFFFFF)) {\n                number_ := shr(0x40, number_)\n                firstBit := add(firstBit, 0x40)\n            }\n            // Check if lower 32 bits are all zero\n            if iszero(and(number_, 0xFFFFFFFF)) {\n                number_ := shr(0x20, number_)\n                firstBit := add(firstBit, 0x20)\n            }\n            // Check if lower 16 bits are all zero\n            if iszero(and(number_, 0xFFFF)) {\n                number_ := shr(0x10, number_)\n                firstBit := add(firstBit, 0x10)\n            }\n            // Check if lower 8 bits are all zero\n            if iszero(and(number_, 0xFF)) {\n                number_ := shr(0x8, number_)\n                firstBit := add(firstBit, 0x8)\n            }\n            // Check if lower 4 bits are all zero\n            if iszero(and(number_, 0xF)) {\n                number_ := shr(0x4, number_)\n                firstBit := add(firstBit, 0x4)\n            }\n            // Check if lower 2 bits are all zero\n            if iszero(and(number_, 0x3)) {\n                number_ := shr(0x2, number_)\n                firstBit := add(firstBit, 0x2)\n            }\n            // Check if lowest bit is zero\n            if iszero(and(number_, 0x1)) {\n                firstBit := add(firstBit, 1)\n            }\n            // Add 1 to match the 1-based position counting\n            firstBit := add(firstBit, 1)\n        }\n    }\n}\n"
    },
    "contracts/libraries/dexLiteSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex Lite.\nlibrary DexLiteSlotsLink {\n    /// @dev storage slot for is auth mapping\n    uint256 internal constant DEX_LITE_IS_AUTH_SLOT = 0;\n    /// @dev storage slot for dexes list\n    uint256 internal constant DEX_LITE_DEXES_LIST_SLOT = 1;\n    /// @dev storage slot for is dex variables\n    uint256 internal constant DEX_LITE_DEX_VARIABLES_SLOT = 2;\n    /// @dev storage slot for center price shift\n    uint256 internal constant DEX_LITE_CENTER_PRICE_SHIFT_SLOT = 3;\n    /// @dev storage slot for range shift\n    uint256 internal constant DEX_LITE_RANGE_SHIFT_SLOT = 4;\n    /// @dev storage slot for threshold shift\n    uint256 internal constant DEX_LITE_THRESHOLD_SHIFT_SLOT = 5;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // DexVariables\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_FEE = 0;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT = 13;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS = 20;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE = 22;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE = 23;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS = 63;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE = 82;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT = 83;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT = 97;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE = 111;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT = 112;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT = 119;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS = 126;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS = 131;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED = 136;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED = 196;\n\n    // CenterPriceShift\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP = 0;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME = 33;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE = 57;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE = 85;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT = 113;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT = 133;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP = 153;\n\n    // RangeShift\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT = 0;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT = 14;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT = 28;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP = 48;\n\n    // ThresholdShift\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT = 0;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT = 7;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT = 14;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP = 34;\n\n    // --------------------------------\n    // @dev stacked uint256 swapData for LogSwap event\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_DEX_ID = 0;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_SWAP_0_TO_1 = 64;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN = 65;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT = 125;\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, bytes32 key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n\n    /***********************************|\n    |           SafeApprove             | \n    |__________________________________*/\n\n    /// @notice thrown when safe approve from for an ERC20 fails\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\n}\n"
    },
    "contracts/libraries/reentrancyLock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nlibrary ReentrancyLock {\n    // bytes32(uint256(keccak256(\"FLUID_REENTRANCY_LOCK\")) - 1)\n    bytes32 constant REENTRANCY_LOCK_SLOT = 0xb9cde754d19acfff2b3ccabc66f256d3563a0bc5805da4205f01a9bda38a2df7;\n\n    function lock() internal {\n        assembly {\n            if tload(REENTRANCY_LOCK_SLOT) { revert(0, 0) }\n            tstore(REENTRANCY_LOCK_SLOT, 1)\n        }\n    }\n\n    function unlock() internal {\n        assembly { tstore(REENTRANCY_LOCK_SLOT, 0) }\n    }\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/protocols/dexLite/adminModule/errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./structs.sol\";\n\nerror InvalidParams();\nerror OnlyDelegateCallAllowed();\nerror AddressNotAContract(address addr);\nerror InvalidTokenOrder(address token0, address token1);\nerror DexNotInitialized(bytes32 dexId);\nerror DexAlreadyInitialized(bytes32 dexId);\nerror InvalidRevenueCut(uint256 revenueCut);\nerror InsufficientMsgValue(uint256 msgValue, uint256 requiredAmount);"
    },
    "contracts/protocols/dexLite/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./errors.sol\";\n\nevent LogUpdateAuth(address auth, bool isAuth);\n\nevent LogInitialize(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 centerPriceShift, InitializeParams i);\n\nevent LogUpdateFeeAndRevenueCut(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 fee, uint256 revenueCut);\n\nevent LogUpdateRebalancingStatus(DexKey dexKey, bytes8 dexId, uint256 dexVariables, bool rebalancingStatus);\n\nevent LogUpdateRangePercents(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 rangeShift, uint256 upperPercent, uint256 lowerPercent, uint256 shiftTime);\n\nevent LogUpdateShiftTime(DexKey dexKey, bytes8 dexId, uint256 centerPriceShift, uint256 shiftTime);\n\nevent LogUpdateCenterPriceLimits(DexKey dexKey, bytes8 dexId, uint256 centerPriceShift, uint256 maxCenterPrice, uint256 minCenterPrice);\n\nevent LogUpdateThresholdPercent(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 thresholdShift, uint256 upperThresholdPercent, uint256 lowerThresholdPercent, uint256 shiftTime);\n\nevent LogUpdateCenterPriceAddress(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 centerPriceShift, uint256 centerPriceContract, uint256 percent, uint256 time);\n\nevent LogDeposit(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 token0Amount, uint256 token1Amount);\n\nevent LogWithdraw(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 token0Amount, uint256 token1Amount);\n\nevent LogCollectRevenue(address[] tokens, uint256[] amounts, address to);\n\nevent LogUpdateExtraDataAddress(address extraDataAddress);\n"
    },
    "contracts/protocols/dexLite/adminModule/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./immutableVariables.sol\";\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\n\nabstract contract AdminModuleHelpers is AdminModuleImmutableVariables {\n    modifier _onlyDelegateCall() {\n        if (address(this) == THIS_ADDRESS) revert OnlyDelegateCallAllowed();\n        _;\n    }\n\n    /// @dev checks that `value_` address is a contract (which includes address zero check)\n    function _checkIsContract(address value_) internal view {\n        if (value_.code.length == 0) {\n            revert AddressNotAContract(value_);\n        }\n    }\n\n    function _calculateNumeratorAndDenominatorPrecisions(uint256 decimals_) internal pure returns (uint256 numerator_, uint256 denominator_) {\n        if (decimals_ > TOKENS_DECIMALS_PRECISION) {\n            numerator_ = 1;\n            denominator_ = 10 ** (decimals_ - TOKENS_DECIMALS_PRECISION);\n        } else {\n            numerator_ = 10 ** (TOKENS_DECIMALS_PRECISION - decimals_);\n            denominator_ = 1;\n        }\n    }\n\n    function _transferTokenIn(address token_, uint256 amount_) internal {\n        if (amount_ == 0) return;\n\n        if (token_ == NATIVE_TOKEN) {\n            if (msg.value < amount_) revert InsufficientMsgValue(msg.value, amount_);\n            if (msg.value > amount_) SafeTransfer.safeTransferNative(msg.sender, msg.value - amount_);\n        } else SafeTransfer.safeTransferFrom(token_, msg.sender, address(this), amount_);\n    }\n\n    function _transferTokenOut(address token_, uint256 amount_, address to_) internal {\n        if (amount_ == 0) return;\n\n        if (token_ == NATIVE_TOKEN) SafeTransfer.safeTransferNative(to_, amount_);\n        else SafeTransfer.safeTransfer(token_, to_, amount_);\n    }\n}\n"
    },
    "contracts/protocols/dexLite/adminModule/immutableVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./events.sol\";\n\nabstract contract AdminModuleImmutableVariables is CommonImport {\n    address internal immutable THIS_ADDRESS;\n}\n"
    },
    "contracts/protocols/dexLite/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport { DexLiteSlotsLink as DSL } from \"../../../libraries/dexLiteSlotsLink.sol\";\nimport { BigMathMinified as BM } from \"../../../libraries/bigMathMinified.sol\";\nimport { AddressCalcs as AC} from \"../../../libraries/addressCalcs.sol\";\nimport \"./helpers.sol\";\n\ncontract FluidDexLiteAdminModule is AdminModuleHelpers {\n    constructor(address liquidity_, address deployerContract_) {\n        THIS_ADDRESS = address(this);\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        DEPLOYER_CONTRACT = deployerContract_;\n    }\n\n    /// @dev update the auth for the dex\n    /// @param auth_ the address to update auth for\n    /// @param isAuth_ the auth statusßßßßß\n    function updateAuth(address auth_, bool isAuth_) external {\n        _isAuth[auth_] = isAuth_ ? 1 : 0;\n        \n        emit LogUpdateAuth(auth_, isAuth_);\n    }\n\n    /// @dev initialize the dex\n    /// @param i_ the initialize params\n    function initialize(InitializeParams memory i_) external payable _onlyDelegateCall {\n        if (i_.dexKey.token0 == address(0) || i_.dexKey.token1 == address(0) || i_.dexKey.token0 >= i_.dexKey.token1) {\n            revert InvalidTokenOrder(i_.dexKey.token0, i_.dexKey.token1);\n        }\n\n        InitializeVariables memory v_;\n\n        v_.dexId = bytes8(keccak256(abi.encode(i_.dexKey)));\n        if (_dexVariables[v_.dexId] != 0) {\n            revert DexAlreadyInitialized(v_.dexId);\n        }\n\n        v_.token0Decimals = i_.dexKey.token0 == NATIVE_TOKEN ? NATIVE_TOKEN_DECIMALS : IERC20WithDecimals(i_.dexKey.token0).decimals();\n        v_.token1Decimals = i_.dexKey.token1 == NATIVE_TOKEN ? NATIVE_TOKEN_DECIMALS : IERC20WithDecimals(i_.dexKey.token1).decimals();\n\n        // cut is an integer in storage slot which is more than enough\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\n        if (i_.revenueCut != 0 && i_.revenueCut < FOUR_DECIMALS) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert InvalidRevenueCut(i_.revenueCut);\n        }\n\n        i_.revenueCut = i_.revenueCut / FOUR_DECIMALS;\n\n        i_.upperPercent = i_.upperPercent / TWO_DECIMALS;\n        i_.lowerPercent = i_.lowerPercent / TWO_DECIMALS;\n\n        i_.upperShiftThreshold = i_.upperShiftThreshold / FOUR_DECIMALS;\n        i_.lowerShiftThreshold = i_.lowerShiftThreshold / FOUR_DECIMALS;\n\n        if (\n            (i_.fee > X13) || // fee cannot be more than 10%\n            (i_.revenueCut > TWO_DECIMALS) || // revenue cut cannot be more than 50%\n            (i_.centerPrice <= i_.minCenterPrice) ||\n            (i_.centerPrice >= i_.maxCenterPrice) ||\n            (i_.centerPriceContract > X19) ||\n            (i_.upperPercent > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (i_.lowerPercent > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (i_.upperPercent == 0) ||\n            (i_.lowerPercent == 0) ||\n            (i_.upperShiftThreshold > TWO_DECIMALS) ||\n            (i_.lowerShiftThreshold > TWO_DECIMALS) ||\n            ((i_.upperShiftThreshold == 0) && (i_.lowerShiftThreshold > 0)) ||\n            ((i_.upperShiftThreshold > 0) && (i_.lowerShiftThreshold == 0)) ||\n            (i_.shiftTime == 0) ||\n            (i_.shiftTime > X24) ||\n            (i_.minCenterPrice == 0) || \n            (v_.token0Decimals < MIN_TOKEN_DECIMALS) ||\n            (v_.token0Decimals > MAX_TOKEN_DECIMALS) ||\n            (v_.token1Decimals < MIN_TOKEN_DECIMALS) ||\n            (v_.token1Decimals > MAX_TOKEN_DECIMALS)\n        ) {\n            revert InvalidParams();\n        }\n\n        _transferTokenIn(i_.dexKey.token0, i_.token0Amount);\n        _transferTokenIn(i_.dexKey.token1, i_.token1Amount);\n\n        (v_.token0NumeratorPrecision, v_.token0DenominatorPrecision) = _calculateNumeratorAndDenominatorPrecisions(v_.token0Decimals);\n        (v_.token1NumeratorPrecision, v_.token1DenominatorPrecision) = _calculateNumeratorAndDenominatorPrecisions(v_.token1Decimals);\n\n        _dexVariables[v_.dexId] = \n            (i_.fee << DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) |\n            (i_.revenueCut << DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) |\n            ((i_.rebalancingStatus ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) |\n            (BM.toBigNumber(i_.centerPrice, BIG_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_DOWN) << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) |\n            (i_.centerPriceContract << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) |\n            (i_.upperPercent << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) |\n            (i_.lowerPercent << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) |\n            (i_.upperShiftThreshold << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) |\n            (i_.lowerShiftThreshold << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) |\n            (v_.token0Decimals << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) |\n            (v_.token1Decimals << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) |\n            (((i_.token0Amount * v_.token0NumeratorPrecision) / v_.token0DenominatorPrecision) << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) |\n            (((i_.token1Amount * v_.token1NumeratorPrecision) / v_.token1DenominatorPrecision) << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        _centerPriceShift[v_.dexId] = \n            (block.timestamp << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) |\n            (i_.shiftTime << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) |\n            (BM.toBigNumber(i_.maxCenterPrice, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_UP) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) |\n            (BM.toBigNumber(i_.minCenterPrice, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_DOWN) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE);\n        \n        _dexesList.push(i_.dexKey);\n        \n        emit LogInitialize(i_.dexKey, v_.dexId, _dexVariables[v_.dexId], _centerPriceShift[v_.dexId], i_);\n    }\n\n    /// @dev update the fee and revenue cut for the dex\n    /// @param dexKey_ the dex key\n    /// @param fee_ in 4 decimals, 10000 = 1%\n    /// @param revenueCut_ in 4 decimals, 10000 = 1%\n    function updateFeeAndRevenueCut(DexKey calldata dexKey_, uint256 fee_, uint256 revenueCut_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        // cut is an integer in storage slot which is more than enough\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\n        if (revenueCut_ != 0 && revenueCut_ < FOUR_DECIMALS) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert InvalidRevenueCut(revenueCut_);\n        }\n\n        revenueCut_ = revenueCut_ / FOUR_DECIMALS;\n\n        if (fee_ > X13 || revenueCut_ > TWO_DECIMALS) {\n            revert InvalidParams();\n        }\n\n        _dexVariables[dexId_] = (dexVariables_ & ~(X20 << DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE)) | \n            (fee_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) |\n            (revenueCut_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT);\n\n        emit LogUpdateFeeAndRevenueCut(dexKey_, dexId_, _dexVariables[dexId_], fee_, revenueCut_ * FOUR_DECIMALS);\n    }\n\n    /// @dev update the rebalancing status for the dex\n    /// @param dexKey_ the dex key\n    /// @param rebalancingStatus_ the rebalancing status (true = on, false = off)\n    function updateRebalancingStatus(DexKey calldata dexKey_, bool rebalancingStatus_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n        \n        _dexVariables[dexId_] = (dexVariables_ & ~(X2 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS)) |\n            (rebalancingStatus_ ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS;\n\n        emit LogUpdateRebalancingStatus(dexKey_, dexId_, _dexVariables[dexId_], rebalancingStatus_);\n    }\n\n    /// @dev update the range percents for the dex\n    /// @param dexKey_ the dex key\n    /// @param upperPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerPercent_ in 4 decimals, 10000 = 1%\n    /// @param shiftTime_ in secs, in how much time the upper percent configs change should be fully done\n    function updateRangePercents(\n        DexKey calldata dexKey_,\n        uint256 upperPercent_,\n        uint256 lowerPercent_,\n        uint256 shiftTime_\n    ) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        upperPercent_ = upperPercent_ / TWO_DECIMALS;\n        lowerPercent_ = lowerPercent_ / TWO_DECIMALS;\n\n        if (\n            (upperPercent_ > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (lowerPercent_ > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (upperPercent_ == 0) ||\n            (lowerPercent_ == 0) ||\n            (shiftTime_ > X20) ||\n            (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) & X1) == 1) // if last shift is still active then don't allow a newer shift\n        ) {\n            revert InvalidParams();\n        }\n\n        _dexVariables[dexId_] = (dexVariables_ & ~(X28 << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT)) |\n            ((shiftTime_ > 0 ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) |\n            (upperPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) |\n            (lowerPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT);\n\n        uint256 oldUpperPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14;\n        uint256 oldLowerPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14;\n\n        if (shiftTime_ > 0) {\n            _rangeShift[dexId_] = \n                (oldUpperPercent_ << DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT) | \n                (oldLowerPercent_ << DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT) | \n                (shiftTime_ << DSL.BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT) | \n                (block.timestamp << DSL.BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP);\n        }\n        // Note _rangeShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\n\n        emit LogUpdateRangePercents(dexKey_, dexId_, _dexVariables[dexId_], _rangeShift[dexId_], upperPercent_ * TWO_DECIMALS, lowerPercent_ * TWO_DECIMALS, shiftTime_);\n    }\n\n    /// @dev update the shift time for the dex for rebalancing\n    /// @param dexKey_ the dex key\n    /// @param shiftTime_ in secs, in how much time rebalancing should be fully done.\n    function updateShiftTime(DexKey calldata dexKey_, uint256 shiftTime_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n        \n        if (shiftTime_ == 0 || shiftTime_ > X24) {\n            revert InvalidParams();\n        }\n\n        _centerPriceShift[dexId_] = (_centerPriceShift[dexId_] & ~(X20 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME)) | \n            (shiftTime_ << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME);\n\n        emit LogUpdateShiftTime(dexKey_, dexId_, _centerPriceShift[dexId_], shiftTime_);\n    }\n\n    /// @dev update the center price limits for the dex\n    /// @param dexKey_ the dex key\n    /// @param maxCenterPrice_ 1:1 means 1e27 \n    /// @param minCenterPrice_ 1:1 means 1e27\n    function updateCenterPriceLimits(DexKey calldata dexKey_, uint256 maxCenterPrice_, uint256 minCenterPrice_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        uint256 centerPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n\n        if (\n            (maxCenterPrice_ <= minCenterPrice_) ||\n            (centerPrice_ <= minCenterPrice_) ||\n            (centerPrice_ >= maxCenterPrice_) ||\n            (minCenterPrice_ == 0)\n        ) {\n            revert InvalidParams();\n        }\n\n        _centerPriceShift[dexId_] = (_centerPriceShift[dexId_] & ~(X56 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE)) | \n            (BM.toBigNumber(maxCenterPrice_, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_UP) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) |\n            (BM.toBigNumber(minCenterPrice_, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_DOWN) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE);\n\n        emit LogUpdateCenterPriceLimits(dexKey_, dexId_, _centerPriceShift[dexId_], maxCenterPrice_, minCenterPrice_);\n    }\n\n    /// @dev update the threshold percent for the dex\n    /// @param dexKey_ the dex key\n    /// @param upperThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param shiftTime_ in secs, in how much time the upper config changes should be fully done.\n    function updateThresholdPercent(\n        DexKey calldata dexKey_,\n        uint256 upperThresholdPercent_,\n        uint256 lowerThresholdPercent_,\n        uint256 shiftTime_\n    ) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        // thresholds are with 1% precision, hence removing last 4 decimals.\n        // we are allowing to send in 4 decimals to maintain consistency with other params\n        upperThresholdPercent_ = upperThresholdPercent_ / FOUR_DECIMALS;\n        lowerThresholdPercent_ = lowerThresholdPercent_ / FOUR_DECIMALS;\n        if (\n            (upperThresholdPercent_ > TWO_DECIMALS) ||\n            (lowerThresholdPercent_ > TWO_DECIMALS) ||\n            ((upperThresholdPercent_ == 0) && (lowerThresholdPercent_ > 0)) ||\n            ((upperThresholdPercent_ > 0) && (lowerThresholdPercent_ == 0)) ||\n            (shiftTime_ > X20) ||\n            (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) & X1) == 1) // if last shift is still active then don't allow a newer shift\n        ) {\n            revert InvalidParams();\n        }\n\n        _dexVariables[dexId_] =\n            (dexVariables_ & ~(X14 << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT)) |\n            ((shiftTime_ > 0 ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) |\n            (upperThresholdPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) |\n            (lowerThresholdPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT);\n\n        uint oldUpperThresholdPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) & X7;\n        uint oldLowerThresholdPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) & X7;\n\n        if (shiftTime_ > 0) {\n            _thresholdShift[dexId_] = \n                (oldUpperThresholdPercent_ << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT) |\n                (oldLowerThresholdPercent_ << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT) |\n                (shiftTime_ << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT) |\n                (block.timestamp << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP);\n        }\n        // Note _thresholdShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\n\n        emit LogUpdateThresholdPercent(dexKey_, dexId_, _dexVariables[dexId_], _thresholdShift[dexId_], upperThresholdPercent_ * FOUR_DECIMALS, lowerThresholdPercent_ * FOUR_DECIMALS, shiftTime_);\n    }\n\n    /// @dev update the center price address (nonce) for the dex\n    /// @param dexKey_ the dex key\n    /// @param centerPriceAddress_ nonce < X19, this nonce will be used to calculate contract address\n    /// @param percent_ in 4 decimals, 10000 = 1%\n    /// @param time_ in secs, in how much time the center price should be fully shifted.\n    function updateCenterPriceAddress(\n        DexKey calldata dexKey_,\n        uint256 centerPriceAddress_,\n        uint256 percent_,\n        uint256 time_\n    ) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        if ((centerPriceAddress_ > X19) || (percent_ == 0) || (percent_ > X20) || (time_ == 0) || (time_ > X20)) {\n            revert InvalidParams();\n        }\n\n        if (centerPriceAddress_ > 0) {\n            address centerPrice_ = AC.addressCalc(DEPLOYER_CONTRACT, centerPriceAddress_);\n            _checkIsContract(centerPrice_);\n            // note: if address is made 0 then as well in the last swap currentPrice is updated on storage, so code will start using that automatically\n            _dexVariables[dexId_] =\n                (dexVariables_ & ~(X19 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS)) |\n                (centerPriceAddress_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) |\n                (uint256(1) << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n\n            _centerPriceShift[dexId_] = (_centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT)) |\n                (percent_ << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT) |\n                (time_ << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT) |\n                (block.timestamp << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP);\n        } else {\n            _dexVariables[dexId_] = (_dexVariables[dexId_] & ~(X19 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS));\n\n            _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n        }\n\n        emit LogUpdateCenterPriceAddress(dexKey_, dexId_, _dexVariables[dexId_], _centerPriceShift[dexId_], centerPriceAddress_, percent_, time_);\n    }\n\n    /// @dev deposit tokens into the dex\n    /// @param dexKey_ the dex key\n    /// @param token0Amount_ the token0 amount\n    /// @param token1Amount_ the token1 amount\n    function deposit(DexKey calldata dexKey_, uint256 token0Amount_, uint256 token1Amount_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        _transferTokenIn(dexKey_.token0, token0Amount_);\n        _transferTokenIn(dexKey_.token1, token1Amount_);\n\n        (uint256 token0NumeratorPrecision_, uint256 token0DenominatorPrecision_) = \n            _calculateNumeratorAndDenominatorPrecisions((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5);\n        (uint256 token1NumeratorPrecision_, uint256 token1DenominatorPrecision_) = \n            _calculateNumeratorAndDenominatorPrecisions((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5);\n\n        uint256 token0TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60) + \n            ((token0Amount_ * token0NumeratorPrecision_) / token0DenominatorPrecision_);\n        uint256 token1TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60) + \n            ((token1Amount_ * token1NumeratorPrecision_) / token1DenominatorPrecision_);\n\n        _dexVariables[dexId_] = (dexVariables_ & ~(X120 << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED)) |\n            (token0TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) |\n            (token1TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        emit LogDeposit(dexKey_, dexId_, _dexVariables[dexId_], token0Amount_, token1Amount_);\n    }\n\n    /// @dev withdraw tokens from the dex\n    /// @param dexKey_ the dex key\n    /// @param token0Amount_ the token0 amount\n    /// @param token1Amount_ the token1 amount\n    /// @param to_ the address to send the tokens to\n    function withdraw(DexKey calldata dexKey_, uint256 token0Amount_, uint256 token1Amount_, address to_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        _transferTokenOut(dexKey_.token0, token0Amount_, to_);\n        _transferTokenOut(dexKey_.token1, token1Amount_, to_);\n\n        (uint256 token0NumeratorPrecision_, uint256 token0DenominatorPrecision_) = \n            _calculateNumeratorAndDenominatorPrecisions((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5);\n        (uint256 token1NumeratorPrecision_, uint256 token1DenominatorPrecision_) = \n            _calculateNumeratorAndDenominatorPrecisions((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5);\n\n        uint256 token0TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60) - \n            ((token0Amount_ * token0NumeratorPrecision_) / token0DenominatorPrecision_);\n        uint256 token1TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60) - \n            ((token1Amount_ * token1NumeratorPrecision_) / token1DenominatorPrecision_);\n\n        _dexVariables[dexId_] = (dexVariables_ & ~(X120 << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED)) |\n            (token0TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) |\n            (token1TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        emit LogWithdraw(dexKey_, dexId_, _dexVariables[dexId_], token0Amount_, token1Amount_);\n    }\n\n    /// @dev update the extra data address in storage slot\n    /// @param extraDataAddress_ the address to set in the extra data slot\n    function updateExtraDataAddress(address extraDataAddress_) public _onlyDelegateCall {\n        assembly {\n            sstore(EXTRA_DATA_SLOT, extraDataAddress_)\n        }\n\n        emit LogUpdateExtraDataAddress(extraDataAddress_);\n    }\n\n    /// @dev collect revenue from the dex\n    /// @param tokens_ the tokens to collect revenue from\n    /// @param amounts_ the amounts of tokens to collect revenue from\n    /// @param to_ the address to send the tokens to\n    function collectRevenue(address[] calldata tokens_, uint256[] calldata amounts_, address to_) public _onlyDelegateCall {\n        for (uint256 i = 0; i < tokens_.length; ) {\n            _transferTokenOut(tokens_[i], amounts_[i], to_);\n            unchecked {++i;}\n        }\n\n        emit LogCollectRevenue(tokens_, amounts_, to_);\n    }\n}\n\n"
    },
    "contracts/protocols/dexLite/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"../other/commonImport.sol\";\n\nstruct InitializeParams {\n    DexKey dexKey;\n    uint256 fee;\n    uint256 revenueCut;\n    bool rebalancingStatus;\n    uint256 centerPrice;\n    uint256 centerPriceContract; // nonce\n    uint256 upperPercent;\n    uint256 lowerPercent;\n    uint256 upperShiftThreshold;\n    uint256 lowerShiftThreshold;\n    uint256 shiftTime; // in seconds // for rebalancing\n    uint256 minCenterPrice;\n    uint256 maxCenterPrice;\n    uint256 token0Amount;\n    uint256 token1Amount;\n}\n\nstruct InitializeVariables {\n    bytes8 dexId;\n    uint256 token0Decimals;\n    uint256 token1Decimals;\n    uint256 token0NumeratorPrecision;\n    uint256 token0DenominatorPrecision;\n    uint256 token1NumeratorPrecision;\n    uint256 token1DenominatorPrecision;\n}"
    },
    "contracts/protocols/dexLite/core/coreInternals.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./helpers.sol\";\n\nabstract contract CoreInternals is Helpers {\n    function _swapIn(\n        DexKey calldata dexKey_,\n        bool swap0To1_,\n        uint256 amountIn_\n    ) internal returns (uint256 amountOut_) {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        uint256 token0AdjustedSupply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60;\n        uint256 token1AdjustedSupply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60;\n        (uint256 centerPrice_, uint256 token0ImaginaryReserves_, uint256 token1ImaginaryReserves_) = \n            _getPricesAndReserves(dexKey_, dexVariables_, dexId_, token0AdjustedSupply_, token1AdjustedSupply_);\n\n        unchecked {\n            if (swap0To1_) {\n                uint256 token0Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5;\n                if (token0Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                    amountIn_ /= _tenPow(token0Decimals_ - TOKENS_DECIMALS_PRECISION);\n                } else {\n                    amountIn_ *= _tenPow(TOKENS_DECIMALS_PRECISION - token0Decimals_);\n                }\n\n                if (amountIn_ < FOUR_DECIMALS || amountIn_ > X60) {\n                    revert InvalidSwapAmounts(amountIn_);\n                }\n                if (amountIn_ > (token0ImaginaryReserves_ / 2)) {\n                    revert ExcessiveSwapAmount(amountIn_, token0ImaginaryReserves_);\n                }\n\n                uint256 fee_ = (amountIn_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) & X13)) / SIX_DECIMALS;\n                // amountOut = (amountIn * iReserveOut) / (iReserveIn + amountIn)\n                amountOut_ = ((amountIn_ - fee_) * token1ImaginaryReserves_) / (token0ImaginaryReserves_ + (amountIn_ - fee_));\n                token0AdjustedSupply_ += amountIn_ - ((fee_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) & X7)) / TWO_DECIMALS);\n\n                if (token1AdjustedSupply_ < amountOut_) {\n                    revert TokenReservesTooLow(amountOut_, token1AdjustedSupply_);\n                }\n                token1AdjustedSupply_ -= amountOut_;\n\n                if (((token1AdjustedSupply_) < ((token0AdjustedSupply_ * centerPrice_) / (PRICE_PRECISION * MINIMUM_LIQUIDITY_SWAP)))) {\n                    revert TokenReservesRatioTooHigh(token0AdjustedSupply_, token1AdjustedSupply_);\n                }\n            } else {\n                uint256 token1Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5;\n                if (token1Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                    amountIn_ /= _tenPow(token1Decimals_ - TOKENS_DECIMALS_PRECISION);\n                } else {\n                    amountIn_ *= _tenPow(TOKENS_DECIMALS_PRECISION - token1Decimals_);\n                }\n\n                if (amountIn_ < FOUR_DECIMALS || amountIn_ > X60) {\n                    revert InvalidSwapAmounts(amountIn_);\n                }\n                if (amountIn_ > (token1ImaginaryReserves_ / 2)) {\n                    revert ExcessiveSwapAmount(amountIn_, token1ImaginaryReserves_);\n                }\n\n                uint256 fee_ = (amountIn_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) & X13)) / SIX_DECIMALS;\n                // amountOut = (amountIn * iReserveOut) / (iReserveIn + amountIn)\n                amountOut_ = ((amountIn_ - fee_) * token0ImaginaryReserves_) / (token1ImaginaryReserves_ + (amountIn_ - fee_));\n                token1AdjustedSupply_ += amountIn_ - ((fee_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) & X7)) / TWO_DECIMALS);\n\n                if (token0AdjustedSupply_ < amountOut_) {\n                    revert TokenReservesTooLow(amountOut_, token0AdjustedSupply_);\n                }\n                token0AdjustedSupply_ -= amountOut_;\n\n                if (((token0AdjustedSupply_) < ((token1AdjustedSupply_ * PRICE_PRECISION) / (centerPrice_ * MINIMUM_LIQUIDITY_SWAP)))) {\n                    revert TokenReservesRatioTooHigh(token0AdjustedSupply_, token1AdjustedSupply_);\n                }\n            }\n        }\n\n        {\n            uint256 rebalancingStatus_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) & X2;\n            if (rebalancingStatus_ > 0) {\n                // rebalancing is active\n                uint256 price_;\n                unchecked {\n                    price_ = (swap0To1_ ? (token1ImaginaryReserves_ - amountOut_) * PRICE_PRECISION / (token0ImaginaryReserves_ + amountIn_) : \n                        (token1ImaginaryReserves_ + amountIn_) * PRICE_PRECISION / (token0ImaginaryReserves_ - amountOut_));\n                }\n                rebalancingStatus_ = _getRebalancingStatus(dexVariables_, dexId_, rebalancingStatus_, price_, centerPrice_);\n            }\n            // NOTE: we are using dexVariables_ and not _dexVariables[dexId_] here to check if the center price shift is active\n            // _dexVariables[dexId_] might have become inactive in this transaction above, but still we are storing the timestamp for this transaction\n            // storing the timestamp is not important, but we are still doing it because we don't want to use _dexVariables[dexId_] here because of gas\n            if (rebalancingStatus_ > 1 || ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE) & X1) == 1) {\n                _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X33 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) | \n                    (block.timestamp << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP);\n            }\n        }\n\n        if (token0AdjustedSupply_ > X60 || token1AdjustedSupply_ > X60) {\n            revert AdjustedSupplyOverflow(dexId_, token0AdjustedSupply_, token1AdjustedSupply_);\n        }\n\n        dexVariables_ = _dexVariables[dexId_] & ~(X120 << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) | \n            (token0AdjustedSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) | \n            (token1AdjustedSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        _dexVariables[dexId_] = dexVariables_;\n\n        if (swap0To1_) {\n            emit LogSwap(\n                (uint256(uint64(dexId_)) << DSL.BITS_DEX_LITE_SWAP_DATA_DEX_ID) | \n                (uint256(1) << DSL.BITS_DEX_LITE_SWAP_DATA_SWAP_0_TO_1) | // swap 0 to 1 bit is 1\n                (amountIn_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN) | \n                (amountOut_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT), \n                dexVariables_\n            );\n\n            uint256 token1Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5;\n            if (token1Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                amountOut_ *= _tenPow(token1Decimals_ - TOKENS_DECIMALS_PRECISION);\n            } else {\n                amountOut_ /= _tenPow(TOKENS_DECIMALS_PRECISION - token1Decimals_);\n            }\n\n        } else {\n            emit LogSwap(\n                (uint256(uint64(dexId_)) << DSL.BITS_DEX_LITE_SWAP_DATA_DEX_ID) | \n                // swap 0 to 1 bit is 0\n                (amountIn_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN) | \n                (amountOut_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT), \n                dexVariables_\n            );\n\n            uint256 token0Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5;\n            if (token0Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                amountOut_ *= _tenPow(token0Decimals_ - TOKENS_DECIMALS_PRECISION);\n            } else {\n                amountOut_ /= _tenPow(TOKENS_DECIMALS_PRECISION - token0Decimals_);\n            }\n        }\n    }\n\n    function _swapOut(\n        DexKey calldata dexKey_,\n        bool swap0To1_,\n        uint256 amountOut_\n    ) internal returns (uint256 amountIn_) {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n    \n        uint256 token0AdjustedSupply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60;\n        uint256 token1AdjustedSupply_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60;\n        (uint256 centerPrice_, uint256 token0ImaginaryReserves_, uint256 token1ImaginaryReserves_) = \n            _getPricesAndReserves(dexKey_, dexVariables_, dexId_, token0AdjustedSupply_, token1AdjustedSupply_);\n\n        unchecked {\n            if (swap0To1_) {\n                uint256 token1Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5;\n                if (token1Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                    amountOut_ /= _tenPow(token1Decimals_ - TOKENS_DECIMALS_PRECISION);\n                } else {\n                    amountOut_ *= _tenPow(TOKENS_DECIMALS_PRECISION - token1Decimals_);\n                }\n\n                if (amountOut_ < FOUR_DECIMALS || amountOut_ > X60) {\n                    revert InvalidSwapAmounts(amountOut_);\n                }\n                if (amountOut_ > (token1ImaginaryReserves_ / 2)) {\n                    revert ExcessiveSwapAmount(amountOut_, token1ImaginaryReserves_);\n                }\n\n                // amountIn = (amountOut * iReserveIn) / (iReserveOut - amountOut)\n                amountIn_ = (amountOut_ * token0ImaginaryReserves_) / (token1ImaginaryReserves_ - amountOut_);\n                uint256 fee_ = ((amountIn_ * SIX_DECIMALS) / (SIX_DECIMALS - ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) & X13))) - amountIn_;\n                amountIn_ += fee_;\n                token0AdjustedSupply_ += amountIn_ - ((fee_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) & X7)) / TWO_DECIMALS);\n\n                if (token1AdjustedSupply_ < amountOut_) {\n                    revert TokenReservesTooLow(amountOut_, token1AdjustedSupply_);\n                }\n                token1AdjustedSupply_ -= amountOut_;\n\n                if (((token1AdjustedSupply_) < ((token0AdjustedSupply_ * centerPrice_) / (PRICE_PRECISION * MINIMUM_LIQUIDITY_SWAP)))) {\n                    revert TokenReservesRatioTooHigh(token0AdjustedSupply_, token1AdjustedSupply_);\n                }\n            } else {\n                uint256 token0Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5;\n                if (token0Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                    amountOut_ /= _tenPow(token0Decimals_ - TOKENS_DECIMALS_PRECISION);\n                } else {\n                    amountOut_ *= _tenPow(TOKENS_DECIMALS_PRECISION - token0Decimals_);\n                }\n                \n                if (amountOut_ < FOUR_DECIMALS || amountOut_ > X60) {\n                    revert InvalidSwapAmounts(amountOut_);\n                }\n                if (amountOut_ > (token0ImaginaryReserves_ / 2)) {\n                    revert ExcessiveSwapAmount(amountOut_, token0ImaginaryReserves_);\n                }\n\n                // amountIn = (amountOut * iReserveIn) / (iReserveOut - amountOut)\n                amountIn_ = (amountOut_ * token1ImaginaryReserves_) / (token0ImaginaryReserves_ - amountOut_);\n                uint256 fee_ = ((amountIn_ * SIX_DECIMALS) / (SIX_DECIMALS - ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) & X13))) - amountIn_;\n                amountIn_ += fee_;\n                token1AdjustedSupply_ += amountIn_ - ((fee_ * ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) & X7)) / TWO_DECIMALS);\n\n                if (token0AdjustedSupply_ < amountOut_) {\n                    revert TokenReservesTooLow(amountOut_, token0AdjustedSupply_);\n                }\n                token0AdjustedSupply_ -= amountOut_;\n\n                if (((token0AdjustedSupply_) < ((token1AdjustedSupply_ * PRICE_PRECISION) / (centerPrice_ * MINIMUM_LIQUIDITY_SWAP)))) {\n                    revert TokenReservesRatioTooHigh(token0AdjustedSupply_, token1AdjustedSupply_);\n                }\n            }\n        }\n\n        {\n            uint256 rebalancingStatus_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) & X2;\n            if (rebalancingStatus_ > 0) {\n                // rebalancing is active\n                uint256 price_;\n                unchecked {\n                    price_ = (swap0To1_ ? (token1ImaginaryReserves_ - amountOut_) * PRICE_PRECISION / (token0ImaginaryReserves_ + amountIn_) : \n                        (token1ImaginaryReserves_ + amountIn_) * PRICE_PRECISION / (token0ImaginaryReserves_ - amountOut_));\n                }\n                rebalancingStatus_ = _getRebalancingStatus(dexVariables_, dexId_, rebalancingStatus_, price_, centerPrice_);\n            }\n            if (rebalancingStatus_ > 1 || ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE) & X1) == 1) {\n                _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X33 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) | \n                    (block.timestamp << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP);\n            }\n        }\n\n        if (token0AdjustedSupply_ > X60 || token1AdjustedSupply_ > X60) {\n            revert AdjustedSupplyOverflow(dexId_, token0AdjustedSupply_, token1AdjustedSupply_);\n        }\n\n        dexVariables_ = _dexVariables[dexId_] & ~(X120 << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) | \n            (token0AdjustedSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) | \n            (token1AdjustedSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        _dexVariables[dexId_] = dexVariables_;\n\n        if (swap0To1_) {\n            emit LogSwap(\n                (uint256(uint64(dexId_)) << DSL.BITS_DEX_LITE_SWAP_DATA_DEX_ID) | \n                (uint256(1) << DSL.BITS_DEX_LITE_SWAP_DATA_SWAP_0_TO_1) | // swap 0 to 1 bit is 1\n                (amountIn_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN) | \n                (amountOut_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT), \n                dexVariables_\n            );\n\n            uint256 token0Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5;\n            if (token0Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                amountIn_ *= _tenPow(token0Decimals_ - TOKENS_DECIMALS_PRECISION);\n            } else {\n                amountIn_ /= _tenPow(TOKENS_DECIMALS_PRECISION - token0Decimals_);\n            }\n        } else {\n            emit LogSwap(\n                (uint256(uint64(dexId_)) << DSL.BITS_DEX_LITE_SWAP_DATA_DEX_ID) | \n                // swap 0 to 1 bit is 0\n                (amountIn_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN) | \n                (amountOut_ << DSL.BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT), \n                dexVariables_\n            );\n\n            uint256 token1Decimals_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5;\n            if (token1Decimals_ > TOKENS_DECIMALS_PRECISION) {\n                amountIn_ *= _tenPow(token1Decimals_ - TOKENS_DECIMALS_PRECISION);\n            } else {\n                amountIn_ /= _tenPow(TOKENS_DECIMALS_PRECISION - token1Decimals_);\n            }\n        }\n    }\n}\n"
    },
    "contracts/protocols/dexLite/core/errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport \"../other/commonImport.sol\";\n\n// --- Custom Errors ---\nerror EstimateSwap(uint256 amountUnspecified);\nerror AmountLimitExceeded(uint256 amountUnspecified, uint256 amountLimit);\nerror AmountLimitNotMet(uint256 amountUnspecified, uint256 amountLimit);\nerror EmptyDexKeysArray();\nerror InvalidPathLength(uint256 pathLength, uint256 dexKeysLength);\nerror InvalidAmountLimitsLength(uint256 dexKeysLength, uint256 amountLimitsLength);\nerror InvalidPathTokenOrder();\nerror UnauthorizedCaller(address caller);\nerror DexNotInitialized(bytes32 dexId);\nerror AdjustedSupplyOverflow(bytes32 dexId, uint256 token0AdjustedSupply, uint256 token1AdjustedSupply);\nerror ZeroAddress();\nerror InvalidPower(uint256 power);\nerror InvalidSwapAmounts(uint256 adjustedAmount);\nerror ExcessiveSwapAmount(uint256 adjustedAmount, uint256 imaginaryReserve);\nerror TokenReservesTooLow(uint256 adjustedAmount, uint256 realReserve);\nerror TokenReservesRatioTooHigh(uint256 token0RealReserve, uint256 token1RealReserve);\nerror InvalidMsgValue();\nerror InsufficientNativeTokenReceived(uint256 receivedAmount, uint256 requiredAmount);\nerror InsufficientERC20Received(uint256 receivedAmount, uint256 requiredAmount);\nerror DelegateCallFailed();"
    },
    "contracts/protocols/dexLite/core/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport \"./errors.sol\";\nimport { DexLiteSlotsLink as DSL } from \"../../../libraries/dexLiteSlotsLink.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { AddressCalcs } from \"../../../libraries/addressCalcs.sol\";\nimport { BigMathMinified } from \"../../../libraries/bigMathMinified.sol\";\nimport { ReentrancyLock } from \"../../../libraries/reentrancyLock.sol\";\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\n\nabstract contract Helpers is CommonImport {\n    using BigMathMinified for uint256;\n\n    modifier _reentrancyLock() {\n        ReentrancyLock.lock();\n        _;\n        ReentrancyLock.unlock();\n    }\n\n    function _getExtraDataSlot() internal view returns (address extraDataAddress_) {\n        assembly {\n            extraDataAddress_ := sload(EXTRA_DATA_SLOT)\n        }\n    }\n\n    function _getGovernanceAddr() internal view returns (address governance_) {\n        governance_ = address(uint160(LIQUIDITY.readFromStorage(LIQUIDITY_GOVERNANCE_SLOT)));\n    }\n\n    function _callExtraDataSlot(bytes memory data_) internal {\n        address extraDataAddress_ = _getExtraDataSlot();\n        if (extraDataAddress_ == address(0)) {\n            revert ZeroAddress();\n        }\n        _spell(extraDataAddress_, data_);\n    }\n\n    function _tenPow(uint256 power_) internal pure returns (uint256) {\n        // keeping the most used powers at the top for better gas optimization\n        if (power_ == 3) {\n            return 1_000; // used for 6 or 12 decimals (USDC, USDT)\n        }\n        if (power_ == 9) {\n            return 1_000_000_000; // used for 18 decimals (ETH, and many more)\n        }\n        if (power_ == 1) {\n            return 10; // used for 1 decimals (WBTC and more)\n        }\n\n        if (power_ == 0) {\n            return 1;\n        }\n        if (power_ == 2) {\n            return 100;\n        }\n        if (power_ == 4) {\n            return 10_000;\n        }\n        if (power_ == 5) {\n            return 100_000;\n        }\n        if (power_ == 6) {\n            return 1_000_000;\n        }\n        if (power_ == 7) {\n            return 10_000_000;\n        }\n        if (power_ == 8) {\n            return 100_000_000;\n        }\n\n        // We will only need powers from 0 to 9 as token decimals can only be 6 to 18\n        revert InvalidPower(power_);\n    }\n\n    /// @dev getting reserves outside range.\n    /// @param gp_ is geometric mean pricing of upper percent & lower percent\n    /// @param pa_ price of upper range or lower range\n    /// @param rx_ real reserves of token0 or token1\n    /// @param ry_ whatever is rx_ the other will be ry_\n    function _calculateReservesOutsideRange(uint256 gp_, uint256 pa_, uint256 rx_, uint256 ry_) internal pure returns (uint256 xa_, uint256 yb_) {\n        // equations we have:\n        // 1. x*y = k\n        // 2. xa*ya = k\n        // 3. xb*yb = k\n        // 4. Pa = ya / xa = upperRange_ (known)\n        // 5. Pb = yb / xb = lowerRange_ (known)\n        // 6. x - xa = rx = real reserve of x (known)\n        // 7. y - yb = ry = real reserve of y (known)\n        // With solving we get:\n        // ((Pa*Pb)^(1/2) - Pa)*xa^2 + (rx * (Pa*Pb)^(1/2) + ry)*xa + rx*ry = 0\n        // yb = yb = xa * (Pa * Pb)^(1/2)\n\n        // xa = (GP⋅rx + ry + (-rx⋅ry⋅4⋅(GP - Pa) + (GP⋅rx + ry)^2)^0.5) / (2Pa - 2GP)\n        // multiply entire equation by 1e27 to remove the price decimals precision of 1e27\n        // xa = (GP⋅rx + ry⋅1e27 + (rx⋅ry⋅4⋅(Pa - GP)⋅1e27 + (GP⋅rx + ry⋅1e27)^2)^0.5) / 2*(Pa - GP)\n        // dividing the equation with 2*(Pa - GP). Pa is always > GP so answer will be positive.\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅4⋅(Pa - GP)⋅1e27) / 4*(Pa - GP)^2) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n        // xa = (((GP⋅rx + ry⋅1e27) / 2*(Pa - GP)) + (((rx⋅ry⋅1e27) / (Pa - GP)) + ((GP⋅rx + ry⋅1e27) / 2*(Pa - GP))^2)^0.5)\n\n        // dividing in 3 parts for simplification:\n        // part1 = (Pa - GP)\n        // part2 = (GP⋅rx + ry⋅1e27) / (2*part1)\n        // part3 = rx⋅ry\n        // note: part1 will almost always be < 1e28 but in case it goes above 1e27 then it's extremely unlikely it'll go above > 1e29\n        unchecked {\n            uint256 p1_ = pa_ - gp_;\n            uint256 p2_ = ((gp_ * rx_) + (ry_ * PRICE_PRECISION)) / (2 * p1_);\n\n            // removed <1e50 check becuase rx_ * ry_ will never be greater than 1e50\n            // Directly used p3_ below instead of using a variable for it\n            // uint256 p3_ = (rx_ * ry_ * PRICE_PRECISION) / p1_;\n\n            // xa = part2 + (part3 + (part2 * part2))^(1/2)\n            // yb = xa_ * gp_\n            xa_ = p2_ + FixedPointMathLib.sqrt((((rx_ * ry_ * PRICE_PRECISION) / p1_) + (p2_ * p2_)));\n            yb_ = (xa_ * gp_) / PRICE_PRECISION;\n        }\n    }\n    \n\n    /// @dev This function calculates the new value of a parameter after a shifting process\n    /// @param current_ The current value is the final value where the shift ends\n    /// @param old_ The old value from where shifting started\n    /// @param timePassed_ The time passed since shifting started\n    /// @param shiftDuration_ The total duration of the shift when old_ reaches current_\n    /// @return The new value of the parameter after the shift\n    function _calcShiftingDone(uint256 current_, uint256 old_, uint256 timePassed_, uint256 shiftDuration_) internal pure returns (uint256) {\n        unchecked {\n            if (current_ > old_) {\n                return (old_ + (((current_ - old_) * timePassed_) / shiftDuration_));\n            } else {\n                return (old_ - (((old_ - current_) * timePassed_) / shiftDuration_));\n            }\n        }\n    }\n\n    /// @dev Calculates the new upper and lower range values during an active range shift\n    /// @param upperRange_ The target upper range value\n    /// @param lowerRange_ The target lower range value\n    /// @notice This function handles the gradual shifting of range values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcRangeShifting(\n        uint256 upperRange_,\n        uint256 lowerRange_,\n        bytes8 dexId_\n    ) internal returns (uint256, uint256) {\n        uint256 rangeShift_ = _rangeShift[dexId_];\n        uint256 shiftDuration_ = (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT) & X20;\n        uint256 startTimeStamp_ = (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP) & X33;\n\n        uint256 timePassed_;\n        unchecked {\n            if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n                // shifting fully done\n                delete _rangeShift[dexId_];\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables only updates from this function and _calcThresholdShifting.\n                _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE);\n                return (upperRange_, lowerRange_);\n            }\n            timePassed_ = block.timestamp - startTimeStamp_;\n        }\n        return (\n            _calcShiftingDone(upperRange_, (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT) & X14, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerRange_, (rangeShift_ >> DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT) & X14, timePassed_, shiftDuration_)\n        );\n    }\n\n    /// @dev Calculates the new upper and lower threshold values during an active threshold shift\n    /// @param upperThreshold_ The target upper threshold value\n    /// @param lowerThreshold_ The target lower threshold value\n    /// @return The updated upper threshold, lower threshold\n    /// @notice This function handles the gradual shifting of threshold values over time\n    /// @notice If the shift is complete, it updates the state and clears the shift data\n    function _calcThresholdShifting(\n        uint256 upperThreshold_,\n        uint256 lowerThreshold_,\n        bytes8 dexId_\n    ) internal returns (uint256, uint256) {\n        uint256 thresholdShift_ = _thresholdShift[dexId_];\n        uint256 shiftDuration_ = (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT) & X20;\n        uint256 startTimeStamp_ = (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP) & X33;\n\n        uint256 timePassed_;\n        unchecked {\n            if ((startTimeStamp_ + shiftDuration_) < block.timestamp) {\n                // shifting fully done\n                delete _thresholdShift[dexId_];\n                // making active shift as 0 because shift is over\n                // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates from this function and _calcRangeShifting.\n                _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE);\n                return (upperThreshold_, lowerThreshold_);\n            }\n            timePassed_ = block.timestamp - startTimeStamp_;\n        }\n        return (\n            _calcShiftingDone(upperThreshold_, (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT) & X7, timePassed_, shiftDuration_),\n            _calcShiftingDone(lowerThreshold_, (thresholdShift_ >> DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT) & X7, timePassed_, shiftDuration_)\n        );\n    }\n\n    /// @dev Calculates the new center price during an active price shift\n    /// @param dexVariables_ The current state of dex variables\n    /// @return newCenterPrice_ The updated center price\n    /// @notice This function gradually shifts the center price towards a new target price over time\n    /// @notice It uses an external price source (via ICenterPrice) to determine the target price\n    /// @notice The shift continues until the current price reaches the target, or the shift duration ends\n    /// @notice Once the shift is complete, it updates the state and clears the shift data\n    /// @notice The shift rate is dynamic and depends on:\n    /// @notice - Time remaining in the shift duration\n    /// @notice - The new center price (fetched externally, which may change)\n    /// @notice - The current (old) center price\n    /// @notice This results in a fuzzy shifting mechanism where the rate can change as these parameters evolve\n    /// @notice The externally fetched new center price is expected to not differ significantly from the last externally fetched center price\n    function _calcCenterPrice(\n        DexKey calldata dexKey_,\n        uint256 dexVariables_,\n        bytes8 dexId_\n    ) internal returns (uint256 newCenterPrice_) {\n        uint256 oldCenterPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n        oldCenterPrice_ = (oldCenterPrice_ >> DEFAULT_EXPONENT_SIZE) << (oldCenterPrice_ & DEFAULT_EXPONENT_MASK);\n        uint256 centerPriceShift_ = _centerPriceShift[dexId_];\n        uint256 startTimeStamp_ = (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP) & X33;\n\n        uint256 fromTimeStamp_ = (centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33;\n        fromTimeStamp_ = fromTimeStamp_ > startTimeStamp_ ? fromTimeStamp_ : startTimeStamp_;\n\n        newCenterPrice_ = ICenterPrice(\n            AddressCalcs.addressCalc(DEPLOYER_CONTRACT, ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) & X19)))\n            .centerPrice(dexKey_.token0, dexKey_.token1);\n        \n        unchecked {\n            uint256 priceShift_ = (oldCenterPrice_ * ((centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT) & X20) * (block.timestamp - fromTimeStamp_)) \n                                    / (((centerPriceShift_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT) & X20) * SIX_DECIMALS);\n\n            if (newCenterPrice_ > oldCenterPrice_) {\n                // shift on positive side\n                oldCenterPrice_ += priceShift_;\n                if (newCenterPrice_ > oldCenterPrice_) {\n                    newCenterPrice_ = oldCenterPrice_;\n                } else {\n                    // shifting fully done\n                    _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n                    // making active shift as 0 because shift is over\n                    // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                    _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n                }\n            } else {\n                oldCenterPrice_ = oldCenterPrice_ > priceShift_ ? oldCenterPrice_ - priceShift_ : 0;\n                // In case of oldCenterPrice_ ending up 0, which could happen when a lot of time has passed (pool has no swaps for many days or weeks)\n                // then below we get into the else logic which will fully conclude shifting and return newCenterPrice_\n                // as it was fetched from the external center price source.\n                // not ideal that this would ever happen unless the pool is not in use and all/most users have left leaving not enough liquidity to trade on\n                if (newCenterPrice_ < oldCenterPrice_) {\n                    newCenterPrice_ = oldCenterPrice_;\n                } else {\n                    // shifting fully done\n                    _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n                    // making active shift as 0 because shift is over\n                    // fetching from storage and storing in storage, aside from admin module dexVariables2 only updates these shift function.\n                    _dexVariables[dexId_] = _dexVariables[dexId_] & ~uint256(1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates and returns the current prices and exchange prices for the pool\n    /// @param dexVariables_ The first set of DEX variables containing various pool parameters\n    function _getPricesAndReserves(\n        DexKey calldata dexKey_,\n        uint256 dexVariables_,\n        bytes8 dexId_,\n        uint256 token0Supply_,\n        uint256 token1Supply_\n    ) internal returns (uint256 centerPrice_, uint256 token0ImaginaryReserves_, uint256 token1ImaginaryReserves_) {\n        // Fetch center price\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE) & X1) == 0) {\n            // centerPrice_ => center price nonce\n            centerPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) & X19;\n            if (centerPrice_ == 0) {\n                centerPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n                centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n            } else {\n                // center price should be fetched from external source. For exmaple, in case of wstETH <> ETH pool,\n                // we would want the center price to be pegged to wstETH exchange rate into ETH\n                centerPrice_ = \n                    ICenterPrice(AddressCalcs.addressCalc(DEPLOYER_CONTRACT, centerPrice_)).centerPrice(dexKey_.token0, dexKey_.token1);\n            }\n        } else {\n            // an active centerPrice_ shift is going on\n            centerPrice_ = _calcCenterPrice(dexKey_, dexVariables_, dexId_);\n        }\n\n        uint256 upperRangePercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14;\n        uint256 lowerRangePercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14;\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) & X1) == 1) {\n            // an active range shift is going on\n            (upperRangePercent_, lowerRangePercent_) = _calcRangeShifting(upperRangePercent_, lowerRangePercent_, dexId_);\n        }\n\n        uint256 upperRangePrice_;\n        uint256 lowerRangePrice_;\n        unchecked {\n            // 1% = 1e2, 100% = 1e4\n            upperRangePrice_ = (centerPrice_ * FOUR_DECIMALS) / (FOUR_DECIMALS - upperRangePercent_);\n            // 1% = 1e2, 100% = 1e4\n            lowerRangePrice_ = (centerPrice_ * (FOUR_DECIMALS - lowerRangePercent_)) / FOUR_DECIMALS;\n        }\n\n        // Rebalance center price if rebalancing is on\n        // temp_ => rebalancingStatus_\n        uint256 temp_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) & X2;\n        uint256 temp2_;\n        if (temp_ > 1) {\n            unchecked {\n                // temp2_ => centerPriceShift_\n                if (temp_ == 2) {\n                    temp2_ = _centerPriceShift[dexId_];\n                    uint256 shiftingTime_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24;\n                    uint256 timeElapsed_ = block.timestamp - ((temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33);\n                    // price shifting towards upper range\n                    if (timeElapsed_ < shiftingTime_) {\n                        centerPrice_ = centerPrice_ + (((upperRangePrice_ - centerPrice_) * timeElapsed_) / shiftingTime_);\n                    } else {\n                        // 100% price shifted\n                        centerPrice_ = upperRangePrice_;\n                    }\n                } else if (temp_ == 3) {\n                    temp2_ = _centerPriceShift[dexId_];\n                    uint256 shiftingTime_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) & X24;\n                    uint256 timeElapsed_ = block.timestamp - ((temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) & X33);\n                    // price shifting towards lower range\n                    if (timeElapsed_ < shiftingTime_) {\n                        centerPrice_ = centerPrice_ - (((centerPrice_ - lowerRangePrice_) * timeElapsed_) / shiftingTime_);\n                    } else {\n                        // 100% price shifted\n                        centerPrice_ = lowerRangePrice_;\n                    }\n                }\n\n                // If rebalancing actually happened then make sure price is within min and max bounds, and update range prices\n                if (temp2_ > 0) {\n                    // Make sure center price is within min and max bounds\n                    // temp_ => max center price\n                    temp_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) & X28;\n                    temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n                    if (centerPrice_ > temp_) {\n                        // if center price is greater than max center price\n                        centerPrice_ = temp_;\n                    } else {\n                        // check if center price is less than min center price\n                        // temp_ => min center price\n                        temp_ = (temp2_ >> DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE) & X28;\n                        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n                        if (centerPrice_ < temp_) centerPrice_ = temp_;\n                    }\n\n                    // Update range prices as center price moved\n                    upperRangePrice_ = (centerPrice_ * FOUR_DECIMALS) / (FOUR_DECIMALS - upperRangePercent_);\n                    lowerRangePrice_ = (centerPrice_ * (FOUR_DECIMALS - lowerRangePercent_)) / FOUR_DECIMALS;\n                }\n            }  \n        }\n\n        // temp_ => geometricMeanPrice_\n        unchecked {         \n            if (upperRangePrice_ < 1e38) {\n                // 1e38 * 1e38 = 1e76 which is less than max uint limit\n                temp_ = FixedPointMathLib.sqrt(upperRangePrice_ * lowerRangePrice_);\n            } else {\n                // upperRange_ price is pretty large hence lowerRange_ will also be pretty large\n                temp_ = FixedPointMathLib.sqrt((upperRangePrice_ / 1e18) * (lowerRangePrice_ / 1e18)) * 1e18;\n            }\n        }\n\n        if (temp_ < 1e27) {\n            (token0ImaginaryReserves_, token1ImaginaryReserves_) = \n                _calculateReservesOutsideRange(temp_, upperRangePrice_, token0Supply_, token1Supply_);\n        } else {\n            // inversing, something like `xy = k` so for calculation we are making everything related to x into y & y into x\n            // 1 / geometricMean for new geometricMean\n            // 1 / lowerRange will become upper range\n            // 1 / upperRange will become lower range\n            unchecked {\n                (token1ImaginaryReserves_, token0ImaginaryReserves_) = _calculateReservesOutsideRange(\n                    (1e54 / temp_),\n                    (1e54 / lowerRangePrice_),\n                    token1Supply_,\n                    token0Supply_\n                );\n            }\n        }\n\n        unchecked {\n            token0ImaginaryReserves_ += token0Supply_;\n            token1ImaginaryReserves_ += token1Supply_;\n        }\n    }\n\n    function _getRebalancingStatus(\n        uint256 dexVariables_, \n        bytes8 dexId_, \n        uint256 rebalancingStatus_, \n        uint256 price_, \n        uint256 centerPrice_\n    ) internal returns (uint256) {\n        uint256 upperRange_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14;\n        uint256 lowerRange_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14;\n\n        // NOTE: we are using dexVariables_ and not _dexVariables[dexId_] here to check if the range shift is active\n        // range shift might have already ended in this transaction above, but still calling _calcRangeShifting again because we don't want to use _dexVariables[dexId_] here because of gas\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) & X1) == 1) {\n            // an active range shift is going on\n            (upperRange_, lowerRange_) = _calcRangeShifting(upperRange_, lowerRange_, dexId_);\n        }\n\n        unchecked {\n            // adding into unchecked because upperRangePercent_ & lowerRangePercent_ can only be > 0 & < FOUR_DECIMALS\n            // 1% = 1e2, 100% = 1e4\n            upperRange_ = (centerPrice_ * FOUR_DECIMALS) / (FOUR_DECIMALS - upperRange_);\n            // 1% = 1e2, 100% = 1e4\n            lowerRange_ = (centerPrice_ * (FOUR_DECIMALS - lowerRange_)) / FOUR_DECIMALS;\n        }\n\n        // Calculate threshold prices\n        uint256 upperThreshold_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) & X7;\n        uint256 lowerThreshold_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) & X7;\n        if (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) & X1) == 1) {\n            // if active shift is going on for threshold then calculate threshold real time\n            (upperThreshold_, lowerThreshold_) = _calcThresholdShifting(upperThreshold_, lowerThreshold_, dexId_);\n        }\n\n        unchecked {\n            upperThreshold_ = \n                (centerPrice_ + ((upperRange_ - centerPrice_) * (TWO_DECIMALS - upperThreshold_)) / TWO_DECIMALS);\n            lowerThreshold_ = \n                (centerPrice_ - ((centerPrice_ - lowerRange_) * (TWO_DECIMALS - lowerThreshold_)) / TWO_DECIMALS);\n        }\n\n        if (price_ > upperThreshold_) {\n            if (rebalancingStatus_ != 2) {\n                _dexVariables[dexId_] = _dexVariables[dexId_] & ~(X2 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) | \n                    (2 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS);\n                return 2;\n            }\n        } else if (price_ < lowerThreshold_) {\n            if (rebalancingStatus_ != 3) {\n                _dexVariables[dexId_] = _dexVariables[dexId_] & ~(X2 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) | \n                    (3 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS);\n                return 3;\n            }\n        } else {\n            if (rebalancingStatus_ != 1) {\n                _dexVariables[dexId_] = _dexVariables[dexId_] & ~(X2 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) | \n                    (1 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS);\n                return 1;\n            }\n        }\n\n        return rebalancingStatus_;\n    }\n\n    function _transferTokens(\n        address tokenIn_,\n        uint256 amountIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        address to_,\n        bool isCallback_,\n        bytes calldata callbackData_\n    ) internal {\n        if (to_ == address(0)) {\n            to_ = msg.sender;\n        }\n\n        // Transfer tokens out first\n        if (tokenOut_ == NATIVE_TOKEN) {\n            SafeTransfer.safeTransferNative(to_, amountOut_);\n        } else {\n            SafeTransfer.safeTransfer(tokenOut_, to_, amountOut_);\n        }\n\n        // Transfer tokens in\n        if (tokenIn_ == NATIVE_TOKEN) {\n            if (isCallback_ && msg.value == 0) {\n                uint256 ethBalance_ = address(this).balance;\n                IDexLiteCallback(msg.sender).dexCallback(tokenIn_, amountIn_, callbackData_);\n                if (address(this).balance - ethBalance_ < amountIn_) revert InsufficientNativeTokenReceived(address(this).balance - ethBalance_, amountIn_);\n            }  else {\n                if (msg.value < amountIn_) {\n                    revert InsufficientNativeTokenReceived(msg.value, amountIn_);\n                }\n                if (msg.value > amountIn_) {\n                    SafeTransfer.safeTransferNative(msg.sender, msg.value - amountIn_);\n                }\n                // if msg.value == amountIn_ then that means the transfer has already happened\n            }\n        } else {\n            if (msg.value > 0) {\n                revert InvalidMsgValue(); // msg.value should be 0 for non native tokens\n            }\n            if (isCallback_) {\n                uint256 tokenInBalance_ = IERC20(tokenIn_).balanceOf(address(this));\n                IDexLiteCallback(msg.sender).dexCallback(tokenIn_, amountIn_, callbackData_);\n                if ((IERC20(tokenIn_).balanceOf(address(this)) - tokenInBalance_) < amountIn_) {\n                    revert InsufficientERC20Received(IERC20(tokenIn_).balanceOf(address(this)) - tokenInBalance_, amountIn_);\n                }\n            } else {\n                SafeTransfer.safeTransferFrom(tokenIn_, msg.sender, address(this), amountIn_);\n            }\n        }\n    }\n\n    /// @dev            do any arbitrary call\n    /// @param target_  Address to which the call needs to be delegated\n    /// @param data_    Data to execute at the delegated address\n    function _spell(address target_, bytes memory data_) internal returns (bytes memory response_) {\n        assembly {\n            let succeeded := delegatecall(gas(), target_, add(data_, 0x20), mload(data_), 0, 0)\n            let size := returndatasize()\n\n            response_ := mload(0x40)\n            mstore(0x40, add(response_, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response_, size)\n            returndatacopy(add(response_, 0x20), 0, size)\n\n            if iszero(succeeded) {\n                // throw if delegatecall failed\n                returndatacopy(0x00, 0x00, size)\n                revert(0x00, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/protocols/dexLite/core/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./coreInternals.sol\";\n\n/// @title FluidDexLite\ncontract FluidDexLite is CoreInternals {\n    constructor(address auth_, address liquidity_, address deployerContract_) {\n        _isAuth[auth_] = 1;\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        DEPLOYER_CONTRACT = deployerContract_;\n    }\n\n    /// @notice Swap through a single dex pool\n    /// @dev Uses _swapIn for positive amountSpecified_ (user provides input), _swapOut for negative (user receives output).\n    /// @param dexKey_ The dex pool to swap through.\n    /// @param swap0To1_ Whether to swap from token0 to token1 or vice versa.\n    /// @param amountSpecified_ The amount to swap (positive for exact input, negative for exact output).\n    /// @param amountLimit_ The minimum/maximum amount for the unspecified side.\n    /// @param to_ The recipient address.\n    function swapSingle(\n        DexKey calldata dexKey_, \n        bool swap0To1_, \n        int256 amountSpecified_,\n        uint256 amountLimit_,\n        address to_,\n        bool isCallback_,\n        bytes calldata callbackData_,\n        bytes calldata extraData_\n    ) external payable _reentrancyLock returns (uint256 amountUnspecified_) {\n        if (amountSpecified_ > 0) {\n            amountUnspecified_ = _swapIn(dexKey_, swap0To1_, uint256(amountSpecified_));\n\n            if (amountUnspecified_ < amountLimit_) {\n                revert AmountLimitNotMet(amountUnspecified_, amountLimit_);\n            }\n\n            if (extraData_.length == 0) {\n                if (swap0To1_) {\n                    _transferTokens(dexKey_.token0, uint256(amountSpecified_), dexKey_.token1, amountUnspecified_, to_, isCallback_, callbackData_);\n                } else {\n                    _transferTokens(dexKey_.token1, uint256(amountSpecified_), dexKey_.token0, amountUnspecified_, to_, isCallback_, callbackData_);\n                }\n            } else if (extraData_.length == 32 && bytes32(extraData_) == ESTIMATE_SWAP) {\n                revert EstimateSwap(amountUnspecified_);\n            } else {\n                _callExtraDataSlot(\n                    abi.encode(\n                        SWAP_SINGLE, \n                        abi.encode(dexKey_, swap0To1_, amountSpecified_, amountUnspecified_, extraData_)\n                    )\n                );\n            }\n        } else {\n            amountUnspecified_ = _swapOut(dexKey_, swap0To1_, uint256(-amountSpecified_));\n\n            if (amountUnspecified_ > amountLimit_) {\n                revert AmountLimitExceeded(amountUnspecified_, amountLimit_);\n            }\n\n            if (extraData_.length == 0) {\n                if (swap0To1_) {\n                    _transferTokens(dexKey_.token0, amountUnspecified_, dexKey_.token1, uint256(-amountSpecified_), to_, isCallback_, callbackData_);\n                } else {\n                    _transferTokens(dexKey_.token1, amountUnspecified_, dexKey_.token0, uint256(-amountSpecified_), to_, isCallback_, callbackData_);\n                }\n            } else if (extraData_.length == 32 && bytes32(extraData_) == ESTIMATE_SWAP) {\n                revert EstimateSwap(amountUnspecified_);\n            } else {\n                _callExtraDataSlot(\n                    abi.encode(\n                        SWAP_SINGLE, \n                        abi.encode(dexKey_, swap0To1_, amountSpecified_, amountUnspecified_, extraData_)\n                    )\n                );\n            }\n        }\n    }\n\n    /// @notice Swap through a path of dex pools\n    /// @dev Uses _swapIn for positive amountSpecified_ (user provides input), _swapOut for negative (user receives output).\n    /// @param path_ The path of the swap.\n    /// @param dexKeys_ The dex pools to swap through.\n    /// @param amountSpecified_ The amount to swap (positive for exact input, negative for exact output).\n    /// @param amountLimits_ The minimum/maximum amount for the unspecified side for all swaps.\n    /// @param transferParams_ The parameters for the transfer.\n    /// @return amountUnspecified_ The amount of the unspecified token.\n    function swapHop(\n        address[] calldata path_,\n        DexKey[] calldata dexKeys_,\n        int256 amountSpecified_,\n        uint256[] calldata amountLimits_,\n        TransferParams calldata transferParams_\n    ) external payable _reentrancyLock returns (uint256 amountUnspecified_) {\n        if (dexKeys_.length == 0) {\n            revert EmptyDexKeysArray();\n        }\n        if (path_.length - 1 != dexKeys_.length) {\n            revert InvalidPathLength(path_.length, dexKeys_.length);\n        }\n        if (amountLimits_.length != dexKeys_.length) {\n            revert InvalidAmountLimitsLength(amountLimits_.length, dexKeys_.length);\n        }\n\n        if (amountSpecified_ > 0) {\n            // Swap In (Exact input amount provided by the user)\n            amountUnspecified_ = uint256(amountSpecified_);\n\n            for (uint256 i = 0; i < dexKeys_.length; ) {\n                bool swap0To1_;\n                unchecked {\n                    if (path_[i] == dexKeys_[i].token0 && path_[i + 1] == dexKeys_[i].token1) {\n                        swap0To1_ = true;\n                    } else if (path_[i] == dexKeys_[i].token1 && path_[i + 1] == dexKeys_[i].token0) {\n                        swap0To1_ = false;\n                    } else {\n                        revert InvalidPathTokenOrder();\n                    }\n                }\n\n                amountUnspecified_ = _swapIn(dexKeys_[i], swap0To1_, amountUnspecified_);\n                if (amountUnspecified_ < amountLimits_[i]) {\n                    revert AmountLimitNotMet(amountUnspecified_, amountLimits_[i]);\n                }\n\n                unchecked { ++i; }\n            }\n\n            if (transferParams_.extraData.length == 0) {\n                _transferTokens(\n                    path_[0], \n                    uint256(amountSpecified_), \n                    path_[dexKeys_.length], \n                    amountUnspecified_, \n                    transferParams_.to, \n                    transferParams_.isCallback, \n                    transferParams_.callbackData\n                );\n            } else if (transferParams_.extraData.length == 32 && bytes32(transferParams_.extraData) == ESTIMATE_SWAP) {\n                revert EstimateSwap(amountUnspecified_);\n            } else {\n                _callExtraDataSlot(\n                    abi.encode(\n                        SWAP_HOP, \n                        abi.encode(path_, dexKeys_, amountSpecified_, amountUnspecified_, transferParams_.extraData)\n                    )\n                );\n            }\n                \n        } else {\n            // Swap Out (Exact output amount received by the user)\n            amountUnspecified_ = uint256(-amountSpecified_);\n\n            for (uint256 i = dexKeys_.length; i > 0; ) {\n                bool swap0To1_;\n                unchecked {\n                    if (path_[i - 1] == dexKeys_[i - 1].token0 && path_[i] == dexKeys_[i - 1].token1) {\n                        swap0To1_ = true;\n                    } else if (path_[i - 1] == dexKeys_[i - 1].token1 && path_[i] == dexKeys_[i - 1].token0) {\n                        swap0To1_ = false;\n                    } else {\n                        revert InvalidPathTokenOrder();\n                    }\n                }\n\n                amountUnspecified_ = _swapOut(dexKeys_[i - 1], swap0To1_, amountUnspecified_);\n                if (amountUnspecified_ > amountLimits_[i - 1]) {\n                    revert AmountLimitExceeded(amountUnspecified_, amountLimits_[i - 1]);\n                }\n\n                unchecked { --i; }\n            }\n\n            if (transferParams_.extraData.length == 0) {\n                _transferTokens(\n                    path_[0], \n                    amountUnspecified_, \n                    path_[dexKeys_.length], \n                    uint256(-amountSpecified_), \n                    transferParams_.to, \n                    transferParams_.isCallback, \n                    transferParams_.callbackData\n                );\n            } else if (transferParams_.extraData.length == 32 && bytes32(transferParams_.extraData) == ESTIMATE_SWAP) {\n                revert EstimateSwap(amountUnspecified_);\n            } else {\n                _callExtraDataSlot(\n                    abi.encode(\n                        SWAP_HOP, \n                        abi.encode(path_, dexKeys_, amountSpecified_, amountUnspecified_, transferParams_.extraData)\n                    )\n                );\n            }\n        }\n    }\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_) {\n        assembly {\n            result_ := sload(slot_)\n        }\n    }\n\n    fallback(bytes calldata data_) external payable _reentrancyLock returns (bytes memory) {\n        if (_isAuth[msg.sender] != 1 && _getGovernanceAddr() != msg.sender) {\n            revert UnauthorizedCaller(msg.sender);\n        }\n\n        (address target_, bytes memory spellData_) = abi.decode(data_, (address, bytes));\n        return _spell(target_, spellData_);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/protocols/dexLite/other/commonImport.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./variables.sol\";\n\nabstract contract CommonImport is Variables {}\n"
    },
    "contracts/protocols/dexLite/other/constantVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./events.sol\";\n\nabstract contract ConstantVariables {\n    /*//////////////////////////////////////////////////////////////\n                                CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// bytes32(uint256(keccak256(\"FLUID_DEX_LITE_EXTRA_DATA\")) - 1)\n    bytes32 internal constant EXTRA_DATA_SLOT = 0x7e8134afb5ed35d36cb65e24b9a4712a52bb77d952806c1acf50970d2107797f;\n\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1\n    /// The exact slot which stored the admin address in infinite proxy of liquidity contracts\n    bytes32 internal constant LIQUIDITY_GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    bool internal constant SWAP_SINGLE = true;\n    bool internal constant SWAP_HOP = false;\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal constant NATIVE_TOKEN_DECIMALS = 18;\n    uint256 internal constant TOKENS_DECIMALS_PRECISION = 9;\n\n    uint8 internal constant MIN_TOKEN_DECIMALS = 6;\n    uint8 internal constant MAX_TOKEN_DECIMALS = 18;\n\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 20;\n    uint256 internal constant BIG_COEFFICIENT_SIZE = 32;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant X1 = 0x1;\n    uint256 internal constant X2 = 0x3;\n    uint256 internal constant X5 = 0x1f;\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X13 = 0x1fff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X19 = 0x7ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X56 = 0xffffffffffffff;\n    uint256 internal constant X60 = 0xfffffffffffffff;\n    uint256 internal constant X73 = 0x1ffffffffffffffffff;\n    uint256 internal constant X120 = 0xffffffffffffffffffffffffffffff;\n    uint256 internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n   \n    uint256 internal constant TWO_DECIMALS = 1e2;\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant SIX_DECIMALS = 1e6;\n\n    uint256 internal constant PRICE_PRECISION = 1e27;\n\n    /// after swap token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_SWAP\n    /// after swap token1 reserves should not be less than token0InToken1 / MINIMUM_LIQUIDITY_SWAP\n    uint256 internal constant MINIMUM_LIQUIDITY_SWAP = 1e4;\n\n    bytes32 internal constant ESTIMATE_SWAP = keccak256(bytes(\"ESTIMATE_SWAP\"));\n}\n"
    },
    "contracts/protocols/dexLite/other/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./interfaces.sol\";\n\nevent LogSwap(uint256 swapData, uint256 dexVariables);\n// swapData\n// First 64 bits => 0   - 63  => dexId\n// Next  1  bit  => 64        => swap 0 to 1 (1 => true, 0 => false)\n// Next  60 bits => 65  - 124 => amount in adjusted\n// Next  60 bits => 125 - 184 => amount out adjusted\n\n// dexVariables\n// Same as variables.sol"
    },
    "contracts/protocols/dexLite/other/immutableVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport \"./constantVariables.sol\";\n\n// TODO\n// import { IFluidDexFactory } from \"../../interfaces/iDexFactory.sol\";\n// import { Error } from \"../../error.sol\";\n// import { ErrorTypes } from \"../../errorTypes.sol\";\n\nabstract contract ImmutableVariables is ConstantVariables {\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Address of liquidity contract\n    IFluidLiquidity internal immutable LIQUIDITY;\n\n    /// @dev Address of contract used for deploying center price & hook related contract\n    address internal immutable DEPLOYER_CONTRACT;\n}\n"
    },
    "contracts/protocols/dexLite/other/interfaces.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport \"./structs.sol\";\n\ninterface IERC20WithDecimals is IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ninterface IDexLiteCallback {\n    function dexCallback(address token_, uint256 amount_, bytes calldata data_) external;\n}\n\ninterface ICenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price The current price of token0 in terms of token1, expressed with 27 decimal places\n    function centerPrice(address token0_, address token1_) external returns (uint256);\n}"
    },
    "contracts/protocols/dexLite/other/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./events.sol\";\n\nstruct DexKey {\n    address token0;\n    address token1;\n    bytes32 salt;\n}\n\nstruct TransferParams {\n    address to;\n    bool isCallback;\n    bytes callbackData;\n    bytes extraData;\n}\n"
    },
    "contracts/protocols/dexLite/other/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./immutableVariables.sol\";\n\nabstract contract Variables is ImmutableVariables {\n    /// @dev admin address\n    mapping(address => uint256) internal _isAuth;\n\n    /// @dev dexes list\n    DexKey[] internal _dexesList;\n\n    // First 13 bits => 0   - 12  => fee (1% = 10000, max value: 8191 = .8191%)\n    // Next  7  bits => 13  - 19  => revenue cut (1 = 1%)\n    // Next  2  bit  => 20  - 21  => rebalancing status (0 = off, 1 = on but not active, 2 = rebalancing active towards upper range, 3 = rebalancing active towards lower range)\n    // Next  1  bit  => 22        => is center price shift active\n    // Next  40 bits => 23  - 62  => center price. Center price from where the ranges will be calculated. BigNumber (32 bits precision, 8 bits exponent)\n    // Next  19 bits => 63  - 81  => center price contract address (Deployment Factory Nonce)\n    // Next  1  bit  => 82        => range percent shift active or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time\n    // Next  14 bits => 83  - 96  => upperPercent (1% = 100) upperRange - upperRange * upperPercent = centerPrice. Hence, upperRange = centerPrice / (1 - upperPercent)\n    // Next  14 bits => 97  - 110 => lowerPercent (1% = 100) lowerRange = centerPrice - centerPrice * lowerPercent\n    // Next  1  bit  => 111       => threshold percent shift active or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time\n    // Next  7 bits  => 112 - 118 => upper shift threshold percent, 1 = 1%. 100 = 100%. if currentPrice > (centerPrice + (upperRange - centerPrice) * (100 - upperShiftThresholdPercent) / 100) then trigger shift\n    // Next  7 bits  => 119 - 125 => lower shift threshold percent, 1 = 1%. 100 = 100%. if currentPrice < (centerPrice - (centerPrice - lowerRange) * (100 - lowerShiftThresholdPercent) / 100) then trigger shift\n    // Next  5  bits => 126 - 130 => token 0 decimals\n    // Next  5  bits => 131 - 135 => token 1 decimals\n    // Next  60 bits => 136 - 195 => total token 0 adjusted amount\n    // Next  60 bits => 196 - 255 => total token 1 adjusted amount\n    /// @dev dex id => dex variables\n    mapping(bytes8 => uint256) internal _dexVariables;\n\n    /// NOTE: Center price shift is always fuzzy, and can shift because of rebalancing or center price shift\n    // First 33 bits => 0   - 32  => last interaction timestamp (only stored when either rebalancing or center price shift is active)\n    /// REBALANCING RELATED THINGS\n    // First 24 bits => 33  - 56  => shifting time (max ~194 days)\n    // Next  28 bits => 57  - 84  => max center price. BigNumber (20 bits precision, 8 bits exponent)\n    // Next  28 bits => 85  - 112 => min center price. BigNumber (20 bits precision, 8 bits exponent)\n    /// CENTER PRICE SHIFT RELATED THINGS\n    // First 20 bits => 113 - 132 => % shift (1% = 1000)\n    // Next  20 bits => 133 - 152 => time to shift that percent, ~12 days max\n    // Next  33 bits => 153 - 185 => timestamp of when the shift started\n    // Last 70 bits empty\n    /// @dev dex id => center price shift\n    mapping(bytes8 => uint256) internal _centerPriceShift;\n\n    /// Range Shift (first 128 bits)\n    // First 14 bits => 0  - 13 => old upper range percent\n    // Next  14 bits => 14 - 27 => old lower range percent\n    // Next  20 bits => 28 - 47 => time to shift in seconds, ~12 days max, shift can last for max ~12 days\n    // Next  33 bits => 48 - 80 => timestamp of when the shift has started.\n    // Last 175 bits empty\n    /// @dev dex id => range shift\n    mapping(bytes8 => uint256) internal _rangeShift;\n\n    // First 7  bits => 0  - 6  => old upper threshold percent\n    // Next  7  bits => 7  - 13 => old lower threshold percent\n    // Next  20 bits => 14 - 33 => time to shift in seconds, ~12 days max, shift can last for max ~12 days\n    // Next  33 bits => 34 - 66 => timestamp of when the shift has started\n    // Last 189 bits empty\n    /// @dev dex id => threshold shift\n    mapping(bytes8 => uint256) internal _thresholdShift;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}