{
  "language": "Solidity",
  "sources": {
    "contracts/infiniteProxy/interfaces/iProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\ninterface IProxy {\n    function setAdmin(address newAdmin_) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external;\n\n    function removeImplementation(address implementation_) external;\n\n    function getAdmin() external view returns (address);\n\n    function getDummyImplementation() external view returns (address);\n\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory);\n\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\n\n    function readFromStorage(bytes32 slot_) external view returns (uint256 result_);\n}\n"
    },
    "contracts/libraries/addressCalcs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n/// @notice implements calculation of address for contracts deployed through CREATE.\n/// Accepts contract deployed from which address & nonce\nlibrary AddressCalcs {\n\n    /// @notice                         Computes the address of a contract based\n    /// @param deployedFrom_            Address from which the contract was deployed\n    /// @param nonce_                   Nonce at which the contract was deployed\n    /// @return contract_               Address of deployed contract\n    function addressCalc(address deployedFrom_, uint nonce_) internal pure returns (address contract_) {\n        // @dev based on https://ethereum.stackexchange.com/a/61413\n\n        // nonce of smart contract always starts with 1. so, with nonce 0 there won't be any deployment\n        // hence, nonce of vault deployment starts with 1.\n        bytes memory data;\n        if (nonce_ == 0x00) {\n            return address(0);\n        } else if (nonce_ <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployedFrom_, uint8(nonce_));\n        } else if (nonce_ <= 0xff) {\n            data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployedFrom_, bytes1(0x81), uint8(nonce_));\n        } else if (nonce_ <= 0xffff) {\n            data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployedFrom_, bytes1(0x82), uint16(nonce_));\n        } else if (nonce_ <= 0xffffff) {\n            data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployedFrom_, bytes1(0x83), uint24(nonce_));\n        } else {\n            data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployedFrom_, bytes1(0x84), uint32(nonce_));\n        }\n\n        return address(uint160(uint256(keccak256(data))));\n    }\n\n}"
    },
    "contracts/libraries/bigMathMinified.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399584 = 10000101010010110100000011111011110010100110100000000011100101001101001101011100000\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n\n    /// @dev gets the least significant bit `firstBit` of a `normal` number (position of rightmost 1 in binary format).\n    /// e.g.\n    /// 5035703444687813576399584 = 10000101010010110100000011111011110010100110100000000011100101001101001101011100000\n    /// firstBit =                                                                                               ^-6--^\n    function leastSignificantBit(uint256 normal) internal pure returns (uint firstBit) {\n        assembly {\n            // If number is 0, revert as there is no least significant bit\n            if iszero(normal) {\n                revert(0, 0)\n            }\n\n            // Find first set bit using binary search\n            let number_ := normal\n            firstBit := 0\n\n            // Check if lower 128 bits are all zero\n            if iszero(and(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) {\n                number_ := shr(0x80, number_)\n                firstBit := 0x80\n            }\n            // Check if lower 64 bits are all zero\n            if iszero(and(number_, 0xFFFFFFFFFFFFFFFF)) {\n                number_ := shr(0x40, number_)\n                firstBit := add(firstBit, 0x40)\n            }\n            // Check if lower 32 bits are all zero\n            if iszero(and(number_, 0xFFFFFFFF)) {\n                number_ := shr(0x20, number_)\n                firstBit := add(firstBit, 0x20)\n            }\n            // Check if lower 16 bits are all zero\n            if iszero(and(number_, 0xFFFF)) {\n                number_ := shr(0x10, number_)\n                firstBit := add(firstBit, 0x10)\n            }\n            // Check if lower 8 bits are all zero\n            if iszero(and(number_, 0xFF)) {\n                number_ := shr(0x8, number_)\n                firstBit := add(firstBit, 0x8)\n            }\n            // Check if lower 4 bits are all zero\n            if iszero(and(number_, 0xF)) {\n                number_ := shr(0x4, number_)\n                firstBit := add(firstBit, 0x4)\n            }\n            // Check if lower 2 bits are all zero\n            if iszero(and(number_, 0x3)) {\n                number_ := shr(0x2, number_)\n                firstBit := add(firstBit, 0x2)\n            }\n            // Check if lowest bit is zero\n            if iszero(and(number_, 0x1)) {\n                firstBit := add(firstBit, 1)\n            }\n            // Add 1 to match the 1-based position counting\n            firstBit := add(firstBit, 1)\n        }\n    }\n}\n"
    },
    "contracts/libraries/dexLiteSlotsLink.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex Lite.\nlibrary DexLiteSlotsLink {\n    /// @dev storage slot for is auth mapping\n    uint256 internal constant DEX_LITE_IS_AUTH_SLOT = 0;\n    /// @dev storage slot for dexes list\n    uint256 internal constant DEX_LITE_DEXES_LIST_SLOT = 1;\n    /// @dev storage slot for is dex variables\n    uint256 internal constant DEX_LITE_DEX_VARIABLES_SLOT = 2;\n    /// @dev storage slot for center price shift\n    uint256 internal constant DEX_LITE_CENTER_PRICE_SHIFT_SLOT = 3;\n    /// @dev storage slot for range shift\n    uint256 internal constant DEX_LITE_RANGE_SHIFT_SLOT = 4;\n    /// @dev storage slot for threshold shift\n    uint256 internal constant DEX_LITE_THRESHOLD_SHIFT_SLOT = 5;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // DexVariables\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_FEE = 0;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT = 13;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS = 20;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE = 22;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE = 23;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS = 63;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE = 82;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT = 83;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT = 97;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE = 111;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT = 112;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT = 119;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS = 126;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS = 131;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED = 136;\n    uint256 internal constant BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED = 196;\n\n    // CenterPriceShift\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP = 0;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME = 33;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE = 57;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE = 85;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT = 113;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT = 133;\n    uint256 internal constant BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP = 153;\n\n    // RangeShift\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT = 0;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT = 14;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT = 28;\n    uint256 internal constant BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP = 48;\n\n    // ThresholdShift\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT = 0;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT = 7;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT = 14;\n    uint256 internal constant BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP = 34;\n\n    // --------------------------------\n    // @dev stacked uint256 swapData for LogSwap event\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_DEX_ID = 0;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_SWAP_0_TO_1 = 64;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_AMOUNT_IN = 65;\n    uint256 internal constant BITS_DEX_LITE_SWAP_DATA_AMOUNT_OUT = 125;\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, bytes32 key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n}\n"
    },
    "contracts/libraries/errorTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n\n    /***********************************|\n    |           SafeApprove             | \n    |__________________________________*/\n\n    /// @notice thrown when safe approve from for an ERC20 fails\n    uint256 internal constant SafeApprove__ApproveFailed = 81001;\n}\n"
    },
    "contracts/libraries/safeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\n\n/// @notice provides minimalistic methods for safe transfers, e.g. ERC20 safeTransferFrom\nlibrary SafeTransfer {\n    uint256 internal constant MAX_NATIVE_TRANSFER_GAS = 20000; // pass max. 20k gas for native transfers\n\n    error FluidSafeTransferError(uint256 errorId_);\n\n    /// @dev Transfer `amount_` of `token_` from `from_` to `to_`, spending the approval given by `from_` to the\n    /// calling contract. If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L31-L63\n    function safeTransferFrom(address token_, address from_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from_\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 68), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFromFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of `token_` to `to_`.\n    /// If `token_` returns no value, non-reverting calls are assumed to be successful.\n    /// Minimally modified from Solmate SafeTransferLib (address as input param for token, Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L65-L95\n    function safeTransfer(address token_, address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to_, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to_\" argument.\n            mstore(add(freeMemoryPointer, 36), amount_) // Append the \"amount_\" argument. Masking not required as it's a full 32 byte type.\n\n            success_ := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n\n    /// @dev Transfer `amount_` of ` native token to `to_`.\n    /// Minimally modified from Solmate SafeTransferLib (Custom Error):\n    /// https://github.com/transmissions11/solmate/blob/50e15bb566f98b7174da9b0066126a4c3e75e0fd/src/utils/SafeTransferLib.sol#L15-L25\n    function safeTransferNative(address to_, uint256 amount_) internal {\n        bool success_;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not. Pass limited gas\n            success_ := call(MAX_NATIVE_TRANSFER_GAS, to_, amount_, 0, 0, 0, 0)\n        }\n\n        if (!success_) {\n            revert FluidSafeTransferError(ErrorTypes.SafeTransfer__TransferFailed);\n        }\n    }\n}\n"
    },
    "contracts/liquidity/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.21 <=0.8.29;\n\nabstract contract Structs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    /// @notice struct to set borrow rate data for version 1\n    struct RateDataV1Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink usually means slow increase in rate, once utilization is above kink borrow rate increases fast\n        uint256 kink;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink borrow rate when utilization is at kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink;\n        ///\n        /// @param rateAtUtilizationMax borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set borrow rate data for version 2\n    struct RateDataV2Params {\n        ///\n        /// @param token for rate data\n        address token;\n        ///\n        /// @param kink1 first kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 1 usually means slow increase in rate, once utilization is above kink 1 borrow rate increases faster\n        uint256 kink1;\n        ///\n        /// @param kink2 second kink in borrow rate. in 1e2: 100% = 10_000; 1% = 100\n        /// utilization below kink 2 usually means slow / medium increase in rate, once utilization is above kink 2 borrow rate increases fast\n        uint256 kink2;\n        ///\n        /// @param rateAtUtilizationZero desired borrow rate when utilization is zero. in 1e2: 100% = 10_000; 1% = 100\n        /// i.e. constant minimum borrow rate\n        /// e.g. at utilization = 0.01% rate could still be at least 4% (rateAtUtilizationZero would be 400 then)\n        uint256 rateAtUtilizationZero;\n        ///\n        /// @param rateAtUtilizationKink1 desired borrow rate when utilization is at first kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at first kink then rateAtUtilizationKink would be 700\n        uint256 rateAtUtilizationKink1;\n        ///\n        /// @param rateAtUtilizationKink2 desired borrow rate when utilization is at second kink. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 7% at second kink then rateAtUtilizationKink would be 1_200\n        uint256 rateAtUtilizationKink2;\n        ///\n        /// @param rateAtUtilizationMax desired borrow rate when utilization is maximum at 100%. in 1e2: 100% = 10_000; 1% = 100\n        /// e.g. when rate should be 125% at 100% then rateAtUtilizationMax would be 12_500\n        uint256 rateAtUtilizationMax;\n    }\n\n    /// @notice struct to set token config\n    struct TokenConfig {\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param fee charges on borrower's interest. in 1e2: 100% = 10_000; 1% = 100\n        uint256 fee;\n        ///\n        /// @param threshold on when to update the storage slot. in 1e2: 100% = 10_000; 1% = 100\n        uint256 threshold;\n        ///\n        /// @param maxUtilization maximum allowed utilization. in 1e2: 100% = 10_000; 1% = 100\n        ///                       set to 100% to disable and have default limit of 100% (avoiding SLOAD).\n        uint256 maxUtilization;\n    }\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param token address\n        address token;\n        ///\n        /// @param mode: 0 = without interest. 1 = with interest\n        uint8 mode;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n}\n"
    },
    "contracts/liquidity/interfaces/iLiquidity.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.21 <=0.8.29;\n\nimport { IProxy } from \"../../infiniteProxy/interfaces/iProxy.sol\";\nimport { Structs as AdminModuleStructs } from \"../adminModule/structs.sol\";\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(AdminModuleStructs.AddressBool[] calldata authsStatus_) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(AdminModuleStructs.AddressBool[] calldata guardiansStatus_) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(AdminModuleStructs.TokenConfig[] calldata tokenConfigs_) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(AdminModuleStructs.AddressUint256[] calldata userClasses_) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_) external;\n\n    /// @notice sets a new withdrawal limit as the current limit for a certain user\n    /// @param user_ user address for which to update the withdrawal limit\n    /// @param token_ token address for which to update the withdrawal limit\n    /// @param newLimit_ new limit until which user supply can decrease to.\n    ///                  Important: input in raw. Must account for exchange price in input param calculation.\n    ///                  Note any limit that is < max expansion or > current user supply will set max expansion limit or\n    ///                  current user supply as limit respectively.\n    ///                  - set 0 to make maximum possible withdrawable: instant full expansion, and if that goes\n    ///                  below base limit then fully down to 0.\n    ///                  - set type(uint256).max to make current withdrawable 0 (sets current user supply as limit).\n    function updateUserWithdrawalLimit(address user_, address token_, uint256 newLimit_) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(address user_, address[] calldata supplyTokens_, address[] calldata borrowTokens_) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    ) external returns (uint256[] memory supplyExchangePrices_, uint256[] memory borrowExchangePrices_);\n}\n\ninterface IFluidLiquidityLogic is IFluidLiquidityAdmin {\n    /// @notice Single function which handles supply, withdraw, borrow & payback\n    /// @param token_ address of token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native)\n    /// @param supplyAmount_ if +ve then supply, if -ve then withdraw, if 0 then nothing\n    /// @param borrowAmount_ if +ve then borrow, if -ve then payback, if 0 then nothing\n    /// @param withdrawTo_ if withdrawal then to which address\n    /// @param borrowTo_ if borrow then to which address\n    /// @param callbackData_ callback data passed to `liquidityCallback` method of protocol\n    /// @return memVar3_ updated supplyExchangePrice\n    /// @return memVar4_ updated borrowExchangePrice\n    /// @dev to trigger skipping in / out transfers (gas optimization):\n    /// -  ` callbackData_` MUST be encoded so that \"from\" address is the last 20 bytes in the last 32 bytes slot,\n    ///     also for native token operations where liquidityCallback is not triggered!\n    ///     from address must come at last position if there is more data. I.e. encode like:\n    ///     abi.encode(otherVar1, otherVar2, FROM_ADDRESS). Note dynamic types used with abi.encode come at the end\n    ///     so if dynamic types are needed, you must use abi.encodePacked to ensure the from address is at the end.\n    /// -   this \"from\" address must match withdrawTo_ or borrowTo_ and must be == `msg.sender`\n    /// -   `callbackData_` must in addition to the from address as described above include bytes32 SKIP_TRANSFERS\n    ///     in the slot before (bytes 32 to 63)\n    /// -   `msg.value` must be 0.\n    /// -   Amounts must be either:\n    ///     -  supply(+) == borrow(+), withdraw(-) == payback(-).\n    ///     -  Liquidity must be on the winning side (deposit < borrow OR payback < withdraw).\n    function operate(\n        address token_,\n        int256 supplyAmount_,\n        int256 borrowAmount_,\n        address withdrawTo_,\n        address borrowTo_,\n        bytes calldata callbackData_\n    ) external payable returns (uint256 memVar3_, uint256 memVar4_);\n}\n\ninterface IFluidLiquidity is IProxy, IFluidLiquidityLogic {}\n"
    },
    "contracts/protocols/dexLite/adminModule/errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./structs.sol\";\n\nerror InvalidParams();\nerror OnlyDelegateCallAllowed();\nerror AddressNotAContract(address addr);\nerror InvalidTokenOrder(address token0, address token1);\nerror DexNotInitialized(bytes32 dexId);\nerror DexAlreadyInitialized(bytes32 dexId);\nerror InvalidRevenueCut(uint256 revenueCut);\nerror InsufficientMsgValue(uint256 msgValue, uint256 requiredAmount);"
    },
    "contracts/protocols/dexLite/adminModule/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./errors.sol\";\n\nevent LogUpdateAuth(address auth, bool isAuth);\n\nevent LogInitialize(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 centerPriceShift, InitializeParams i);\n\nevent LogUpdateFeeAndRevenueCut(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 fee, uint256 revenueCut);\n\nevent LogUpdateRebalancingStatus(DexKey dexKey, bytes8 dexId, uint256 dexVariables, bool rebalancingStatus);\n\nevent LogUpdateRangePercents(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 rangeShift, uint256 upperPercent, uint256 lowerPercent, uint256 shiftTime);\n\nevent LogUpdateShiftTime(DexKey dexKey, bytes8 dexId, uint256 centerPriceShift, uint256 shiftTime);\n\nevent LogUpdateCenterPriceLimits(DexKey dexKey, bytes8 dexId, uint256 centerPriceShift, uint256 maxCenterPrice, uint256 minCenterPrice);\n\nevent LogUpdateThresholdPercent(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 thresholdShift, uint256 upperThresholdPercent, uint256 lowerThresholdPercent, uint256 shiftTime);\n\nevent LogUpdateCenterPriceAddress(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 centerPriceShift, uint256 centerPriceContract, uint256 percent, uint256 time);\n\nevent LogDeposit(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 token0Amount, uint256 token1Amount);\n\nevent LogWithdraw(DexKey dexKey, bytes8 dexId, uint256 dexVariables, uint256 token0Amount, uint256 token1Amount);\n\nevent LogCollectRevenue(address[] tokens, uint256[] amounts, address to);\n\nevent LogUpdateExtraDataAddress(address extraDataAddress);\n"
    },
    "contracts/protocols/dexLite/adminModule/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./immutableVariables.sol\";\nimport { SafeTransfer } from \"../../../libraries/safeTransfer.sol\";\n\nabstract contract AdminModuleHelpers is AdminModuleImmutableVariables {\n    modifier _onlyDelegateCall() {\n        if (address(this) == THIS_ADDRESS) revert OnlyDelegateCallAllowed();\n        _;\n    }\n\n    /// @dev checks that `value_` address is a contract (which includes address zero check)\n    function _checkIsContract(address value_) internal view {\n        if (value_.code.length == 0) {\n            revert AddressNotAContract(value_);\n        }\n    }\n\n    function _calculateNumeratorAndDenominatorPrecisions(uint256 decimals_) internal pure returns (uint256 numerator_, uint256 denominator_) {\n        if (decimals_ > TOKENS_DECIMALS_PRECISION) {\n            numerator_ = 1;\n            denominator_ = 10 ** (decimals_ - TOKENS_DECIMALS_PRECISION);\n        } else {\n            numerator_ = 10 ** (TOKENS_DECIMALS_PRECISION - decimals_);\n            denominator_ = 1;\n        }\n    }\n\n    function _transferTokenIn(address token_, uint256 amount_) internal {\n        if (amount_ == 0) return;\n\n        if (token_ == NATIVE_TOKEN) {\n            if (msg.value < amount_) revert InsufficientMsgValue(msg.value, amount_);\n            if (msg.value > amount_) SafeTransfer.safeTransferNative(msg.sender, msg.value - amount_);\n        } else SafeTransfer.safeTransferFrom(token_, msg.sender, address(this), amount_);\n    }\n\n    function _transferTokenOut(address token_, uint256 amount_, address to_) internal {\n        if (amount_ == 0) return;\n\n        if (token_ == NATIVE_TOKEN) SafeTransfer.safeTransferNative(to_, amount_);\n        else SafeTransfer.safeTransfer(token_, to_, amount_);\n    }\n}\n"
    },
    "contracts/protocols/dexLite/adminModule/immutableVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./events.sol\";\n\nabstract contract AdminModuleImmutableVariables is CommonImport {\n    address internal immutable THIS_ADDRESS;\n}\n"
    },
    "contracts/protocols/dexLite/adminModule/main.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport { DexLiteSlotsLink as DSL } from \"../../../libraries/dexLiteSlotsLink.sol\";\nimport { BigMathMinified as BM } from \"../../../libraries/bigMathMinified.sol\";\nimport { AddressCalcs as AC} from \"../../../libraries/addressCalcs.sol\";\nimport \"./helpers.sol\";\n\ncontract FluidDexLiteAdminModule is AdminModuleHelpers {\n    constructor(address liquidity_, address deployerContract_) {\n        THIS_ADDRESS = address(this);\n        LIQUIDITY = IFluidLiquidity(liquidity_);\n        DEPLOYER_CONTRACT = deployerContract_;\n    }\n\n    /// @dev update the auth for the dex\n    /// @param auth_ the address to update auth for\n    /// @param isAuth_ the auth status\n    function updateAuth(address auth_, bool isAuth_) external _onlyDelegateCall {\n        _isAuth[auth_] = isAuth_ ? 1 : 0;\n        \n        emit LogUpdateAuth(auth_, isAuth_);\n    }\n\n    /// @dev initialize the dex\n    /// @param i_ the initialize params\n    function initialize(InitializeParams memory i_) external payable _onlyDelegateCall {\n        if (i_.dexKey.token0 == address(0) || i_.dexKey.token1 == address(0) || i_.dexKey.token0 >= i_.dexKey.token1) {\n            revert InvalidTokenOrder(i_.dexKey.token0, i_.dexKey.token1);\n        }\n\n        InitializeVariables memory v_;\n\n        v_.dexId = bytes8(keccak256(abi.encode(i_.dexKey)));\n        if (_dexVariables[v_.dexId] != 0) {\n            revert DexAlreadyInitialized(v_.dexId);\n        }\n\n        v_.token0Decimals = i_.dexKey.token0 == NATIVE_TOKEN ? NATIVE_TOKEN_DECIMALS : IERC20WithDecimals(i_.dexKey.token0).decimals();\n        v_.token1Decimals = i_.dexKey.token1 == NATIVE_TOKEN ? NATIVE_TOKEN_DECIMALS : IERC20WithDecimals(i_.dexKey.token1).decimals();\n\n        // cut is an integer in storage slot which is more than enough\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\n        if (i_.revenueCut != 0 && i_.revenueCut < FOUR_DECIMALS) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert InvalidRevenueCut(i_.revenueCut);\n        }\n\n        i_.revenueCut = i_.revenueCut / FOUR_DECIMALS;\n\n        i_.upperPercent = i_.upperPercent / TWO_DECIMALS;\n        i_.lowerPercent = i_.lowerPercent / TWO_DECIMALS;\n\n        i_.upperShiftThreshold = i_.upperShiftThreshold / FOUR_DECIMALS;\n        i_.lowerShiftThreshold = i_.lowerShiftThreshold / FOUR_DECIMALS;\n\n        if (\n            (i_.fee > X13) ||\n            (i_.revenueCut > TWO_DECIMALS) ||\n            (i_.centerPrice <= i_.minCenterPrice) ||\n            (i_.centerPrice >= i_.maxCenterPrice) ||\n            (i_.centerPriceContract > X19) ||\n            (i_.upperPercent > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (i_.lowerPercent > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (i_.upperPercent == 0) ||\n            (i_.lowerPercent == 0) ||\n            (i_.upperShiftThreshold > TWO_DECIMALS) ||\n            (i_.lowerShiftThreshold > TWO_DECIMALS) ||\n            ((i_.upperShiftThreshold == 0) && (i_.lowerShiftThreshold > 0)) ||\n            ((i_.upperShiftThreshold > 0) && (i_.lowerShiftThreshold == 0)) ||\n            (i_.shiftTime == 0) ||\n            (i_.shiftTime > X24) ||\n            (i_.minCenterPrice == 0) || \n            (v_.token0Decimals < MIN_TOKEN_DECIMALS) ||\n            (v_.token0Decimals > MAX_TOKEN_DECIMALS) ||\n            (v_.token1Decimals < MIN_TOKEN_DECIMALS) ||\n            (v_.token1Decimals > MAX_TOKEN_DECIMALS)\n        ) {\n            revert InvalidParams();\n        }\n\n        _transferTokenIn(i_.dexKey.token0, i_.token0Amount);\n        _transferTokenIn(i_.dexKey.token1, i_.token1Amount);\n\n        (v_.token0NumeratorPrecision, v_.token0DenominatorPrecision) = _calculateNumeratorAndDenominatorPrecisions(v_.token0Decimals);\n        (v_.token1NumeratorPrecision, v_.token1DenominatorPrecision) = _calculateNumeratorAndDenominatorPrecisions(v_.token1Decimals);\n\n        _dexVariables[v_.dexId] = \n            (i_.fee << DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) |\n            (i_.revenueCut << DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT) |\n            ((i_.rebalancingStatus ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS) |\n            (BM.toBigNumber(i_.centerPrice, BIG_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_DOWN) << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) |\n            (i_.centerPriceContract << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) |\n            (i_.upperPercent << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) |\n            (i_.lowerPercent << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) |\n            (i_.upperShiftThreshold << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) |\n            (i_.lowerShiftThreshold << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) |\n            (v_.token0Decimals << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) |\n            (v_.token1Decimals << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) |\n            (((i_.token0Amount * v_.token0NumeratorPrecision) / v_.token0DenominatorPrecision) << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) |\n            (((i_.token1Amount * v_.token1NumeratorPrecision) / v_.token1DenominatorPrecision) << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        _centerPriceShift[v_.dexId] = \n            (block.timestamp << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_LAST_INTERACTION_TIMESTAMP) |\n            (i_.shiftTime << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME) |\n            (BM.toBigNumber(i_.maxCenterPrice, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_UP) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) |\n            (BM.toBigNumber(i_.minCenterPrice, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_DOWN) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE);\n        \n        _dexesList.push(i_.dexKey);\n        \n        emit LogInitialize(i_.dexKey, v_.dexId, _dexVariables[v_.dexId], _centerPriceShift[v_.dexId], i_);\n    }\n\n    /// @dev update the fee and revenue cut for the dex\n    /// @param dexKey_ the dex key\n    /// @param fee_ in 4 decimals, 10000 = 1%\n    /// @param revenueCut_ in 4 decimals, 10000 = 1%\n    function updateFeeAndRevenueCut(DexKey calldata dexKey_, uint256 fee_, uint256 revenueCut_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        // cut is an integer in storage slot which is more than enough\n        // but from UI we are allowing to send in 4 decimals to maintain consistency & avoid human error in future\n        if (revenueCut_ != 0 && revenueCut_ < FOUR_DECIMALS) {\n            // human input error. should send 0 for wanting 0, not 0 because of precision reduction.\n            revert InvalidRevenueCut(revenueCut_);\n        }\n\n        revenueCut_ = revenueCut_ / FOUR_DECIMALS;\n\n        if (fee_ > X13 || revenueCut_ > TWO_DECIMALS) {\n            revert InvalidParams();\n        }\n\n        _dexVariables[dexId_] = (dexVariables_ & ~(X20 << DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE)) | \n            (fee_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_FEE) |\n            (revenueCut_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_REVENUE_CUT);\n\n        emit LogUpdateFeeAndRevenueCut(dexKey_, dexId_, _dexVariables[dexId_], fee_, revenueCut_ * FOUR_DECIMALS);\n    }\n\n    /// @dev update the rebalancing status for the dex\n    /// @param dexKey_ the dex key\n    /// @param rebalancingStatus_ the rebalancing status (true = on, false = off)\n    function updateRebalancingStatus(DexKey calldata dexKey_, bool rebalancingStatus_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n        \n        _dexVariables[dexId_] = (dexVariables_ & ~(X2 << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS)) |\n            (rebalancingStatus_ ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_REBALANCING_STATUS;\n\n        emit LogUpdateRebalancingStatus(dexKey_, dexId_, _dexVariables[dexId_], rebalancingStatus_);\n    }\n\n    /// @dev update the range percents for the dex\n    /// @param dexKey_ the dex key\n    /// @param upperPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerPercent_ in 4 decimals, 10000 = 1%\n    /// @param shiftTime_ in secs, in how much time the upper percent configs change should be fully done\n    function updateRangePercents(\n        DexKey calldata dexKey_,\n        uint256 upperPercent_,\n        uint256 lowerPercent_,\n        uint256 shiftTime_\n    ) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        upperPercent_ = upperPercent_ / TWO_DECIMALS;\n        lowerPercent_ = lowerPercent_ / TWO_DECIMALS;\n\n        if (\n            (upperPercent_ > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (lowerPercent_ > (FOUR_DECIMALS - TWO_DECIMALS)) || // capping range to 99%\n            (upperPercent_ == 0) ||\n            (lowerPercent_ == 0) ||\n            (shiftTime_ > X20) ||\n            (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) & X1) == 1) // if last shift is still active then don't allow a newer shift\n        ) {\n            revert InvalidParams();\n        }\n\n        _dexVariables[dexId_] = (dexVariables_ & ~(X28 << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT)) |\n            ((shiftTime_ > 0 ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_RANGE_PERCENT_SHIFT_ACTIVE) |\n            (upperPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) |\n            (lowerPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT);\n\n        uint256 oldUpperPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_PERCENT) & X14;\n        uint256 oldLowerPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_PERCENT) & X14;\n\n        if (shiftTime_ > 0) {\n            _rangeShift[dexId_] = \n                (oldUpperPercent_ << DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_UPPER_RANGE_PERCENT) | \n                (oldLowerPercent_ << DSL.BITS_DEX_LITE_RANGE_SHIFT_OLD_LOWER_RANGE_PERCENT) | \n                (shiftTime_ << DSL.BITS_DEX_LITE_RANGE_SHIFT_TIME_TO_SHIFT) | \n                (block.timestamp << DSL.BITS_DEX_LITE_RANGE_SHIFT_TIMESTAMP);\n        }\n        // Note _rangeShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\n\n        emit LogUpdateRangePercents(dexKey_, dexId_, _dexVariables[dexId_], _rangeShift[dexId_], upperPercent_ * TWO_DECIMALS, lowerPercent_ * TWO_DECIMALS, shiftTime_);\n    }\n\n    /// @dev update the shift time for the dex for rebalancing\n    /// @param dexKey_ the dex key\n    /// @param shiftTime_ in secs, in how much time rebalancing should be fully done.\n    function updateShiftTime(DexKey calldata dexKey_, uint256 shiftTime_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n        \n        if (shiftTime_ == 0 || shiftTime_ > X24) {\n            revert InvalidParams();\n        }\n\n        _centerPriceShift[dexId_] = (_centerPriceShift[dexId_] & ~(X24 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME)) | \n            (shiftTime_ << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_SHIFTING_TIME);\n\n        emit LogUpdateShiftTime(dexKey_, dexId_, _centerPriceShift[dexId_], shiftTime_);\n    }\n\n    /// @dev update the center price limits for the dex\n    /// @param dexKey_ the dex key\n    /// @param maxCenterPrice_ 1:1 means 1e27 \n    /// @param minCenterPrice_ 1:1 means 1e27\n    function updateCenterPriceLimits(DexKey calldata dexKey_, uint256 maxCenterPrice_, uint256 minCenterPrice_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        uint256 centerPrice_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE) & X40;\n        centerPrice_ = (centerPrice_ >> DEFAULT_EXPONENT_SIZE) << (centerPrice_ & DEFAULT_EXPONENT_MASK);\n\n        if (\n            (maxCenterPrice_ <= minCenterPrice_) ||\n            (centerPrice_ <= minCenterPrice_) ||\n            (centerPrice_ >= maxCenterPrice_) ||\n            (minCenterPrice_ == 0)\n        ) {\n            revert InvalidParams();\n        }\n\n        _centerPriceShift[dexId_] = (_centerPriceShift[dexId_] & ~(X56 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE)) | \n            (BM.toBigNumber(maxCenterPrice_, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_UP) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MAX_CENTER_PRICE) |\n            (BM.toBigNumber(minCenterPrice_, SMALL_COEFFICIENT_SIZE, DEFAULT_EXPONENT_SIZE, BM.ROUND_DOWN) << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_MIN_CENTER_PRICE);\n\n        emit LogUpdateCenterPriceLimits(dexKey_, dexId_, _centerPriceShift[dexId_], maxCenterPrice_, minCenterPrice_);\n    }\n\n    /// @dev update the threshold percent for the dex\n    /// @param dexKey_ the dex key\n    /// @param upperThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param shiftTime_ in secs, in how much time the upper config changes should be fully done.\n    function updateThresholdPercent(\n        DexKey calldata dexKey_,\n        uint256 upperThresholdPercent_,\n        uint256 lowerThresholdPercent_,\n        uint256 shiftTime_\n    ) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        // thresholds are with 1% precision, hence removing last 4 decimals.\n        // we are allowing to send in 4 decimals to maintain consistency with other params\n        upperThresholdPercent_ = upperThresholdPercent_ / FOUR_DECIMALS;\n        lowerThresholdPercent_ = lowerThresholdPercent_ / FOUR_DECIMALS;\n        if (\n            (upperThresholdPercent_ > TWO_DECIMALS) ||\n            (lowerThresholdPercent_ > TWO_DECIMALS) ||\n            ((upperThresholdPercent_ == 0) && (lowerThresholdPercent_ > 0)) ||\n            ((upperThresholdPercent_ > 0) && (lowerThresholdPercent_ == 0)) ||\n            (shiftTime_ > X20) ||\n            (((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) & X1) == 1) // if last shift is still active then don't allow a newer shift\n        ) {\n            revert InvalidParams();\n        }\n\n        _dexVariables[dexId_] =\n            (dexVariables_ & ~(X14 << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT)) |\n            ((shiftTime_ > 0 ? uint256(1) : uint256(0)) << DSL.BITS_DEX_LITE_DEX_VARIABLES_THRESHOLD_PERCENT_SHIFT_ACTIVE) |\n            (upperThresholdPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) |\n            (lowerThresholdPercent_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT);\n\n        uint oldUpperThresholdPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_UPPER_SHIFT_THRESHOLD_PERCENT) & X7;\n        uint oldLowerThresholdPercent_ = (dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_LOWER_SHIFT_THRESHOLD_PERCENT) & X7;\n\n        if (shiftTime_ > 0) {\n            _thresholdShift[dexId_] = \n                (oldUpperThresholdPercent_ << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_UPPER_THRESHOLD_PERCENT) |\n                (oldLowerThresholdPercent_ << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_OLD_LOWER_THRESHOLD_PERCENT) |\n                (shiftTime_ << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIME_TO_SHIFT) |\n                (block.timestamp << DSL.BITS_DEX_LITE_THRESHOLD_SHIFT_TIMESTAMP);\n        }\n        // Note _thresholdShift is reset when the previous shift is fully completed, which is forced to have happened through if check above\n\n        emit LogUpdateThresholdPercent(dexKey_, dexId_, _dexVariables[dexId_], _thresholdShift[dexId_], upperThresholdPercent_ * FOUR_DECIMALS, lowerThresholdPercent_ * FOUR_DECIMALS, shiftTime_);\n    }\n\n    /// @dev update the center price address (nonce) for the dex\n    /// @param dexKey_ the dex key\n    /// @param centerPriceAddress_ nonce < X19, this nonce will be used to calculate contract address\n    /// @param percent_ in 4 decimals, 10000 = 1%\n    /// @param time_ in secs, in how much time the center price should be fully shifted.\n    function updateCenterPriceAddress(\n        DexKey calldata dexKey_,\n        uint256 centerPriceAddress_,\n        uint256 percent_,\n        uint256 time_\n    ) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        if ((centerPriceAddress_ > X19) || (percent_ == 0) || (percent_ > X20) || (time_ == 0) || (time_ > X20)) {\n            revert InvalidParams();\n        }\n\n        if (centerPriceAddress_ > 0) {\n            address centerPrice_ = AC.addressCalc(DEPLOYER_CONTRACT, centerPriceAddress_);\n            _checkIsContract(centerPrice_);\n            // note: if address is made 0 then as well in the last swap currentPrice is updated on storage, so code will start using that automatically\n            _dexVariables[dexId_] =\n                (dexVariables_ & ~(X19 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS)) |\n                (centerPriceAddress_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS) |\n                (uint256(1) << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_SHIFT_ACTIVE);\n\n            _centerPriceShift[dexId_] = (_centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT)) |\n                (percent_ << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT) |\n                (time_ << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIME_TO_SHIFT) |\n                (block.timestamp << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_TIMESTAMP);\n        } else {\n            _dexVariables[dexId_] = (_dexVariables[dexId_] & ~(X19 << DSL.BITS_DEX_LITE_DEX_VARIABLES_CENTER_PRICE_CONTRACT_ADDRESS));\n\n            _centerPriceShift[dexId_] = _centerPriceShift[dexId_] & ~(X73 << DSL.BITS_DEX_LITE_CENTER_PRICE_SHIFT_PERCENT);\n        }\n\n        emit LogUpdateCenterPriceAddress(dexKey_, dexId_, _dexVariables[dexId_], _centerPriceShift[dexId_], centerPriceAddress_, percent_, time_);\n    }\n\n    /// @dev deposit tokens into the dex\n    /// @param dexKey_ the dex key\n    /// @param token0Amount_ the token0 amount\n    /// @param token1Amount_ the token1 amount\n    function deposit(DexKey calldata dexKey_, uint256 token0Amount_, uint256 token1Amount_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        _transferTokenIn(dexKey_.token0, token0Amount_);\n        _transferTokenIn(dexKey_.token1, token1Amount_);\n\n        (uint256 token0NumeratorPrecision_, uint256 token0DenominatorPrecision_) = \n            _calculateNumeratorAndDenominatorPrecisions((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5);\n        (uint256 token1NumeratorPrecision_, uint256 token1DenominatorPrecision_) = \n            _calculateNumeratorAndDenominatorPrecisions((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5);\n\n        uint256 token0TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60) + \n            ((token0Amount_ * token0NumeratorPrecision_) / token0DenominatorPrecision_);\n        uint256 token1TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60) + \n            ((token1Amount_ * token1NumeratorPrecision_) / token1DenominatorPrecision_);\n\n        _dexVariables[dexId_] = (dexVariables_ & ~(X120 << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED)) |\n            (token0TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) |\n            (token1TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        emit LogDeposit(dexKey_, dexId_, _dexVariables[dexId_], token0Amount_, token1Amount_);\n    }\n\n    /// @dev withdraw tokens from the dex\n    /// @param dexKey_ the dex key\n    /// @param token0Amount_ the token0 amount\n    /// @param token1Amount_ the token1 amount\n    /// @param to_ the address to send the tokens to\n    function withdraw(DexKey calldata dexKey_, uint256 token0Amount_, uint256 token1Amount_, address to_) public _onlyDelegateCall {\n        bytes8 dexId_ = bytes8(keccak256(abi.encode(dexKey_)));\n        uint256 dexVariables_ = _dexVariables[dexId_];\n        if (dexVariables_ == 0) {\n            revert DexNotInitialized(dexId_);\n        }\n\n        _transferTokenOut(dexKey_.token0, token0Amount_, to_);\n        _transferTokenOut(dexKey_.token1, token1Amount_, to_);\n\n        (uint256 token0NumeratorPrecision_, uint256 token0DenominatorPrecision_) = \n            _calculateNumeratorAndDenominatorPrecisions((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_DECIMALS) & X5);\n        (uint256 token1NumeratorPrecision_, uint256 token1DenominatorPrecision_) = \n            _calculateNumeratorAndDenominatorPrecisions((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_DECIMALS) & X5);\n\n        uint256 token0TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) & X60) - \n            ((token0Amount_ * token0NumeratorPrecision_) / token0DenominatorPrecision_);\n        uint256 token1TotalSupply_ = ((dexVariables_ >> DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED) & X60) - \n            ((token1Amount_ * token1NumeratorPrecision_) / token1DenominatorPrecision_);\n\n        _dexVariables[dexId_] = (dexVariables_ & ~(X120 << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED)) |\n            (token0TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_0_TOTAL_SUPPLY_ADJUSTED) |\n            (token1TotalSupply_ << DSL.BITS_DEX_LITE_DEX_VARIABLES_TOKEN_1_TOTAL_SUPPLY_ADJUSTED);\n\n        emit LogWithdraw(dexKey_, dexId_, _dexVariables[dexId_], token0Amount_, token1Amount_);\n    }\n\n    /// @dev update the extra data address in storage slot\n    /// @param extraDataAddress_ the address to set in the extra data slot\n    function updateExtraDataAddress(address extraDataAddress_) public _onlyDelegateCall {\n        assembly {\n            sstore(EXTRA_DATA_SLOT, extraDataAddress_)\n        }\n\n        emit LogUpdateExtraDataAddress(extraDataAddress_);\n    }\n\n    /// @dev collect revenue from the dex\n    /// @param tokens_ the tokens to collect revenue from\n    /// @param amounts_ the amounts of tokens to collect revenue from\n    /// @param to_ the address to send the tokens to\n    function collectRevenue(address[] calldata tokens_, uint256[] calldata amounts_, address to_) public _onlyDelegateCall {\n        for (uint256 i = 0; i < tokens_.length; ) {\n            _transferTokenOut(tokens_[i], amounts_[i], to_);\n            unchecked {++i;}\n        }\n\n        emit LogCollectRevenue(tokens_, amounts_, to_);\n    }\n}\n\n"
    },
    "contracts/protocols/dexLite/adminModule/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"../other/commonImport.sol\";\n\nstruct InitializeParams {\n    DexKey dexKey;\n    uint256 fee;\n    uint256 revenueCut;\n    bool rebalancingStatus;\n    uint256 centerPrice;\n    uint256 centerPriceContract; // nonce\n    uint256 upperPercent;\n    uint256 lowerPercent;\n    uint256 upperShiftThreshold;\n    uint256 lowerShiftThreshold;\n    uint256 shiftTime; // in seconds // for rebalancing\n    uint256 minCenterPrice;\n    uint256 maxCenterPrice;\n    uint256 token0Amount;\n    uint256 token1Amount;\n}\n\nstruct InitializeVariables {\n    bytes8 dexId;\n    uint256 token0Decimals;\n    uint256 token1Decimals;\n    uint256 token0NumeratorPrecision;\n    uint256 token0DenominatorPrecision;\n    uint256 token1NumeratorPrecision;\n    uint256 token1DenominatorPrecision;\n}"
    },
    "contracts/protocols/dexLite/other/commonImport.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./variables.sol\";\n\nabstract contract CommonImport is Variables {}\n"
    },
    "contracts/protocols/dexLite/other/constantVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./events.sol\";\n\nabstract contract ConstantVariables {\n    /*//////////////////////////////////////////////////////////////\n                                CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// bytes32(uint256(keccak256(\"FLUID_DEX_LITE_EXTRA_DATA\")) - 1)\n    bytes32 internal constant EXTRA_DATA_SLOT = 0x7e8134afb5ed35d36cb65e24b9a4712a52bb77d952806c1acf50970d2107797f;\n\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1\n    /// The exact slot which stored the admin address in infinite proxy of liquidity contracts\n    bytes32 internal constant LIQUIDITY_GOVERNANCE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    bool internal constant SWAP_SINGLE = true;\n    bool internal constant SWAP_HOP = false;\n\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 internal constant NATIVE_TOKEN_DECIMALS = 18;\n    uint256 internal constant TOKENS_DECIMALS_PRECISION = 9;\n\n    uint8 internal constant MIN_TOKEN_DECIMALS = 6;\n    uint8 internal constant MAX_TOKEN_DECIMALS = 18;\n\n    uint256 internal constant SMALL_COEFFICIENT_SIZE = 20;\n    uint256 internal constant BIG_COEFFICIENT_SIZE = 32;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant X1 = 0x1;\n    uint256 internal constant X2 = 0x3;\n    uint256 internal constant X5 = 0x1f;\n    uint256 internal constant X7 = 0x7f;\n    uint256 internal constant X13 = 0x1fff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X19 = 0x7ffff;\n    uint256 internal constant X20 = 0xfffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X28 = 0xfffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X40 = 0xffffffffff;\n    uint256 internal constant X56 = 0xffffffffffffff;\n    uint256 internal constant X60 = 0xfffffffffffffff;\n    uint256 internal constant X73 = 0x1ffffffffffffffffff;\n    uint256 internal constant X120 = 0xffffffffffffffffffffffffffffff;\n    uint256 internal constant X128 = 0xffffffffffffffffffffffffffffffff;\n   \n    uint256 internal constant TWO_DECIMALS = 1e2;\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant SIX_DECIMALS = 1e6;\n\n    uint256 internal constant PRICE_PRECISION = 1e27;\n\n    /// after swap token0 reserves should not be less than token1InToken0 / MINIMUM_LIQUIDITY_SWAP\n    /// after swap token1 reserves should not be less than token0InToken1 / MINIMUM_LIQUIDITY_SWAP\n    uint256 internal constant MINIMUM_LIQUIDITY_SWAP = 1e4;\n\n    bytes32 internal constant ESTIMATE_SWAP = keccak256(bytes(\"ESTIMATE_SWAP\"));\n}\n"
    },
    "contracts/protocols/dexLite/other/events.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./interfaces.sol\";\n\nevent LogSwap(uint256 swapData, uint256 dexVariables);\n// swapData\n// First 64 bits => 0   - 63  => dexId\n// Next  1  bit  => 64        => swap 0 to 1 (1 => true, 0 => false)\n// Next  60 bits => 65  - 124 => amount in adjusted\n// Next  60 bits => 125 - 184 => amount out adjusted\n\n// dexVariables\n// Same as variables.sol"
    },
    "contracts/protocols/dexLite/other/immutableVariables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport \"./constantVariables.sol\";\n\n// TODO\n// import { IFluidDexFactory } from \"../../interfaces/iDexFactory.sol\";\n// import { Error } from \"../../error.sol\";\n// import { ErrorTypes } from \"../../errorTypes.sol\";\n\nabstract contract ImmutableVariables is ConstantVariables {\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Address of liquidity contract\n    IFluidLiquidity internal immutable LIQUIDITY;\n\n    /// @dev Address of contract used for deploying center price & hook related contract\n    address internal immutable DEPLOYER_CONTRACT;\n}\n"
    },
    "contracts/protocols/dexLite/other/interfaces.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\nimport { IERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IFluidLiquidity } from \"../../../liquidity/interfaces/iLiquidity.sol\";\nimport \"./structs.sol\";\n\ninterface IERC20WithDecimals is IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ninterface IDexLiteCallback {\n    function dexCallback(address token_, uint256 amount_, bytes calldata data_) external;\n}\n\ninterface ICenterPrice {\n    /// @notice Retrieves the center price for the pool\n    /// @dev This function is marked as non-constant (potentially state-changing) to allow flexibility in price fetching mechanisms.\n    ///      While typically used as a read-only operation, this design permits write operations if needed for certain token pairs\n    ///      (e.g., fetching up-to-date exchange rates that may require state changes).\n    /// @return price The current price of token0 in terms of token1, expressed with 27 decimal places\n    function centerPrice(address token0_, address token1_) external returns (uint256);\n}"
    },
    "contracts/protocols/dexLite/other/structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./events.sol\";\n\nstruct DexKey {\n    address token0;\n    address token1;\n    bytes32 salt;\n}\n\nstruct TransferParams {\n    address to;\n    bool isCallback;\n    bytes callbackData;\n    bytes extraData;\n}\n"
    },
    "contracts/protocols/dexLite/other/variables.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.29;\n\nimport \"./immutableVariables.sol\";\n\nabstract contract Variables is ImmutableVariables {\n    /// @dev admin address\n    mapping(address => uint256) internal _isAuth;\n\n    /// @dev dexes list\n    DexKey[] internal _dexesList;\n\n    // First 13 bits => 0   - 12  => fee (1% = 10000, max value: 8191 = .8191%)\n    // Next  7  bits => 13  - 19  => revenue cut (1 = 1%)\n    // Next  2  bit  => 20  - 21  => rebalancing status (0 = off, 1 = on but not active, 2 = rebalancing active towards upper range, 3 = rebalancing active towards lower range)\n    // Next  1  bit  => 22        => is center price shift active\n    // Next  40 bits => 23  - 62  => center price. Center price from where the ranges will be calculated. BigNumber (32 bits precision, 8 bits exponent)\n    // Next  19 bits => 63  - 81  => center price contract address (Deployment Factory Nonce)\n    // Next  1  bit  => 82        => range percent shift active or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time\n    // Next  14 bits => 83  - 96  => upperPercent (1% = 100) upperRange - upperRange * upperPercent = centerPrice. Hence, upperRange = centerPrice / (1 - upperPercent)\n    // Next  14 bits => 97  - 110 => lowerPercent (1% = 100) lowerRange = centerPrice - centerPrice * lowerPercent\n    // Next  1  bit  => 111       => threshold percent shift active or not, 0 = false, 1 = true, if true than that means governance has updated the below percents and the update should happen with a specified time\n    // Next  7 bits  => 112 - 118 => upper shift threshold percent, 1 = 1%. 100 = 100%. if currentPrice > (centerPrice + (upperRange - centerPrice) * (100 - upperShiftThresholdPercent) / 100) then trigger shift\n    // Next  7 bits  => 119 - 125 => lower shift threshold percent, 1 = 1%. 100 = 100%. if currentPrice < (centerPrice - (centerPrice - lowerRange) * (100 - lowerShiftThresholdPercent) / 100) then trigger shift\n    // Next  5  bits => 126 - 130 => token 0 decimals\n    // Next  5  bits => 131 - 135 => token 1 decimals\n    // Next  60 bits => 136 - 195 => total token 0 adjusted amount\n    // Next  60 bits => 196 - 255 => total token 1 adjusted amount\n    /// @dev dex id => dex variables\n    mapping(bytes8 => uint256) internal _dexVariables;\n\n    /// NOTE: Center price shift is always fuzzy, and can shift because of rebalancing or center price shift\n    // First 33 bits => 0   - 32  => last interaction timestamp (only stored when either rebalancing or center price shift is active)\n    /// REBALANCING RELATED THINGS\n    // First 24 bits => 33  - 56  => shifting time (max ~194 days)\n    // Next  28 bits => 57  - 84  => max center price. BigNumber (20 bits precision, 8 bits exponent)\n    // Next  28 bits => 85  - 112 => min center price. BigNumber (20 bits precision, 8 bits exponent)\n    /// CENTER PRICE SHIFT RELATED THINGS\n    // First 20 bits => 113 - 132 => % shift (1% = 1000)\n    // Next  20 bits => 133 - 152 => time to shift that percent, ~12 days max\n    // Next  33 bits => 153 - 185 => timestamp of when the shift started\n    // Last 70 bits empty\n    /// @dev dex id => center price shift\n    mapping(bytes8 => uint256) internal _centerPriceShift;\n\n    /// Range Shift (first 128 bits)\n    // First 14 bits => 0  - 13 => old upper range percent\n    // Next  14 bits => 14 - 27 => old lower range percent\n    // Next  20 bits => 28 - 47 => time to shift in seconds, ~12 days max, shift can last for max ~12 days\n    // Next  33 bits => 48 - 80 => timestamp of when the shift has started.\n    // Last 175 bits empty\n    /// @dev dex id => range shift\n    mapping(bytes8 => uint256) internal _rangeShift;\n\n    // First 7  bits => 0  - 6  => old upper threshold percent\n    // Next  7  bits => 7  - 13 => old lower threshold percent\n    // Next  20 bits => 14 - 33 => time to shift in seconds, ~12 days max, shift can last for max ~12 days\n    // Next  33 bits => 34 - 66 => timestamp of when the shift has started\n    // Last 189 bits empty\n    /// @dev dex id => threshold shift\n    mapping(bytes8 => uint256) internal _thresholdShift;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}